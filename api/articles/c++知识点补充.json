{"title":"c++知识点补充","uid":"dc168ae0e61f850398133451b0c7647e","slug":"c++知识点补充","date":"2022-08-04T11:10:31.000Z","updated":"2023-08-25T02:51:32.425Z","comments":true,"path":"api/articles/c++知识点补充.json","keywords":null,"cover":"https://www.loliapi.com/acg/?id=10","content":"<h1 id=\"c-c\"><a href=\"#c-c\" class=\"headerlink\" title=\"c&#x2F;c++\"></a>c&#x2F;c++</h1><h2 id=\"写代码的要求\"><a href=\"#写代码的要求\" class=\"headerlink\" title=\"写代码的要求\"></a>写代码的要求</h2><h3 id=\"尽可能的使用const-修饰代码\"><a href=\"#尽可能的使用const-修饰代码\" class=\"headerlink\" title=\"尽可能的使用const 修饰代码\"></a>尽可能的使用const 修饰代码</h3><ul>\n<li>避免无意识中修改变量导致出错</li>\n<li>使他能够接受const 和 非const 参数</li>\n<li>是4程序能够正常生成 临时变量 — 引用的时候</li>\n</ul>\n<h3 id=\"命名规则\"><a href=\"#命名规则\" class=\"headerlink\" title=\"命名规则\"></a>命名规则</h3><ul>\n<li>小驼峰 myPoint</li>\n<li>大驼峰 MyPoint</li>\n<li>匈牙利 my_point</li>\n<li><code>__</code>  和 <code>_</code>开头的命令被保留给实现，一般不用</li>\n</ul>\n<h3 id=\"不使用using-namespace-std\"><a href=\"#不使用using-namespace-std\" class=\"headerlink\" title=\"不使用using namespace std\"></a>不使用using namespace std</h3><ul>\n<li>使用 using std::cout;</li>\n<li>使用 using std::cin;</li>\n</ul>\n<h3 id=\"使用容器的时候包含头文件\"><a href=\"#使用容器的时候包含头文件\" class=\"headerlink\" title=\"使用容器的时候包含头文件\"></a>使用容器的时候包含头文件</h3><ul>\n<li>iostream 包含了string 但 自己还是包含一下</li>\n</ul>\n<h3 id=\"给函数传递参数时的选择\"><a href=\"#给函数传递参数时的选择\" class=\"headerlink\" title=\"给函数传递参数时的选择\"></a>给函数传递参数时的选择</h3><ol>\n<li>当传递类或者结构体这种数据量大的数据时一般选择 引用传递</li>\n<li>传递数组时 智能选择指针</li>\n<li>当传递普通数据类型的变量是 选择值传递</li>\n</ol>\n<h3 id=\"数组的初始化\"><a href=\"#数组的初始化\" class=\"headerlink\" title=\"数组的初始化\"></a>数组的初始化</h3><ul>\n<li><code>int array[10] &#123; 1, 2, 3, 4 &#125;</code>c11可以忽略等于号</li>\n<li><code>int array[10] &#123;&#125;</code>c11可以直接用空括号初始化0</li>\n<li>列表禁止缩窄定义 比如long  -&gt;  int</li>\n</ul>\n<h2 id=\"未完成的事情\"><a href=\"#未完成的事情\" class=\"headerlink\" title=\"未完成的事情\"></a>未完成的事情</h2><ul>\n<li>类型关键字<ul>\n<li>static</li>\n<li>const</li>\n<li>extern</li>\n<li>volatile</li>\n<li>auto 自动识别类型</li>\n<li>register</li>\n<li>thread_local</li>\n<li>mutable 使用这个可以修改常量函数里的变量</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"类和对象\"><a href=\"#类和对象\" class=\"headerlink\" title=\"类和对象\"></a>类和对象</h2><h3 id=\"类的基本结构\"><a href=\"#类的基本结构\" class=\"headerlink\" title=\"类的基本结构\"></a>类的基本结构</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Person : public Animal &#x2F;&#x2F;继承自Animal 类\n&#123;\nprivate: &#x2F;&#x2F;访问权限\n    int x; &#x2F;&#x2F;数据成员\n   \npublic:\n    Person() &#x3D; default; &#x2F;&#x2F;默认构造函数，不写系统会自动生成\n    Person(int x); &#x2F;&#x2F;重载的构造函数\n    explicit Person(int x, int y, int z &#x3D; 0); &#x2F;&#x2F;禁止发生隐式抓换构造函数\n    Person(const Person &amp;p); &#x2F;&#x2F;拷贝构造函数 当需要拷贝的时候调用\n    Person(const Person &amp;&amp;p); &#x2F;&#x2F;移动构造函数 当需要移动数据完成构造的时候调用\n    ~Person() &#x3D; default; &#x2F;&#x2F;析构函数，不加default默认会生成一个，他没有参数\n    void printPerson(); &#x2F;&#x2F;普通成员函数\n    virtual void test(); &#x2F;&#x2F;虚函数\n    virtual void test_1() &#x3D; 0; &#x2F;&#x2F;纯虚函数，如果不重写，他的子类或者他本身无法生成对象\n    int getX() const; &#x2F;&#x2F;禁止修改数据成员，隐含 const 修饰 this指针。\n&#125;;</code></pre>\n\n\n\n<h3 id=\"explicit-关键字\"><a href=\"#explicit-关键字\" class=\"headerlink\" title=\"explicit  关键字\"></a><strong>explicit</strong>  关键字</h3><p>一般用于构造函数&#x2F;拷贝构造函数 加上之后就不能发生隐式类型转换，必须指明</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\n    explicit Person(int x &#x3D; 0, int y &#x3D;1) &#x2F;&#x2F;添加禁止隐式转换关键字\n    &#123;\n\n    &#125;\n&#125;;\nvoid test()\n&#123;\n    Person p1 &#x3D; 3; &#x2F;&#x2F;发生隐式类型转换\n    &#x2F;&#x2F;程序处理 ： Person temp(3); p1 &#x3D; temp; \n    &#x2F;&#x2F;未来避免发生不必要的错误，使用explicit关键字禁止 隐式类型转换\n\n    &#x2F;&#x2F;加上explicit关键字后\n    &#x2F;&#x2F; Person p1 &#x3D; 3; 错误\n    &#x2F;&#x2F; Person p1 &#x3D; Person(3); 正确\n&#125;\n</code></pre>\n\n<h3 id=\"匿名对象\"><a href=\"#匿名对象\" class=\"headerlink\" title=\"匿名对象\"></a>匿名对象</h3><p>调用成员函数 直接生成匿名对象，调用函数</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Person\n&#123;\npublic:\n    void test()\n    &#123;\n        cout &lt;&lt; &quot;hello world &quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Person().test();\n    return 0;\n&#125;\n</code></pre>\n\n<h3 id=\"default-关键字\"><a href=\"#default-关键字\" class=\"headerlink\" title=\"default 关键字\"></a><strong>default</strong> 关键字</h3><p>生成一个默认的构造函数或者析构函数</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Person\n&#123;\n    &#x2F;&#x2F;生成默认构造函数，该函数不可重新定义\n  \tPerson() &#x3D; default; \n&#125;;</code></pre>\n\n\n\n<h3 id=\"noexcept-关键字\"><a href=\"#noexcept-关键字\" class=\"headerlink\" title=\"noexcept  关键字\"></a><strong>noexcept</strong>  关键字</h3><p>告诉编译器该函数 默认是安全的不会弹出错误</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void test() noexcept;\nvoid test() noexcept(true); &#x2F;&#x2F;等同于上面那个\nvoid test(); &#x2F;&#x2F;不加关键字默认是可能弹出错误\nvoid test() noexcept(false); &#x2F;&#x2F;等同于上面那个\n\n&#x2F;&#x2F;函数 声明&#x2F;定义 有一个有noexcept关键字，其他所有 声明&#x2F;定义 都要有关键字</code></pre>\n\n<h3 id=\"override-关键字\"><a href=\"#override-关键字\" class=\"headerlink\" title=\"override 关键字\"></a>override 关键字</h3><p>表示对一个virtual 函数进行重写</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Animal&#123;\n    virtual void eat()&#123;\n        std::cout &lt;&lt; &quot;Animal is eating\\n&quot;;\n    &#125;\n&#125;;\n\nclass Person : public Animal&#123;\n    void eat() override&#123; &#x2F;&#x2F;对虚函数进行重写\n        std::cout &lt;&lt; &quot;Person is eating\\n&quot;;\n    &#125;\n&#125;;</code></pre>\n\n<h3 id=\"final-关键字\"><a href=\"#final-关键字\" class=\"headerlink\" title=\"final 关键字\"></a><strong>final</strong> 关键字</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;表示该类禁止被继承\nclass Person final : public Animal&#123;\n    virtual void eat() final; &#x2F;&#x2F;表示该函数禁止被子类重写\n&#125;</code></pre>\n\n\n\n\n<h2 id=\"常用函数补充\"><a href=\"#常用函数补充\" class=\"headerlink\" title=\"常用函数补充\"></a>常用函数补充</h2><h3 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"#include &lt;limits.h&gt;\"></a><code>#include &lt;limits.h&gt;</code></h3><p>保存各类型的最大值 INT_MAX</p>\n<h3 id=\"include-1\"><a href=\"#include-1\" class=\"headerlink\" title=\"#include &lt;stdlib.h&gt;\"></a><code>#include &lt;stdlib.h&gt;</code></h3><p>常用申请内存函数</p>\n<ol>\n<li><code>int *num = (int *)malloc(8 * sizeof(int));</code> &#x2F;&#x2F;分配内存但是不重置为0 失败返回NULL</li>\n<li><code>int *num = (int *)calloc(8, sizeof(int)); </code>&#x2F;&#x2F;分配n 个size内存 并置为0 失败返回 NULL</li>\n<li><code>num = realloc(num, 9 * sizeof(int)); </code>重新分配内存可大可小<ul>\n<li>后面空间小于 原有空间则释放多余地址</li>\n<li>后面空间大于 原有空间则查看后面连续地址是否有剩余 没有则把旧数据拷贝到新地址且返回新地址</li>\n<li>指针为NULL 且size不为0 作用和malloc类似 返回新的地址</li>\n<li>指针不为NULL 但是size为0  则空间会被释放 返回NULL</li>\n<li>空间不足 返回NULL原空间内容不变</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"include-2\"><a href=\"#include-2\" class=\"headerlink\" title=\"#include &lt;limits&gt;\"></a><code>#include &lt;limits&gt;</code></h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>std::numeric_limits <a href=\"https://so.csdn.net/so/search?q=%E7%B1%BB%E6%A8%A1%E6%9D%BF&spm=1001.2101.3001.7020\">类模板</a>来获取类型的最大值和最小值等</p></blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;limits&gt;\n\nint main(int argc, char *argv[]) &#123;\n    std::cout &lt;&lt; &quot;long long max&quot; &lt;&lt; std::numeric_limits&lt;long long&gt;::max() &lt;&lt; std::endl; &#x2F;&#x2F; 获取long long最大值\n    std::cout &lt;&lt; &quot;long long min&quot; &lt;&lt; std::numeric_limits&lt;long long&gt;::min() &lt;&lt; std::endl;\n    \n    std::cout &lt;&lt; &quot;int max&quot; &lt;&lt; std::numeric_limits&lt;long long&gt;::max() &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;int min&quot; &lt;&lt; std::numeric_limits&lt;long long&gt;::min() &lt;&lt; std::endl;\n&#125;\n</code></pre>\n\n\n\n<h2 id=\"常见关键字补充\"><a href=\"#常见关键字补充\" class=\"headerlink\" title=\"常见关键字补充\"></a>常见关键字补充</h2><h3 id=\"const-关键字\"><a href=\"#const-关键字\" class=\"headerlink\" title=\"const 关键字\"></a>const 关键字</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nint main(int argc, char const *argv[])\n&#123;\n    int x &#x3D; 666, b &#x3D; 666;\n    int *p;\n\n    const int *point &#x3D; &amp;x; &#x2F;&#x2F;const 在左边表示他指向的值不能修改\n    &#x2F;&#x2F; *point &#x3D; 666; &#x2F;&#x2F;不能修改，报错\n    point &#x3D; &amp;b; &#x2F;&#x2F;可以修改\n\n    int *const point_2 &#x3D; &amp;x;\n    *point_2 &#x3D; 666;\n    &#x2F;&#x2F; point_2 &#x3D; &amp;b; &#x2F;&#x2F;不能修改，报错\n\n    const int temp &#x3D; 666;\n\n    return 0;\n&#125;</code></pre>\n\n<p><strong>总结：</strong></p>\n<ol>\n<li><p>const 加在类型的前面则表示后面的值不能修改 <code>const int *point = &amp;x;</code></p>\n<ol>\n<li>不能通过point 修改 x 的值</li>\n<li>可以修改point 指向的值</li>\n</ol>\n</li>\n<li><p>const 加在类型的后面则表示这个变量不能修改<code>int *const point_2 = &amp;x;</code></p>\n<ol>\n<li>可以通过point_2 修改x的值</li>\n<li>不能修改point_2 指向的值</li>\n</ol>\n</li>\n<li><p>尽量加const 这样可以接受const的值，普通变量是不能接受const的值的</p>\n</li>\n</ol>\n<h3 id=\"auto-关键字\"><a href=\"#auto-关键字\" class=\"headerlink\" title=\"auto 关键字\"></a>auto 关键字</h3><p>自动识别数据类型</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing std::cout;\nusing std::endl;\nusing std::vector;\n\nclass Student\n&#123;\n\nprivate:\n  int age;\n\npublic:\n  explicit Student()\n  &#123;\n    age &#x3D; 666;\n  &#125;\n\n&#125;;\n\nint main(int argc, char **argv)\n&#123;\n    vector&lt;int&gt; v1;\n    for(int i &#x3D; 0; i &lt; 10; i++)&#123;\n      v1.push_back(i);\n    &#125;\n\n    &#x2F;&#x2F;自动识别迭代器类型\n    for (auto begin &#x3D; v1.begin(); begin !&#x3D; v1.end(); begin++)\n    &#123;\n      cout &lt;&lt; *begin &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n    for (vector&lt;int&gt;::iterator begin &#x3D; v1.begin(); begin !&#x3D; v1.end(); begin++)\n    &#123;\n      cout &lt;&lt; *begin &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    auto &amp;hell &#x3D; v1;\n    cout &lt;&lt; &quot;hello &quot; &lt;&lt; hell[0] &lt;&lt; endl;\n    return 0;\n&#125;\n</code></pre>\n\n<h3 id=\"右值引用符号\"><a href=\"#右值引用符号\" class=\"headerlink\" title=\"&amp;&amp; 右值引用符号\"></a>&amp;&amp; 右值引用符号</h3><h2 id=\"宏定义知识点补充\"><a href=\"#宏定义知识点补充\" class=\"headerlink\" title=\"宏定义知识点补充\"></a>宏定义知识点补充</h2><ol>\n<li><p><code>#</code>号 转化成字符串</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#define STR(s) #s &#x2F;&#x2F;将s转化成字符串\nSTR(sss) &#x2F;&#x2F;结果 &quot;sss&quot;</code></pre>\n\n\n</li>\n<li><p><code>##</code> 连接前后两个 </p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#define CAT(a,b) a##e##b &#x2F;&#x2F;CAT(2,10) 结果2e10 也就是 2的十次方</code></pre>\n\n\n</li>\n<li></li>\n</ol>\n<h2 id=\"指针知识补充\"><a href=\"#指针知识补充\" class=\"headerlink\" title=\"指针知识补充\"></a>指针知识补充</h2><h3 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h3><h3 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h3><ul>\n<li><strong>std::unique_ptr</strong> 独占指针<ol>\n<li>在任何给定的时刻只能有一指针管理内存</li>\n<li>在超出作用域后，指针将会释放内存</li>\n<li>只能move 不能 copy</li>\n</ol>\n</li>\n<li><strong>std::shard_ptr</strong> 计数指针<ol>\n<li>他可以copy</li>\n<li>可以计数 赋值一次 计数器加一，销毁一次计数器减一</li>\n<li>unique_ptr 可以传递给shard_ptr 但是shard不能传递给unique_ptr</li>\n<li>拥有计数方法 .use_count() 统计指针被复制的次数。 被删除一次则加一</li>\n</ol>\n</li>\n<li><strong>std::weak_ptr</strong> <ol>\n<li>没有所有权</li>\n<li>不能解引用和使用箭头函数</li>\n<li>一般用于标识别的对象信息，用shard和unique会释放掉内存</li>\n</ol>\n</li>\n</ul>\n<p>详细列子</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nclass Person\n&#123;\nprivate:\n    \npublic:\n    std::string name&#123;&quot;hello&quot;&#125;;\n    \n    Person(); &#x2F;&#x2F;默认调用函数\n    Person(const std::string &amp;name);\n    void set_name(const std::string &amp;name);\n    ~Person();\n    Person(const Person &amp;&amp;p);\n&#125;;\n\nPerson::Person() \n&#123;\n    std::cout &lt;&lt; &quot;name : &quot; &lt;&lt; name &lt;&lt; &quot;  Person 类创建\\n&quot;;\n&#125;\n\nPerson::Person(const std::string &amp;name) : name(name)\n&#123;\n    std::cout &lt;&lt; &quot;name : &quot; &lt;&lt; name &lt;&lt; &quot;  Person 类创建\\n&quot;;\n&#125;\n\nPerson::~Person()\n&#123;\n    std::cout &lt;&lt; &quot;name : &quot; &lt;&lt; name &lt;&lt; &quot;  Person 类析构\\n&quot;;\n&#125;\n\nvoid Person::set_name(const std::string &amp;name)\n&#123;\n    this-&gt;name &#x3D; name;\n&#125;\nPerson::Person(const Person &amp;&amp;p)\n&#123;\n    std::cout &lt;&lt; &quot;移动构造函数调用\\n&quot;;\n    this-&gt;name &#x3D; p.name;\n&#125;\n\nvoid test_0()\n&#123;\n    Person p1; &#x2F;&#x2F;会自己调用析构函数\n    Person *p2 &#x3D; new Person; &#x2F;&#x2F;不会自己调用析构函数\n    delete p2; &#x2F;&#x2F;需要自己调用\n&#125;\n\nvoid unique_ptr()\n&#123;\n    &#x2F;&#x2F;创建方式1 使用原始指针创建\n    Person *p &#x3D; new Person;\n    std::unique_ptr&lt;Person&gt; u_p&#123;p&#125;; &#x2F;&#x2F;通过原始指针创建\n\n    &#x2F;&#x2F;独占指针需要满足条件1 这里两个都能调用不满足，把它指向空\n    p &#x3D; nullptr;\n\n    std::cout &lt;&lt; &quot;u_p : name --- &quot; &lt;&lt; u_p-&gt;name &lt;&lt; std::endl; &#x2F;&#x2F;正常调用，函数结束后自己会调用析构函数\n\n    \n    &#x2F;&#x2F;创建方式2 使用new 创建\n    std::unique_ptr&lt;Person&gt; u_p_2&#123;new Person(&quot;yuri&quot;)&#125;;\n    \n    &#x2F;&#x2F;创建方式3 使用std::make 创建\n\n    std::unique_ptr&lt;Person&gt; u_p_3 &#x3D;  std::make_unique&lt;Person&gt;(&quot;yuri is yes&quot;);\n\n    std::cout &lt;&lt; &quot;u_p_2.get() : &quot; &lt;&lt; u_p_2.get() &lt;&lt; std::endl; &#x2F;&#x2F;打印地址\n    &#x2F;&#x2F;打印的是指针指向的地址，而不是&amp; 打印指针的地址\n\n    std::unique_ptr&lt;Person&gt; up &#x3D; std::make_unique&lt;Person&gt;(&quot;yuri&quot;);\n    auto hello &#x3D; std::move(up); &#x2F;&#x2F;只能通过move使用\n    &#x2F;&#x2F; auto hello &#x3D; up; 报错，无法复制，只能move\n&#125;\n\nvoid shared_ptr()\n&#123;\n    std::shared_ptr&lt;int&gt; int_1 &#x3D; std::make_shared&lt;int&gt;(100);\n    std::cout &lt;&lt; &quot;(1 cout &#x3D; &quot; &lt;&lt; int_1.use_count() &lt;&lt; std::endl;\n    auto int_2 &#x3D; int_1; &#x2F;&#x2F;复制一次计数器加一\n    std::cout &lt;&lt; &quot;(1 cout &#x3D; &quot; &lt;&lt; int_1.use_count() &lt;&lt; std::endl; &#x2F;&#x2F;指向同一个地方，计数器都变成2\n    std::cout &lt;&lt; &quot;(2 cout &#x3D; &quot; &lt;&lt; int_2.use_count() &lt;&lt; std::endl;\n\n    int_1.reset(); &#x2F;&#x2F;释放一次\n    std::cout &lt;&lt; &quot;(1 cout &#x3D; &quot; &lt;&lt; int_1.use_count() &lt;&lt; std::endl; &#x2F;&#x2F;已经删除了，计数器编程0\n    std::cout &lt;&lt; &quot;(2 cout &#x3D; &quot; &lt;&lt; int_2.use_count() &lt;&lt; std::endl; &#x2F;&#x2F;这里不变，因为原来的删除，所以减一变成0了\n    &#x2F;&#x2F;在函数里面调用的时候会加一，出来之后又会不变\n&#125;\n\nvoid weak_ptr()\n&#123;\n    &#x2F;&#x2F;没有所有权\n    &#x2F;&#x2F;不能解引用和使用箭头函数\n    &#x2F;&#x2F;一般用于标识别的对象信息，用shard和unique会释放掉内存\n    auto p &#x3D; std::make_shared&lt;Person&gt;();\n    std::weak_ptr&lt;Person&gt; weak_p(p);\n    &#x2F;&#x2F; p-&gt;name; 错误无法调用\n    \n&#125;\n\nint main(int argc, char const *argv[])\n&#123;\n    unique_ptr(); &#x2F;&#x2F;独占指针\n    shared_ptr(); &#x2F;&#x2F;计数指针\n    return 0;\n&#125;</code></pre>\n\n","text":"c&#x2F;c++写代码的要求尽可能的使用const 修饰代码 避免无意识中修改变量导致出错 使他能够接受const 和 非const 参数 是4程序能够正常...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[{"name":"c/c++","slug":"c-c","count":9,"path":"api/categories/c-c.json"}],"tags":[{"name":"c/c++","slug":"c-c","count":9,"path":"api/tags/c-c.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#c-c\"><span class=\"toc-text\">c&#x2F;c++</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E8%A6%81%E6%B1%82\"><span class=\"toc-text\">写代码的要求</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BD%BF%E7%94%A8const-%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">尽可能的使用const 修饰代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99\"><span class=\"toc-text\">命名规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E4%BD%BF%E7%94%A8using-namespace-std\"><span class=\"toc-text\">不使用using namespace std</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%8C%85%E5%90%AB%E5%A4%B4%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">使用容器的时候包含头文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%99%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E6%97%B6%E7%9A%84%E9%80%89%E6%8B%A9\"><span class=\"toc-text\">给函数传递参数时的选择</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">数组的初始化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E4%BA%8B%E6%83%85\"><span class=\"toc-text\">未完成的事情</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">类和对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">类的基本结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#explicit-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">explicit  关键字</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">匿名对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#default-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">default 关键字</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#noexcept-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">noexcept  关键字</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#override-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">override 关键字</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#final-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">final 关键字</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">常用函数补充</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#include\"><span class=\"toc-text\">#include &lt;limits.h&gt;</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#include-1\"><span class=\"toc-text\">#include &lt;stdlib.h&gt;</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#include-2\"><span class=\"toc-text\">#include &lt;limits&gt;</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">常见关键字补充</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#const-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">const 关键字</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#auto-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">auto 关键字</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%AC%A6%E5%8F%B7\"><span class=\"toc-text\">&amp;&amp; 右值引用符号</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">宏定义知识点补充</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">指针知识补充</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88\"><span class=\"toc-text\">函数指针</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88\"><span class=\"toc-text\">智能指针</span></a></li></ol></li></ol></li></ol>","author":{"name":"yuri2078","slug":"blog-author","avatar":"https://www.loliapi.com/acg/pp/","link":"/","description":"一名与世无争的百合控!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"css大全","uid":"456a9f884f236ceaa1db3db112545b25","slug":"css大全","date":"2022-08-04T11:11:49.000Z","updated":"2023-08-25T02:53:05.538Z","comments":true,"path":"api/articles/css大全.json","keywords":null,"cover":"https://www.loliapi.com/acg/?id=14","text":"文本direction 定义 属性规定文本的方向 &#x2F; 书写方向。 语法 direction:ltr|rtl|inherit; 属性值 值 描述 ltr...","link":"","photos":[],"count_time":{"symbolsCount":"9.1k","symbolsTime":"8 mins."},"categories":[{"name":"小记","slug":"小记","count":4,"path":"api/categories/小记.json"}],"tags":[{"name":"web","slug":"web","count":1,"path":"api/tags/web.json"}],"author":{"name":"yuri2078","slug":"blog-author","avatar":"https://www.loliapi.com/acg/pp/","link":"/","description":"一名与世无争的百合控!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"linux常用命令","uid":"a190eeed437f3803134f7d0fcd279e47","slug":"linux常用命令","date":"2022-08-02T14:43:33.000Z","updated":"2023-08-25T02:54:14.305Z","comments":true,"path":"api/articles/linux常用命令.json","keywords":null,"cover":"https://www.loliapi.com/acg/?id=19","text":"安装软件 sudo apt-get update sudo apt-get uprdge sudo apt upgrade -y 升级系统包 sudo apt ...","link":"","photos":[],"count_time":{"symbolsCount":691,"symbolsTime":"1 mins."},"categories":[{"name":"小记","slug":"小记","count":4,"path":"api/categories/小记.json"}],"tags":[{"name":"常用命令","slug":"常用命令","count":3,"path":"api/tags/常用命令.json"},{"name":"linux","slug":"linux","count":1,"path":"api/tags/linux.json"}],"author":{"name":"yuri2078","slug":"blog-author","avatar":"https://www.loliapi.com/acg/pp/","link":"/","description":"一名与世无争的百合控!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}