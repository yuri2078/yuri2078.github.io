{"title":"planning_component（1）","uid":"1e2fbbe6f8df83a5d7f4d6a9281e7fa7","slug":"planning-component","date":"2023-01-11T05:35:05.000Z","updated":"2023-08-25T03:13:17.891Z","comments":true,"path":"api/articles/planning-component.json","keywords":null,"cover":"https://www.loliapi.com/acg/?id=21","content":"<h1 id=\"apollo-planning-模块分析\"><a href=\"#apollo-planning-模块分析\" class=\"headerlink\" title=\"apollo planning 模块分析\"></a>apollo planning 模块分析</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>只做简单分析，教程来自 知乎 -&gt; <a href=\"https://www.zhihu.com/people/ge-ge-yao-xue-xi\">自动驾驶Player</a></p>\n<p>更加详细的内容请去看 <a href=\"https://zhuanlan.zhihu.com/p/494813220?utm_id=0\">原文</a></p></blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里是我的个人理解不是官方理解，也不是原文的理解</p></blockquote>\n<h3 id=\"planning-结构\"><a href=\"#planning-结构\" class=\"headerlink\" title=\"planning 结构\"></a>planning 结构</h3><ol>\n<li><p>Planning_component 入口 (作为cyber 组件的入口，我把它当作第一层)</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这个作为planning 模块的入口主要的作用就是两点</p>\n<p>1、对一些基础的东西进行初始化 (init 函数)</p>\n<p>2、作为cyber 组件 不断执行规划逻辑 (Proc 函数)</p></blockquote>\n</li>\n<li><p>三个规划器 （默认的是 <code>OnLanePlanning</code>）</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>我认为这是<code>planning</code> 的第二层。 在 <code>component</code> 中选择规划器进行下一步的规划</p></blockquote>\n<ol>\n<li><code>NavinPlanning</code> 处理普通道路  </li>\n<li><code>OnLanePlanning</code> 处理情况复杂的人行横道  主要的应用场景是开放道路的自动驾驶</li>\n<li><code>OpenSpasePlanning</code> 处理泊车或者断路掉头情况   主要的应用场景是自主泊车和狭窄路段的掉头</li>\n</ol>\n</li>\n<li><p>两个路径规划器</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>每个规划器会调用自己对应的路径规划器，然后来进行路径规划。</p>\n<p>他在<code>OnLanePlanning</code> 的构造函数中就被构造，然后初始化</p>\n<p>他的作用就是选择创建对应的 planner </p></blockquote>\n<ol>\n<li><code>on_lane_planner_dispatcher</code> (OpenSpasePlanning 、 OnLanePlanning 都是用的这个)</li>\n<li><code>navi_planner_dispatcher</code> (NavinPlanning 用的这个)</li>\n</ol>\n</li>\n<li><p>几个 planner </p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>每个planner 承担了具体的规划逻辑(Plan 函数)</p></blockquote>\n<p>主要介绍 <code>on_lane_planner_dispatcher</code> 下默认的 <code>public_road_planner</code></p>\n</li>\n</ol>\n<h3 id=\"planning-规划流程\"><a href=\"#planning-规划流程\" class=\"headerlink\" title=\"planning 规划流程\"></a>planning 规划流程</h3><ol>\n<li>在入口<code>planning_component</code> 中进行初始化(Init 函数只执行一次)<ol>\n<li>选择对应的规划器，并进行初始化</li>\n<li>加载配置，检查配置文件</li>\n<li>读取一系列的配置数据</li>\n</ol>\n</li>\n<li>在入口<code>planning_component</code> 中执行具体的规划逻辑(Proc 函数，不断执行)<ol>\n<li>检查路由</li>\n<li>执行具体规划逻辑</li>\n<li>发布新路线</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"cyber-组件\"><a href=\"#cyber-组件\" class=\"headerlink\" title=\"cyber 组件\"></a>cyber 组件</h2><p><strong>每个组件的入口函数是 Proc 函数</strong></p>\n<ol>\n<li><p>apollo 是基于 cyber 通信框架的</p>\n</li>\n<li><p>具体可以去看我的另外一篇文章 <a href=\"https://yuri2078.github.io/2022/09/17/cyber/\">cyberRT开发教程</a></p>\n</li>\n<li><p>下面是一个最基础的cyber 组件框架 （.h 文件） planning 的差不多也是如此</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#ifndef MY_COMPONENTS\n#define MY_COMPONENTS\n\n#include &quot;cyber&#x2F;cyber.h&quot; &#x2F;&#x2F; cyber 基础头文件\n#include &quot;cyber&#x2F;component&#x2F;component.h&quot; &#x2F;&#x2F; component 基础头文件\n#include &quot;cyber&#x2F;demo_cpp&#x2F;components&#x2F;Student.pb.h&quot; &#x2F;&#x2F; 通信载体protobuf 文件编译成的c++ 文件\n\nusing apollo::cyber::Component;\nusing apollo::cyber::demo_cpp::Student;\n\n&#x2F;&#x2F;继承需要添加数据模板\nclass my_components : public Component&lt;Student&gt; \n&#123;\nprivate:\n    &#x2F;* data *&#x2F;\npublic:\n\n    bool Init() override; &#x2F;&#x2F;表示重写函数，初始化函数\n    bool Proc(const std::shared_ptr&lt;Student&gt; &amp;stu) override; &#x2F;&#x2F;数据处理函数\n    \n&#125;;\n\nCYBER_REGISTER_COMPONENT(my_components) &#x2F;&#x2F;注册组件\n#endif</code></pre></li>\n</ol>\n<h3 id=\"简单cyber-组件的组成\"><a href=\"#简单cyber-组件的组成\" class=\"headerlink\" title=\"简单cyber 组件的组成\"></a>简单cyber 组件的组成</h3><h4 id=\"Conponent-类\"><a href=\"#Conponent-类\" class=\"headerlink\" title=\"Conponent 类\"></a>Conponent 类</h4><p><strong>知识点</strong></p>\n<ol>\n<li><p>他继承自<code>Component</code> 类，他是所有通信模块的基类</p>\n</li>\n<li><p>他的原型  他是继承自<code>ConponentBase</code> 这个我就不管了，这是隔壁cyber的东西</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">template &lt;typename M0, typename M1, typename M2,  typename M3&gt; &#x2F;&#x2F; 接受四个模板类型 也就是消息载体 - protobuf\nclass Component&lt;M0, M1, M2, M3&gt; : public ComponentBase &#123; </code></pre>\n</li>\n<li><p><code>Component&lt;M0, M1, M2, M3&gt;</code> 由此看出他最多接收4个数据类型。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>他需要的都是通信载体，也就是protobuf 类信息，如果不知道这是啥，可以百度捏。简单来说就是自定义数据类</p></blockquote>\n</li>\n</ol>\n<h4 id=\"Init-函数\"><a href=\"#Init-函数\" class=\"headerlink\" title=\"Init 函数\"></a>Init 函数</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 继承自<code>Component_base </code> 纯虚类，所以需要重写</p></blockquote>\n<p>函数原型 <code>virtual bool Init() = 0;</code></p>\n<p><strong>知识点</strong></p>\n<ol>\n<li>Init 函数来自于Conponent_base 类 </li>\n<li>他不接受任何参数，并且会在执行Proc 函数之前被调用</li>\n<li>用途是 初始化</li>\n</ol>\n<h4 id=\"Proc-函数\"><a href=\"#Proc-函数\" class=\"headerlink\" title=\"Proc 函数\"></a>Proc 函数</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>继承自 <code>Conponent</code> 纯虚类，所以需要重写</p></blockquote>\n<p>函数原型  - planning 模块对应的函数原型</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">virtual bool Proc(const std::shared_ptr&lt;M0&gt;&amp; msg,\n                  const std::shared_ptr&lt;M1&gt;&amp; msg1,\n                  const std::shared_ptr&lt;M2&gt;&amp; msg2, \n                  const std::shared_ptr&lt;M2&gt;&amp; msg3) &#x3D; 0;</code></pre>\n\n<p>知识点 </p>\n<ol>\n<li>他最多只能接受四个msg</li>\n<li>我们需要在Proc 函数中完成对传入的消息载体的处理</li>\n<li>这里是处理消息的主要地方</li>\n</ol>\n<h4 id=\"注册组件\"><a href=\"#注册组件\" class=\"headerlink\" title=\"注册组件\"></a>注册组件</h4><p><code>CYBER_REGISTER_COMPONENT(my_components)</code> &#x2F;&#x2F;对组件进行注册</p>\n<h3 id=\"别的模块\"><a href=\"#别的模块\" class=\"headerlink\" title=\"别的模块\"></a>别的模块</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>通过上面对简单组件的了解我门可以知道</p></blockquote>\n<ol>\n<li>apollo 的模块也是一个cyber组件</li>\n<li>每个模块通过接受消息，然后处理消息，最后将消息发送出去（通过cyber 通信框架）</li>\n<li>cyber 采用的通信协议是谷歌的protobuf 所以<code>Component</code> 类需要接受的四个消息都是由protobuf编译来的</li>\n<li>一个组件的入口函数是proc函数，但之前他会执行init 函数就行初始化</li>\n<li>Proc 函数才是组件的主体处理逻辑</li>\n</ol>\n<h2 id=\"常用类\"><a href=\"#常用类\" class=\"headerlink\" title=\"常用类\"></a>常用类</h2><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>EgoInfo</code>类</td>\n<td>包含了自车信息，例如：当前位置点，车辆状态，外围Box等。</td>\n</tr>\n<tr>\n<td><code>Frame</code>类</td>\n<td>包含了一次Planning计算循环中的所有信息。</td>\n</tr>\n<tr>\n<td><code>FrameManager</code>类</td>\n<td>Frame的管理器，每个Frame会有一个整数型id。</td>\n</tr>\n<tr>\n<td><code>LocalView</code>类</td>\n<td>Planning计算需要的输入，下文将看到其定义。</td>\n</tr>\n<tr>\n<td><code>Obstacle</code>类</td>\n<td>描述一个特定的障碍物。障碍物会有一个唯一的id来区分。</td>\n</tr>\n<tr>\n<td><code>PlanningContext</code>类</td>\n<td>Planning全局相关的信息，例如：是否正在变道。这是一个<a href=\"https://en.wikipedia.org/wiki/Singleton_pattern\">单例</a>。</td>\n</tr>\n<tr>\n<td><code>ReferenceLineInfo</code>类</td>\n<td>车辆行驶的参考线，下文会专门讲解。</td>\n</tr>\n<tr>\n<td><code>path</code>文件夹</td>\n<td>描述车辆路线信息。包含：PathData，DiscretizedPath，FrenetFramePath三个类。</td>\n</tr>\n<tr>\n<td><code>speed</code>文件夹</td>\n<td>描述车辆速度信息。包含SpeedData，STPoint，StBoundary三个类。</td>\n</tr>\n<tr>\n<td><code>trajectory</code>文件夹</td>\n<td>描述车辆轨迹信息。包含DiscretizedTrajectory，PublishableTrajectory，TrajectoryStitcher三个类。</td>\n</tr>\n<tr>\n<td><code>planning_gflags.h</code></td>\n<td>定义了模块需要的许多常量，例如各个配置文件的路径。</td>\n</tr>\n</tbody></table>\n<h2 id=\"planning-模块入口\"><a href=\"#planning-模块入口\" class=\"headerlink\" title=\"planning 模块入口\"></a>planning 模块入口</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>有了上面的基础相信你已经可以很好的阅读planning的基础源码了，让我们一起来看看planning的cyber组件吧</p>\n<p>本文的源码基于 apollo-8.0 edu 版本</p>\n<p>两个源码重要的地方都有注释</p></blockquote>\n<h3 id=\"planning-component-h\"><a href=\"#planning-component-h\" class=\"headerlink\" title=\"planning_component.h\"></a>planning_component.h</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">namespace apollo &#123;\nnamespace planning &#123;\n\nclass PlanningComponent final &#x2F;&#x2F; final\n    : public cyber::Component&lt;prediction::PredictionObstacles, canbus::Chassis,\n                              localization::LocalizationEstimate&gt; &#123;\n public:\n  PlanningComponent() &#x3D; default; &#x2F;&#x2F;默认构造函数\n\n  ~PlanningComponent() &#x3D; default; &#x2F;&#x2F;默认析构函数\n\n public:\n  bool Init() override;\n\n  bool Proc(const std::shared_ptr&lt;prediction::PredictionObstacles&gt;&amp; rediction_obstacles, &#x2F;&#x2F; 预测的障碍物信息(prediction_obstacles)\n            const std::shared_ptr&lt;canbus::Chassis&gt;&amp; chassis, &#x2F;&#x2F; 车辆底盘(chassis)信息(车辆的速度，加速度，航向角等信息)\n            const std::shared_ptr&lt;localization::LocalizationEstimate&gt;&amp; localization_estimate)  &#x2F;&#x2F; 车辆当前位置(localization_estimate)\n            override; &#x2F;&#x2F; 表示重写函数\n\n private:\n  void CheckRerouting();\n  bool CheckInput();\n\n private:\n  std::shared_ptr&lt;cyber::Reader&lt;perception::TrafficLightDetection&gt;&gt; traffic_light_reader_; &#x2F;&#x2F; 读取红绿灯信息\n  std::shared_ptr&lt;cyber::Reader&lt;routing::RoutingResponse&gt;&gt; routing_reader_; &#x2F;&#x2F; 读取路由模块信息\n  std::shared_ptr&lt;cyber::Reader&lt;planning::PadMessage&gt;&gt; pad_msg_reader_;\n  std::shared_ptr&lt;cyber::Reader&lt;relative_map::MapMsg&gt;&gt; relative_map_reader_; &#x2F;&#x2F; 读取相对地图信息\n  std::shared_ptr&lt;cyber::Reader&lt;storytelling::Stories&gt;&gt; story_telling_reader_;\n\n  std::shared_ptr&lt;cyber::Writer&lt;ADCTrajectory&gt;&gt; planning_writer_; &#x2F;&#x2F; 将规划好的线路，发布到Control模块订阅的Topic中\n  std::shared_ptr&lt;cyber::Writer&lt;routing::RoutingRequest&gt;&gt; rerouting_writer_; &#x2F;&#x2F; 是否需要重新规划路线\n  std::shared_ptr&lt;cyber::Writer&lt;PlanningLearningData&gt;&gt; planning_learning_data_writer_;\n\n  std::mutex mutex_;\n  perception::TrafficLightDetection traffic_light_;\n  routing::RoutingResponse routing_;\n  planning::PadMessage pad_msg_;\n  relative_map::MapMsg relative_map_;\n  storytelling::Stories stories_;\n\n  LocalView local_view_;   &#x2F;&#x2F; 用于存放模块运行需要的数据\n\n  std::unique_ptr&lt;PlanningBase&gt; planning_base_; &#x2F;&#x2F; 规划器基类\n  std::shared_ptr&lt;DependencyInjector&gt; injector_;\n\n  PlanningConfig config_;\n  MessageProcess message_process_;\n&#125;;\n\n&#x2F;&#x2F; 在cyber中注册组件\nCYBER_REGISTER_COMPONENT(PlanningComponent)\n\n&#125;  &#x2F;&#x2F; namespace planning\n&#125;  &#x2F;&#x2F; namespace apollo</code></pre>\n\n<h3 id=\"planning-component-cc\"><a href=\"#planning-component-cc\" class=\"headerlink\" title=\"planning_component.cc\"></a>planning_component.cc</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">namespace apollo &#123;\nnamespace planning &#123;\n\nusing apollo::cyber::ComponentBase;\nusing apollo::hdmap::HDMapUtil;\nusing apollo::perception::TrafficLightDetection;\nusing apollo::relative_map::MapMsg;\nusing apollo::routing::RoutingRequest;\nusing apollo::routing::RoutingResponse;\nusing apollo::storytelling::Stories;\n\n&#x2F;&#x2F;初始化函数，用于初始化planning模块\nbool PlanningComponent::Init() &#123;\n  AINFO &lt;&lt; &quot;planning component init 函数调用!&quot;;\n  injector_ &#x3D; std::make_shared&lt;DependencyInjector&gt;();\n\n  &#x2F;&#x2F;NavinPlanning 处理普通道路  \n  &#x2F;&#x2F;OnLanePlanning 处理情况复杂的人行横道  主要的应用场景是开放道路的自动驾驶。\n  &#x2F;&#x2F;OpenSpasePlanning 处理泊车或者断路掉头情况   主要的应用场景是自主泊车和狭窄路段的掉头\n\n\n&#x2F;&#x2F;选择相应的规划器 默认是OnLanePlanning 模块\n  AINFO &lt;&lt; &quot;选择相应的规划器 默认是OnLanePlanning 模块 &quot;;\n  if (FLAGS_use_navigation_mode) &#123;\n    planning_base_ &#x3D; std::make_unique&lt;NaviPlanning&gt;(injector_); &#x2F;&#x2F;相对地图规划器\n    AINFO &lt;&lt; &quot;默认选择的是 : naviplanning&quot;;\n  &#125; else &#123;\n    planning_base_ &#x3D; std::make_unique&lt;OnLanePlanning&gt;(injector_); &#x2F;&#x2F;默认规划器\n    AINFO &lt;&lt; &quot;默认选择的是 : onlaneplanning&quot;;\n  &#125;\n\n&#x2F;&#x2F;加载config 文件\n  AINFO &lt;&lt; &quot;正在加载配置文件&quot;;\n  ACHECK(ComponentBase::GetProtoConfig(&amp;config_))\n      &lt;&lt; &quot;加载配置文件失败! 失败文件路径 ： &quot;\n      &lt;&lt; ComponentBase::ConfigFilePath();\n\n&#x2F;&#x2F; 这一句不知道干啥的\n  if (FLAGS_planning_offline_learning ||\n      config_.learning_mode() !&#x3D; PlanningConfig::NO_LEARNING) &#123;\n    if (!message_process_.Init(config_, injector_)) &#123;\n      AERROR &lt;&lt; &quot;failed to init MessageProcess&quot;;\n      return false;\n    &#125;\n  &#125;\n\n&#x2F;&#x2F;执行OnLanePlanning 的初始化\n  AINFO &lt;&lt; &quot;正在执行planning_base 的初始化 &quot;;\n  planning_base_-&gt;Init(config_);\n\n  &#x2F;&#x2F;获取路由（routig）模块信息\n  AINFO &lt;&lt; &quot;获取路由 routing信息&quot;;\n  routing_reader_ &#x3D; node_-&gt;CreateReader&lt;RoutingResponse&gt;(  &#x2F;&#x2F;新建reader\n      config_.topic_config().routing_response_topic(),\n      [this](const std::shared_ptr&lt;RoutingResponse&gt;&amp; routing) &#123;\n        AINFO &lt;&lt; &quot; 收到路由数据：运行路由回调。&quot;\n              &lt;&lt; routing-&gt;header().DebugString();\n        std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n        routing_.CopyFrom(*routing);\n      &#125;);\n\n  &#x2F;&#x2F;读取红绿灯\n  AINFO &lt;&lt; &quot;读取红绿灯信息&quot;;\n  traffic_light_reader_ &#x3D; node_-&gt;CreateReader&lt;TrafficLightDetection&gt;(\n      config_.topic_config().traffic_light_detection_topic(),\n      [this](const std::shared_ptr&lt;TrafficLightDetection&gt;&amp; traffic_light) &#123;\n        ADEBUG &lt;&lt; &quot;Received traffic light data: run traffic light callback.&quot;;\n        std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n        traffic_light_.CopyFrom(*traffic_light);\n      &#125;);\n\n  pad_msg_reader_ &#x3D; node_-&gt;CreateReader&lt;PadMessage&gt;(\n      config_.topic_config().planning_pad_topic(),\n      [this](const std::shared_ptr&lt;PadMessage&gt;&amp; pad_msg) &#123;\n        ADEBUG &lt;&lt; &quot;Received pad data: run pad callback.&quot;;\n        std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n        pad_msg_.CopyFrom(*pad_msg);\n      &#125;);\n\n  story_telling_reader_ &#x3D; node_-&gt;CreateReader&lt;Stories&gt;(\n      config_.topic_config().story_telling_topic(),\n      [this](const std::shared_ptr&lt;Stories&gt;&amp; stories) &#123;\n        ADEBUG &lt;&lt; &quot;Received story_telling data: run story_telling callback.&quot;;\n        std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n        stories_.CopyFrom(*stories);\n      &#125;);\n\n&#x2F;&#x2F;是否使用导航模式\n  AINFO &lt;&lt; &quot;判断是否使用导航模式&quot;;\n  if (FLAGS_use_navigation_mode) &#123;\n    &#x2F;&#x2F;读取相对地图\n    AINFO &lt;&lt; &quot;使用导航模式，正在读取相对地图&quot;;\n    relative_map_reader_ &#x3D; node_-&gt;CreateReader&lt;MapMsg&gt;(\n        config_.topic_config().relative_map_topic(),\n        [this](const std::shared_ptr&lt;MapMsg&gt;&amp; map_message) &#123;\n          ADEBUG &lt;&lt; &quot;Received relative map data: run relative map callback.&quot;;\n          std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n          relative_map_.CopyFrom(*map_message);\n        &#125;);\n  &#125;\n  &#x2F;&#x2F;发布规划好的线路\n  planning_writer_ &#x3D; node_-&gt;CreateWriter&lt;ADCTrajectory&gt;(\n      config_.topic_config().planning_trajectory_topic());\n\n  &#x2F;&#x2F;发布重新规划请求\n  rerouting_writer_ &#x3D; node_-&gt;CreateWriter&lt;RoutingRequest&gt;(\n      config_.topic_config().routing_request_topic());\n\n  planning_learning_data_writer_ &#x3D; node_-&gt;CreateWriter&lt;PlanningLearningData&gt;(\n      config_.topic_config().planning_learning_data_topic());\n\n  return true;\n&#125;\n\nbool PlanningComponent::Proc(\n    const std::shared_ptr&lt;prediction::PredictionObstacles&gt;&amp; prediction_obstacles, &#x2F;&#x2F; 预测的障碍物信息(prediction_obstacles)\n    const std::shared_ptr&lt;canbus::Chassis&gt;&amp; chassis, &#x2F;&#x2F; 车辆底盘(chassis)信息(车辆的速度，加速度，航向角等信息)\n    const std::shared_ptr&lt;localization::LocalizationEstimate&gt;&amp; localization_estimate) &#x2F;&#x2F; 车辆当前位置(localization_estimate) \n&#123;\n  AINFO &lt;&lt; &quot;planning—component Proc 函数调用!&quot;;\n  ACHECK(prediction_obstacles !&#x3D; nullptr);  &#x2F;&#x2F; 检查障碍物信息是不是为空\n\n  &#x2F;&#x2F; check and process possible rerouting request\n  &#x2F;&#x2F; 检查是否需要重新规划路线\n  CheckRerouting();\n\n  &#x2F;&#x2F; process fused input data\n  &#x2F;&#x2F; 数据放入local_view 中，并且检查输入的数据\n  local_view_.prediction_obstacles &#x3D; prediction_obstacles;\n  local_view_.chassis &#x3D; chassis;\n  local_view_.localization_estimate &#x3D; localization_estimate;\n  &#123;\n    std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n    if (!local_view_.routing ||\n        hdmap::PncMap::IsNewRouting(*local_view_.routing, routing_)) &#123;\n      local_view_.routing &#x3D;\n          std::make_shared&lt;routing::RoutingResponse&gt;(routing_);\n    &#125;\n  &#125;\n  &#123;\n    std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n    local_view_.traffic_light &#x3D;\n        std::make_shared&lt;TrafficLightDetection&gt;(traffic_light_);\n    local_view_.relative_map &#x3D; std::make_shared&lt;MapMsg&gt;(relative_map_);\n  &#125;\n  &#123;\n    std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n    local_view_.pad_msg &#x3D; std::make_shared&lt;PadMessage&gt;(pad_msg_);\n  &#125;\n  &#123;\n    std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n    local_view_.stories &#x3D; std::make_shared&lt;Stories&gt;(stories_);\n  &#125;\n\n  if (!CheckInput()) &#123;\n    AERROR &lt;&lt; &quot;Input check failed&quot;;\n    return false;\n  &#125;\n\n  if (config_.learning_mode() !&#x3D; PlanningConfig::NO_LEARNING) &#123;\n    &#x2F;&#x2F; data process for online training\n    message_process_.OnChassis(*local_view_.chassis);\n    message_process_.OnPrediction(*local_view_.prediction_obstacles);\n    message_process_.OnRoutingResponse(*local_view_.routing);\n    message_process_.OnStoryTelling(*local_view_.stories);\n    message_process_.OnTrafficLightDetection(*local_view_.traffic_light);\n    message_process_.OnLocalization(*local_view_.localization_estimate);\n  &#125;\n\n  &#x2F;&#x2F; publish learning data frame for RL test\n  if (config_.learning_mode() &#x3D;&#x3D; PlanningConfig::RL_TEST) &#123;\n    PlanningLearningData planning_learning_data;\n    LearningDataFrame* learning_data_frame &#x3D;\n        injector_-&gt;learning_based_data()-&gt;GetLatestLearningDataFrame();\n    if (learning_data_frame) &#123;\n      planning_learning_data.mutable_learning_data_frame()\n                            -&gt;CopyFrom(*learning_data_frame);\n      common::util::FillHeader(node_-&gt;Name(), &amp;planning_learning_data);\n      planning_learning_data_writer_-&gt;Write(planning_learning_data);\n    &#125; else &#123;\n      AERROR &lt;&lt; &quot;fail to generate learning data frame&quot;;\n      return false;\n    &#125;\n    return true;\n  &#125;\n\n  ADCTrajectory adc_trajectory_pb;\n\n  &#x2F;&#x2F; 执行注册好的planning信息，并且生成线路\n  planning_base_-&gt;RunOnce(local_view_, &amp;adc_trajectory_pb); \n  auto start_time &#x3D; adc_trajectory_pb.header().timestamp_sec();\n  common::util::FillHeader(node_-&gt;Name(), &amp;adc_trajectory_pb);\n\n  &#x2F;&#x2F; modify trajectory relative time due to the timestamp change in header\n  const double dt &#x3D; start_time - adc_trajectory_pb.header().timestamp_sec();\n  for (auto&amp; p : *adc_trajectory_pb.mutable_trajectory_point()) &#123;\n    p.set_relative_time(p.relative_time() + dt);\n  &#125;\n  &#x2F;&#x2F; 发布信息\n  planning_writer_-&gt;Write(adc_trajectory_pb);\n\n  &#x2F;&#x2F; record in history\n  auto* history &#x3D; injector_-&gt;history();\n  history-&gt;Add(adc_trajectory_pb);\n\n  return true;\n&#125;\n\nvoid PlanningComponent::CheckRerouting() &#123;\n  AINFO &lt;&lt; &quot;检查路由函数调用!&quot;;\n  auto* rerouting &#x3D; injector_-&gt;planning_context()\n                        -&gt;mutable_planning_status()\n                        -&gt;mutable_rerouting();\n  if (!rerouting-&gt;need_rerouting()) &#123;\n    return;\n  &#125;\n  common::util::FillHeader(node_-&gt;Name(), rerouting-&gt;mutable_routing_request());\n  rerouting-&gt;set_need_rerouting(false);\n  rerouting_writer_-&gt;Write(rerouting-&gt;routing_request());\n&#125;\n\nbool PlanningComponent::CheckInput() &#123;\n  AINFO &lt;&lt; &quot;检查输入函数调用!&quot;;\n  ADCTrajectory trajectory_pb;\n  auto* not_ready &#x3D; trajectory_pb.mutable_decision()\n                        -&gt;mutable_main_decision()\n                        -&gt;mutable_not_ready();\n\n  if (local_view_.localization_estimate &#x3D;&#x3D; nullptr) &#123;\n    not_ready-&gt;set_reason(&quot;localization not ready&quot;);\n  &#125; else if (local_view_.chassis &#x3D;&#x3D; nullptr) &#123;\n    not_ready-&gt;set_reason(&quot;chassis not ready&quot;);\n  &#125; else if (HDMapUtil::BaseMapPtr() &#x3D;&#x3D; nullptr) &#123;\n    not_ready-&gt;set_reason(&quot;地图没有准备好!&quot;);\n  &#125; else &#123;\n    &#x2F;&#x2F; nothing\n  &#125;\n\n  if (FLAGS_use_navigation_mode) &#123;\n    if (!local_view_.relative_map-&gt;has_header()) &#123;\n      not_ready-&gt;set_reason(&quot;relative map not ready&quot;);\n    &#125;\n  &#125; else &#123;\n    if (!local_view_.routing-&gt;has_header()) &#123;\n      not_ready-&gt;set_reason(&quot;路由没有准备好!&quot;);\n    &#125;\n  &#125;\n\n  if (not_ready-&gt;has_reason()) &#123;\n    AERROR &lt;&lt; not_ready-&gt;reason() &lt;&lt; &quot;; skip the planning cycle.&quot;;\n    common::util::FillHeader(node_-&gt;Name(), &amp;trajectory_pb);\n    planning_writer_-&gt;Write(trajectory_pb);\n    return false;\n  &#125;\n  return true;\n&#125;\n\n&#125;  &#x2F;&#x2F; namespace planning\n&#125;  &#x2F;&#x2F; namespace apoll</code></pre>\n\n<h3 id=\"Init-函数-1\"><a href=\"#Init-函数-1\" class=\"headerlink\" title=\"Init 函数\"></a>Init 函数</h3><p>他主要做三件事</p>\n<ol>\n<li>选择规划器</li>\n<li>读取并检查配置文件</li>\n<li>读取并检查输入的数据</li>\n</ol>\n<h3 id=\"Proc-函数-1\"><a href=\"#Proc-函数-1\" class=\"headerlink\" title=\"Proc 函数\"></a>Proc 函数</h3><p>planning 的 Proc 函数需要接收三个消息分别是,他们也是plannning启动的关键输入</p>\n<ol>\n<li><code>const std::shared_ptr&lt;prediction::PredictionObstacles&gt;</code> &#x2F;&#x2F; 预测的障碍物信(prediction_obstacles)</li>\n<li><code>const std::shared_ptr&lt;canbus::Chassis&gt;</code>&#x2F;&#x2F; 车辆底盘(chassis)信息(车辆的速度，加速度，航向角等信息)</li>\n<li><code>const std::shared_ptr&lt;localization::LocalizationEstimate&gt; </code> &#x2F;&#x2F; 车辆当前位置(localization_estimate)</li>\n</ol>\n<p>他的任务就是不断进行规划</p>\n<ol>\n<li>检查数据</li>\n<li>生成路线，并将新的路线发布</li>\n</ol>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">Log file created at: 2023&#x2F;01&#x2F;11 18:53:45\nRunning on machine: in-dev-docker\nLog line format: [IWEF]mmdd hh:mm:ss.uuuuuu threadid file:line] msg\nI0111 18:53:45.310637 20642 class_loader_utility.h:79] registerclass:PlanningComponent,apollo::cyber::ComponentBase,&#x2F;opt&#x2F;apollo&#x2F;neo&#x2F;packages&#x2F;planning-dev&#x2F;latest&#x2F;lib&#x2F;libplanning_component.so\nI0111 18:53:45.315501 20642 planning_component.cc:43] planning component init 函数调用! &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nI0111 18:53:45.315992 20642 planning_component.cc:52] 选择相应的规划器 默认是OnLanePlanning 模块 \nI0111 18:53:45.316018 20642 planning_component.cc:58] 默认选择的是 : onlaneplanning\nI0111 18:53:45.316021 20642 planning_component.cc:62] 正在加载配置文件\nI0111 18:53:45.318209 20642 planning_component.cc:77] 正在执行planning_base 的初始化 \nI0111 18:53:45.828123 20642 planning_component.cc:81] 获取路由 routing信息\nI0111 18:53:45.828958 20642 planning_component.cc:92] 读取红绿灯信息\nI0111 18:53:45.829712 20642 planning_component.cc:118] 判断是否使用导航模式\nE0111 18:53:45.880179 20647 reference_line_provider.cc:195] Routing is not ready.\nE0111 18:53:45.940057 20648 reference_line_provider.cc:195] Routing is not ready.\n\nI0111 18:53:50.352406 20652 planning_component.cc:149] planning—component Proc 函数调用! &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nI0111 18:53:50.352429 20652 planning_component.cc:239] 检查路由函数调用!\nE0111 18:53:50.352438 20652 pnc_map.cc:267] Route is empty.\nI0111 18:53:50.352522 20652 planning_component.cc:252] 检查输入函数调用!\nE0111 18:53:50.352545 20652 planning_component.cc:279] 路由没有准备好!; skip the planning cycle.\nE0111 18:53:50.352632 20652 planning_component.cc:185] Input check failed\nE0111 18:53:50.400401 20649 reference_line_provider.cc:195] Routing is not ready.\nE0111 18:53:50.450472 20657 reference_line_provider.cc:195] Routing is not ready.\nI0111 18:53:50.451936 20650 planning_component.cc:149] planning—component Proc 函数调用! &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nI0111 18:53:50.451952 20650 planning_component.cc:239] 检查路由函数调用!\nE0111 18:53:50.451958 20650 pnc_map.cc:267] Route is empty.\nI0111 18:53:50.452006 20650 planning_component.cc:252] 检查输入函数调用!\nE0111 18:53:50.452024 20650 planning_component.cc:279] 路由没有准备好!; skip the planning cycle.\nE0111 18:53:50.452095 20650 planning_component.cc:185] Input check failed\nE0111 18:53:50.510488 20644 reference_line_provider.cc:195] Routing is not ready.\nI0111 18:53:50.552870 20645 planning_component.cc:149] planning—component Proc 函数调用! &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</code></pre>\n\n<p>总结 ：</p>\n<ol>\n<li>通过日志文件我们发现Init 函数只会执行一次，而Proc函数则是在规划期间一直执行的</li>\n<li>init函数只是起到了初始化的作用</li>\n<li>真正进行规划的Proc函数</li>\n</ol>\n<h2 id=\"c-知识点\"><a href=\"#c-知识点\" class=\"headerlink\" title=\"c++ 知识点\"></a>c++ 知识点</h2><ol>\n<li><code>std::unique_ptr</code> 智能指针 -&gt; 独占指针，该指针指向的空间不能共享，只能move，并且生存周期结束会释放对应的内存</li>\n<li><code>std::shared_ptr</code> 智能指针 -&gt; 共享指针，该指针指向的空间可以共享，能够计数，并且生存周期结束会释放对应的内存</li>\n<li><code>final</code> 表示该类禁止继承</li>\n<li><code>override</code> 表示重写函数</li>\n<li><code>default</code> 表示自动生成的默认构造&#x2F;析构函数</li>\n<li><code>namespace</code> 命名空间</li>\n<li><code>using </code> 使用命名空间&#x2F;别名</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li><p>planning 模块继承自 <code>Component</code> 类，他需要接收三个模板类型分别是</p>\n<ul>\n<li><code>const std::shared_ptr&lt;prediction::PredictionObstacles&gt;</code> &#x2F;&#x2F; 预测的障碍物信(prediction_obstacles)</li>\n<li><code>const std::shared_ptr&lt;canbus::Chassis&gt;</code>&#x2F;&#x2F; 车辆底盘(chassis)信息(车辆的速度，加速度，航向角等信息)</li>\n<li><code>const std::shared_ptr&lt;localization::LocalizationEstimate&gt; </code> &#x2F;&#x2F; 车辆当前位置(localization_estimate)</li>\n</ul>\n</li>\n<li><p>以上三个数据类型对应了三个protobuf文件里面存储者各种数据 需要的可以去看看</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>vscode 安装protobuf 插件既可以舒适的浏览portobuf文件，如果还需要深入了解各种含义可以自行百度</p></blockquote>\n<ol>\n<li><code>/apollo_workspace/modules/common_msgs/prediction_msgs/prediction_obstacle.proto</code> </li>\n<li><code>/apollo_workspace/modules/common_msgs/chassis_msgs/chassis.proto</code></li>\n<li><code>/apollo_workspace/modules/common_msgs/localization_msgs/localization.proto</code></li>\n</ol>\n</li>\n<li><p>planning 默认选择的是OnLanePlanning 规划器，所以后续会以这个为主讲解</p>\n</li>\n<li><p>planning 执行所检查的配置文件大多在<code>/apollo_workspace/modules/planning/conf</code> 中可以找到</p>\n</li>\n<li><p>因为默认选择onlaneplanning 所以以后的planning_base 默认都是指向OnLanePlanning类</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">planning_base_ &#x3D; std::make_unique&lt;OnLanePlanning&gt;(injector_);</code></pre>\n</li>\n<li><p>vscode 中按抓ctrl + 函数名可以直接跳转</p>\n</li>\n</ol>\n","feature":true,"text":"apollo planning 模块分析 只做简单分析，教程来自 知乎 -&gt; 自动驾驶Player 更加详细的内容请去看 原文 前言 这里是我的个人理解不...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[{"name":"apollo-源码分析","slug":"apollo-源码分析","count":3,"path":"api/categories/apollo-源码分析.json"}],"tags":[{"name":"apollo","slug":"apollo","count":12,"path":"api/tags/apollo.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#apollo-planning-%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90\"><span class=\"toc-text\">apollo planning 模块分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#planning-%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">planning 结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#planning-%E8%A7%84%E5%88%92%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">planning 规划流程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#cyber-%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">cyber 组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95cyber-%E7%BB%84%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90\"><span class=\"toc-text\">简单cyber 组件的组成</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Conponent-%E7%B1%BB\"><span class=\"toc-text\">Conponent 类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Init-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">Init 函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Proc-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">Proc 函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">注册组件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%AB%E7%9A%84%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">别的模块</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E7%B1%BB\"><span class=\"toc-text\">常用类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#planning-%E6%A8%A1%E5%9D%97%E5%85%A5%E5%8F%A3\"><span class=\"toc-text\">planning 模块入口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#planning-component-h\"><span class=\"toc-text\">planning_component.h</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#planning-component-cc\"><span class=\"toc-text\">planning_component.cc</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Init-%E5%87%BD%E6%95%B0-1\"><span class=\"toc-text\">Init 函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Proc-%E5%87%BD%E6%95%B0-1\"><span class=\"toc-text\">Proc 函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#c-%E7%9F%A5%E8%AF%86%E7%82%B9\"><span class=\"toc-text\">c++ 知识点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","author":{"name":"yuri2078","slug":"blog-author","avatar":"https://www.loliapi.com/acg/pp/","link":"/","description":"一名与世无争的百合控!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"yuriSTL","uid":"3b8a14a53e41ce2f72f6537d61475809","slug":"yuriSTL","date":"2023-01-15T12:40:13.000Z","updated":"2023-08-25T03:13:00.155Z","comments":true,"path":"api/articles/yuriSTL.json","keywords":null,"cover":"https://www.loliapi.com/acg/?id=33","text":"常用知识点引用折叠 当有一个为左值时 &amp;&amp; &amp; 都会折叠成 &amp;, 只有都是 &amp;&amp; 才会折叠成&amp;&amp;...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"c/c++","slug":"c-c","count":9,"path":"api/categories/c-c.json"}],"tags":[{"name":"c/c++","slug":"c-c","count":9,"path":"api/tags/c-c.json"},{"name":"STL","slug":"STL","count":1,"path":"api/tags/STL.json"}],"author":{"name":"yuri2078","slug":"blog-author","avatar":"https://www.loliapi.com/acg/pp/","link":"/","description":"一名与世无争的百合控!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"cyber RT 开发教程","uid":"9d467d8176371f5545251578b9100d29","slug":"cyber","date":"2022-09-17T10:32:01.587Z","updated":"2023-08-25T03:13:11.571Z","comments":true,"path":"api/articles/cyber.json","keywords":null,"cover":"https://www.loliapi.com/acg/?id=16","text":"apollo Cyber c++ 实现 前言： 本文是基于赵老师的视频：CyberRT教程 ，文中所有东西都是基于arch + vscode 1.72 建议： ...","link":"","photos":[],"count_time":{"symbolsCount":"44k","symbolsTime":"40 mins."},"categories":[{"name":"apollo","slug":"apollo","count":9,"path":"api/categories/apollo.json"}],"tags":[{"name":"apollo","slug":"apollo","count":12,"path":"api/tags/apollo.json"},{"name":"教程","slug":"教程","count":6,"path":"api/tags/教程.json"}],"author":{"name":"yuri2078","slug":"blog-author","avatar":"https://www.loliapi.com/acg/pp/","link":"/","description":"一名与世无争的百合控!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}