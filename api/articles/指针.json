{"title":"指针","uid":"4c0cb40856baa1e8384c37c457fb63f6","slug":"指针","date":"2021-12-12T07:41:07.092Z","updated":"2022-04-01T05:17:27.862Z","comments":true,"path":"api/articles/指针.json","keywords":null,"cover":"https://www.loliapi.com/acg/?id=4","content":"<p>1  指针的初值。一般我们将没有赋值的指针初值设置为NULL</p>\n<p>定义指针时一定要有初值，不然后面赋值之后它指向的地方是不确定的，那么你修改内存中的东西可能会修改到已经有值的内存，这是不被允许的。并且编译器也会报错。</p>\n<pre><code><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n&#123;\n    char *p;\n    char *s &#x3D; &quot;china&quot;;\n    &#x2F;&#x2F;定义字符数组的时候可以省略[]所以这不是野指针\n    int *i; &#x2F;&#x2F;未初始化指针i的值，所以i是一个野指针\n    p &#x3D; s;\n    *i &#x3D; 123;\n    printf(&quot;s &#x3D; %s , p &#x3D; %p \\n&quot;, p, p);\n    &#x2F;&#x2F;可以打印出p的地址也就是s的地址\n    printf(&quot;i &#x3D; %d , p &#x3D; %p \\n&quot;, *i,i);\n    &#x2F;&#x2F;打印结果i的地址是0，并且编译器告诉你你非法修改地址的内容\n    return 0;\n&#125; </code></pre>\n</code></pre>\n<p>比如上面这段代码，运行结果是：</p>\n<pre><code><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">test.c:10:5: warning: &#39;i&#39; is used uninitialized in this function [-Wuninitialized]\n*i &#x3D; 123;\n~~~^~~~~\ns &#x3D; china , p &#x3D; 0000000000404000\ni &#x3D; 123 , p &#x3D; 0000000000000000</code></pre>\n</code></pre>\n<p>它会告诉你你非法修改了内存里的值，也就是i所指向的这部分值。</p>\n<p>2 定义字符数组的时候，如果是 char *p&#x3D;”china”;这种的，是只读类型的</p>\n<pre><code><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n&#123;\n    char *p;\n    char *s &#x3D; &quot;china&quot;;\n    p &#x3D; s;\n    for (int i &#x3D; 0; i &lt; strlen(p);i++)\n    &#123;\n        putchar(p[i]);\n    &#125;\n    &#x2F;&#x2F;通过下标访问字符数组的值\n    p[0] &#x3D; &#39;C&#39;;\n    puts(p);\n    &#x2F;&#x2F;我们发现数组的值并没有改变\n    return 0;\n&#125; </code></pre>\n</code></pre>\n<p>这样定义的字符数组同样可以通过下标访问但是却不能修改他的值，是只读的。不能修改。</p>\n<p>3 指针数组和数组指针</p>\n<p>1 数组名是不可以修改的，数组名永远代表第一个元素的首地址。不可以改变它指向的地址。比如以下程序会报错！</p>\n<pre><code><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int i&#x3D;0;\n    char s[]&#x3D; &quot;i love miku&quot;;\n    while(*s++) i++;\n    printf(&quot;len &#x3D; %d &quot;, i);\n    return 0;\n&#125; </code></pre>\n</code></pre>\n<p>报错 error: lvalue required as increment operand<br>运算对象必须是一个可以运算的左值，而数组名不可以修改。</p>\n<p>指针数组： int *p[10];定义存放是个指针的数组p</p>\n<pre><code><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int *p[10]&#x3D;&#123;NULL&#125;;\n    &#x2F;&#x2F;[]优先级高于*所以，这是一个存放5个指针变量的指针数组\n    int a[5],b[5];\n    for (int i &#x3D; 0; i &lt; 5;i++)\n    &#123;\n        a[i] &#x3D; i + 1;\n        p[i] &#x3D; &amp;a[i];\n        printf(&quot;p[i] &#x3D; %d  \\n&quot;, *p[i]);\n    &#125;\n    for (int i &#x3D; 5; i &lt; 10;i++)\n    &#123;\n        b[i-5] &#x3D; i + 1;\n        p[i] &#x3D; &amp;b[i-5];\n        printf(&quot;p[i] &#x3D; %d  \\n&quot;, *p[i]);\n    &#125;\n    &#x2F;&#x2F;p指针数组分别存放a，b数组的十个变量的地址\n    return 0;\n&#125; </code></pre>\n</code></pre>\n<p>总结： 指针数组是一个数组，每个元素存放一个指针变量</p>\n<p>数组指针：<code>int(*p)[5];</code>这是一个指针，指向一个有5个元素的数组</p>\n<p>()和[]优先级是一样的，从左往右运算<br>加了括号，先和*结合再和[]结合，这是个数组指针</p>\n<p>错误初始化实例</p>\n<pre><code><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int(*p)[5]&#x3D;&#123;1,2,3,4,5&#125;;\n    for (int i &#x3D; 0; i &lt; 5;i++)\n    &#123;\n        printf(&quot; %d \\n&quot;, *(p + i));\n    &#125;\n    &#x2F;&#x2F; 打印结果是  1 21 41 61 81\n    return 0;\n&#125; </code></pre>\n</code></pre>\n<p>p里存放的应该是地址而不是值</p>\n<pre><code><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int a[5] &#x3D; &#123;1, 2, 3, 4, 5&#125;;\n    int(*p)[5] &#x3D; &amp;a;\n    &#x2F;&#x2F; p指向的应该是一个真正的数组而不是元素值\n    &#x2F;&#x2F; 如果仅仅是a编译器会警告你\n    for (int i &#x3D; 0; i &lt; 5;i++)\n    &#123;\n        printf(&quot; %d  &quot;, *(*p + i));\n        &#x2F;&#x2F; p指向的是数组，所以*p才是它所指向的数组的首地址\n    &#125;\n    return 0;\n&#125; \n</code></pre>\n</code></pre>\n<p>总结： p是数组指针指向的应该是数组的地址。而数组名虽然和数组的第一个元素地址相同，但却代表不同的意思。这里我们的p需要指向的是数组，而不是元素的地址，所以需要用&amp;取数组的地址。后面也可以看出来，p指向的数组，*p才是数组的首地址。而普通定义的<code>int *p</code>。其实是一个指向整形变量的指针，这里是一个指向数组的指针。</p>\n<p>指针和二维数组</p>\n<p>二维数组才c语言中是线性存放的，也就死并不存在真正的二维数组。<br>数组名 数组第一行 数组第一行第一列的元素  所代表的都是a[0][0]的地址</p>\n<pre><code><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int a[5][5];\n    for (int i &#x3D; 0; i &lt; 5;i++)\n    &#123;\n        for (int j &#x3D; 0; j &lt; 5;j++)\n        &#123;\n            *(*(a + i) + j) &#x3D; j;\n            printf(&quot;%d &quot;, *(*(a + i) + j));\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n    printf(&quot;a &#x3D; %p \\n&quot;, a);\n    printf(&quot;a &#x3D; %p \\n&quot;, a[0]);\n    printf(&quot;a &#x3D; %p \\n&quot;, &amp;a[0][0]);\n    &#x2F;&#x2F;打印后我们发现结果是一样的\n    return 0;\n&#125; </code></pre>\n</code></pre>\n<p>数组名代表的是一个指向二维数组的指针，他的值是第一行，第一个元素的地址</p>\n<pre><code><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int a[5][5]&#x3D;&#123;0&#125;;\n    &#x2F;&#x2F;一共100字节一共5行，也就是每行20字节\n    printf(&quot;a &#x3D; %p  a+1 &#x3D; %p \\n&quot;, a,a+1);\n    &#x2F;&#x2F;打印结果是 ： a &#x3D; 000000000061FD90  a+1 &#x3D; 000000000061FDA4\n    &#x2F;&#x2F;结果相差14 也就是十进制的20自己，证明了a+1就是指向下一行（第二行）\n    printf(&quot;a[1] &#x3D; %p  *(a+1) &#x3D; %p \\n&quot;, a[1],*(a+1));\n    &#x2F;&#x2F;结果相同，并且结果都是a+1的值，证明a+1 a[1] *(a+1) 都指向第二行\n    printf(&quot;a[1][0] &#x3D; %p  (*(a+1)) &#x3D; %p \\n&quot;, &amp;a[1][0],(*(a+1)));\n    &#x2F;&#x2F;结果相同，证明 a[1][0]  *(*(a+1)) 都是指的第二行第一个元素\n    return 0;\n&#125; \n</code></pre>\n</code></pre>\n<p>数组名 + n 表示的是第 n 行 &#x2F;&#x2F;此处的第n行，仅仅是指向行<br>而 <em>(数组名 + n)值得是 第n行的元素 再次通过</em>可以访问里面的元素</p>\n<p><em>(数组名+n)+m 这是表示指向n行m列的元素的地址 当加上</em>，才可以访问它的值</p>\n<pre><code><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int a[5][5]&#x3D;&#123;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25&#125;;\n    int(*p)[5];\n    p &#x3D; a;\n    printf(&quot;a[0][0] &#x3D; %d    **p &#x3D; %d \\n&quot;,a[0][0],**p);\n    printf(&quot;a[1][0] &#x3D; %d    **(p+1) &#x3D; %d \\n&quot;,a[1][0],**(p+1));\n    printf(&quot;a[1][2] &#x3D; %d    *(*(p+1)+2) &#x3D; %d \\n&quot;,a[1][2],*(*(p+1)+2));\n    return 0;\n&#125; </code></pre>\n运行上面这段代码，我们发现，下面每一行的值是相同的，这也印证了，数组名代表的是第一行的地址，而它可以直接赋值给一个数组指针。也可以通过下标访问这个数组里个各个值。\n\n\n4 指向函数的指针\n\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int x, y;\n    int sum(int x, int y);\n    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n    int (*p)(int, int);\n    &#x2F;&#x2F;初始换指针是里面的数据需要和指向的函数相对应\n    &#x2F;&#x2F;对应参数的名字可以省略，但是参数的类型不能省略\n    &#x2F;&#x2F;定义函数指针\n    p &#x3D; sum;\n    &#x2F;&#x2F;将指针指向 sum函数\n    printf(&quot;sum &#x3D; %d \\n&quot;, p(x, y));\n    &#x2F;&#x2F;通过指针调用sum函数\n    return 0;\n&#125; \nint sum(int x,int y)\n&#123;\n    return x + y;\n&#125;\n</code></pre>\n</code></pre>\n<p>5 NULL指针和void指针</p>\n<p>（1） void指针可以指向任何指针，任何指针也可以赋值给void指针</p>\n<p>6 指向指针的指针</p>\n<p>定义 ： int **p;</p>\n<pre><code><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int x;\n    int *t&#x3D;&amp;x;\n    &#x2F;&#x2F;定义一个指针指向x\n    int **p&#x3D;&amp;t;\n    &#x2F;&#x2F;定义一个指向指针的指针，指向指针t\n    &#x2F;&#x2F;t表示指针t指向的地址，%t才是指针t本省\n    scanf(&quot;%d&quot;, &amp;x);\n    printf(&quot;x &#x3D; %d **p &#x3D; %d &quot;, x, **p);\n    &#x2F;&#x2F;打印结果相同\n    return 0;\n&#125; </code></pre>\n</code></pre>\n<p>应用 ： 将指向指针的指针指向一个字符数组</p>\n","text":"1 指针的初值。一般我们将没有赋值的指针初值设置为NULL 定义指针时一定要有初值，不然后面赋值之后它指向的地方是不确定的，那么你修改内存中的东西可能会修改到已...","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"c/c++","slug":"c-c","count":9,"path":"api/categories/c-c.json"}],"tags":[{"name":"c/c++","slug":"c-c","count":9,"path":"api/tags/c-c.json"}],"toc":"","author":{"name":"yuri2078","slug":"blog-author","avatar":"https://www.loliapi.com/acg/pp/","link":"/","description":"一名与世无争的百合控!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"c语言知识点补充","uid":"dbe2dc55bd3968b121423724b8b30463","slug":"c语言知识点补充","date":"2021-12-14T06:34:01.293Z","updated":"2021-12-23T12:03:45.787Z","comments":true,"path":"api/articles/c语言知识点补充.json","keywords":null,"cover":"https://www.loliapi.com/acg/?id=13","text":"scanf 输入是 用 %*d 会吞掉一个输入#include&lt;stdio.h&gt; int main() &#123; int x, y; scanf...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"c/c++","slug":"c-c","count":9,"path":"api/categories/c-c.json"}],"tags":[{"name":"c/c++","slug":"c-c","count":9,"path":"api/tags/c-c.json"}],"author":{"name":"yuri2078","slug":"blog-author","avatar":"https://www.loliapi.com/acg/pp/","link":"/","description":"一名与世无争的百合控!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"vscode配置教程","uid":"e2c06b60dce8071098800af5e45f52bb","slug":"vscode配置教程","date":"2021-12-11T09:18:08.875Z","updated":"2021-12-23T12:04:15.180Z","comments":true,"path":"api/articles/vscode配置教程.json","keywords":null,"cover":"https://www.loliapi.com/acg/?id=32","text":" 前言 : 因为里面需要配置Jason文件路径，所以没有基础就按着我的路径走，等有经验了，再继续用自己的方法走 c语言 教程 下载mingw64 https:/...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"教程","slug":"教程","count":3,"path":"api/categories/教程.json"}],"tags":[{"name":"教程","slug":"教程","count":6,"path":"api/tags/教程.json"},{"name":"vscode","slug":"vscode","count":3,"path":"api/tags/vscode.json"}],"author":{"name":"yuri2078","slug":"blog-author","avatar":"https://www.loliapi.com/acg/pp/","link":"/","description":"一名与世无争的百合控!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}