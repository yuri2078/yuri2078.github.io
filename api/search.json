[{"id":"fc0526855442b95f91bf019f61084091","title":"ubantuC#配置教程","content":"ubantu 22.04 vscode配置教程以下部分内容来自微软官方文档\n安装.net\n添加微软密钥\n\n   wget https:&#x2F;&#x2F;packages.microsoft.com&#x2F;config&#x2F;ubuntu&#x2F;22.04&#x2F;packages-microsoft-prod.deb -O packages-microsoft-prod.deb\nsudo dpkg -i packages-microsoft-prod.deb\nrm packages-microsoft-prod.deb\n\n\n安装sdk\nsudo apt-get update &amp;&amp; sudo apt-get install -y dotnet-sdk-6.0\n\n安装运行时\nsudo apt-get update &amp;&amp; sudo apt-get install -y aspnetcore-runtime-6.0\n\n检查是否安装成功\n输入dotnet 命令没有报错就是成功\n~&#x2F;下载 » dotnet                                   \n\nUsage: dotnet [options]\nUsage: dotnet [path-to-application]\n\nOptions:\n  -h|--help         Display help.\n  --info            Display .NET information.\n  --list-sdks       Display the installed SDKs.\n  --list-runtimes   Display the installed runtimes.\n\npath-to-application:\n  The path to an application .dll file to execute.\n\n\n配置vscode下载c#插件就行了\n开始第一个项目\nmkdir helloCshap 新建一个项目文件夹\ncode helloCshap用vscode打开文件夹\ndotnet new console新建控制台项目\ndotnet run 直接运行\n\ncode runner 配置c#\n打开code runner 扩展设置\n更改原来的 Csharp为&quot;csharp&quot;: &quot;cd $dir &amp;&amp; dotnet run&quot;\nrun 直接运行\n\n","slug":"ubantuC-配置教程","date":"2023-08-24T11:48:25.599Z","categories_index":"c#","tags_index":"c#","author_index":"yuri2078"},{"id":"fa742782f365d16a9d89f863a1370c00","title":"apollo 学习资料","content":"\n\n\n\n\n\n\n\n\n为了大家更好的学习(更好的过年)，我给大家整理了 apollo 的各种学习资料，大家没事就可点点进去眼熟一下，一回生二回熟！\napollo 官方文档\napollo开发者社区 —- 里面有各种文章和手册，可以帮你更好的了解alpollo\napollo-Github开源项目 —- 官方在github的开源仓库，有开源文档，在docs文件夹里访问可能需要梯子\ncyber文档 —- cyber常用api查询，多半用不到\napollo官方账号 —- 里面有星火计划的回放、比赛题目解析、各种教程\n\napollo 安装教程\n官方8.0文档 —- 官当8.0文档\nWSL安装教程 —- 使用swl2 安装教程\ngithub-profile模块版 —- 需要profile模块并且使用源码方式编译教程\nyuri-8.0安装教程 —- 8.0 安装教以软件包方式安装教程\nyuri-源码安装教程 —- 使用源码方式编译apollo,默认拉取最新版本\n\n更好的浏览源码\nc++学习路径 —- 看源码你需要了解的c++知识\n使用vscode看源码教程 —- 使用vscode更好的阅读apollo源码\n使用vscode调试打印日志教程 —- 使用vscode对apollo各种模块进行调试的教程（基于edu版本）\n\napollo 学习教程\ncyber开发教程 —- 自己写的cyber开发教程\n云端场景同步本地 —- 使用profile模块同步场景\n我自己整理的源码分析\nplanning-component  —- planning 基础规划流程\nplanning-onlaneplanning —- 默认的规划器介绍\nplanning-conf文件详解  —- 配置文件详解（还没写完）\n\n\n星火计划系列教程  —- 第二期星火计划的回放\nPNC专项训练 —- 星火计划pnc 专项视频的回放\n详解planning代码  —- 知呼大佬自动驾驶Player 的详解plannning源码\napollo7.0规划算法解析 —- steve 大佬的规划算法解析\n万字详解apollo学习资料  —- 不知道哪个大佬在整理的apollo学习资料\n\n更好的使用linux\nlinxu命令大全  —- apollo基于ubuntu，所以需要了解linux\nubuntu常用命令 —- apollo 基于ubuntu,所以需要了解ubuntu，看这个基本就够了\nvim常用命令  —- linux常用的工具，需要了解\n\n","slug":"happy-new-year","date":"2023-01-18T10:51:40.000Z","categories_index":"apollo","tags_index":"apollo","author_index":"yuri2078"},{"id":"043612b9cbadc34bbbbc179e6d78dec9","title":"Scenario(3)","content":"Scenario\n\n\n\n\n\n\n\n\n本文参考自 ： 原文\nplanner选择I0202 19:15:10.702800 25408 on_lane_planning.cc:165] 分配planner -&gt; PUBLIC_ROAD\nI0202 19:15:10.702884 25408 scenario_manager.cc:59] ScenarioManager 初始化\nI0202 19:15:10.725889 25408 scenario_manager.cc:72] 创建Scenario -&gt; LANE_FOLLOW\n\n\n根据日志我们可以看出他会在on_lane_planning中分配planner -&gt; public_road\n所以如果是on_lane_planning的话他默认使用public——road 进行具体的规划\n\npublic_road_plannnerStatus PublicRoadPlanner::Init(const PlanningConfig&amp; config) &#123;\n  config_ &#x3D; config;\n  &#x2F;&#x2F; ScenarioManager会实例化一个全局的scenario_manager_对象来进行场景管理，\n  &#x2F;&#x2F; PublicRoadPlanner初始化时会调用配置文件里的参数来建立这个对象\n  scenario_manager_.Init(config); &#x2F;&#x2F; 实列化一个scenario—manager对象用来管理场景\n  return Status::OK();\n&#125;\n\n&#x2F;&#x2F; 具体的场景规划\nStatus PublicRoadPlanner::Plan(const TrajectoryPoint&amp; planning_start_point,\n                               Frame* frame,\n                               ADCTrajectory* ptr_computed_trajectory) &#123;\n                            \n  scenario_manager_.Update(planning_start_point, *frame); &#x2F;&#x2F; 决策使用哪个场景\n  scenario_ &#x3D; scenario_manager_.mutable_scenario(); &#x2F;&#x2F; 获取当前场景\n  auto result &#x3D; scenario_-&gt;Process(planning_start_point, frame); &#x2F;&#x2F; 处理当前场景\n\n  &#x2F;&#x2F; 打印debug信息\n  if (FLAGS_enable_record_debug) &#123;\n    auto scenario_debug &#x3D; ptr_computed_trajectory-&gt;mutable_debug()\n                              -&gt;mutable_planning_data()\n                              -&gt;mutable_scenario();\n    scenario_debug-&gt;set_scenario_type(scenario_-&gt;scenario_type());\n    scenario_debug-&gt;set_stage_type(scenario_-&gt;GetStage());\n    scenario_debug-&gt;set_msg(scenario_-&gt;GetMsg());\n  &#125;\n\n  &#x2F;&#x2F; 场景处理成功\n  if (result &#x3D;&#x3D; scenario::Scenario::STATUS_DONE) &#123;\n    &#x2F;&#x2F; 只有在场景处理完成的时候才会进行场景Update\n    &#x2F;&#x2F; STATUS_DONE\n    scenario_manager_.Update(planning_start_point, *frame);\n    AINFO &lt;&lt; &quot;场景处理完成 &quot;;\n  &#125;\n  else if (result &#x3D;&#x3D; scenario::Scenario::STATUS_UNKNOWN)\n  &#123;\n    AERROR &lt;&lt; &quot;场景处理失败!&quot;;\n    return Status(common::PLANNING_ERROR, &quot;不知道你返回了什么东西捏!&quot;);\n  &#125;\n  return Status::OK();\n&#125;\n\n我们看public_road 的源码可以看出，他只有两个函数\nInit 阶段\n\n\n\n\n\n\n\n\n调用配置文里的参数，实列化一个scenario—manager对象用来管理场景.所以本阶段只做一件事就是调用 ScenarioManager的init 函数进行初始化\nbool ScenarioManager::Init(const PlanningConfig&amp; planning_config) &#123;\n  AINFO &lt;&lt; &quot;ScenarioManager (Init) -- 初始化&quot;;\n  planning_config_.CopyFrom(planning_config); &#x2F;&#x2F; 复制配置文件\n  RegisterScenarios(); &#x2F;&#x2F; 检查配置文件，注册场景\n  &#x2F;&#x2F; 创建场景，默认为lane_follow\n  default_scenario_type_ &#x3D; ScenarioType::LANE_FOLLOW; &#x2F;&#x2F; 设置默认场景type\n  current_scenario_ &#x3D; CreateScenario(default_scenario_type_); &#x2F;&#x2F; 创建场景\n  AINFO &lt;&lt; &quot;初始化(Scenario manager init) 创建场景 -&gt; &quot; &lt;&lt; current_scenario_-&gt;Name();\n  return true;\n&#125;\n\n\n通过传入的配置文件，进行配置 \n注册所有场景 RegisterScenarios()函数\n设置默认的场景 默认 -&gt; LANE_FOLLOW\n创建场景 CreateScenario() 通过传入的场景type来创建场景\n\nPlan 阶段\n\n\n\n\n\n\n\n\n这个阶段就是执行具体的规划逻辑的地方\nUpdate\n\n\n\n\n\n\n\n\n ScenarioManager类的Update()函数，用来决策当前处在什么场景。如果进入了新的场景，会创建一个新的对象来进行之后的规划逻辑\nvoid ScenarioManager::Update(const common::TrajectoryPoint&amp; ego_point, const Frame&amp; frame) &#123;\n  ACHECK(!frame.reference_line_info().empty());\n  Observe(frame);\n  ScenarioDispatch(frame); &#x2F;&#x2F; 会根据配置选择基于规则还是基于学习的决策方法\n&#125;\n\nScenarioDispatch函数中他会根据你的配置文件选择基于规划还是基于学习的决策方法。如果遇到新得场景则会更新场景\nvoid ScenarioManager::ScenarioDispatch(const Frame&amp; frame) &#123;\n  ACHECK(!frame.reference_line_info().empty()); &#x2F;&#x2F; 检查参考线是否为空\n  ScenarioType scenario_type; \n  &#x2F;&#x2F; 获取历史点的个数\n  int history_points_len &#x3D; 0; \n  if (injector_-&gt;learning_based_data() &amp;&amp;\n      injector_-&gt;learning_based_data()-&gt;GetLatestLearningDataFrame()) &#123;\n    history_points_len &#x3D; injector_-&gt;learning_based_data()\n                             -&gt;GetLatestLearningDataFrame()\n                             -&gt;adc_trajectory_point_size();\n  &#125;\n  &#x2F;&#x2F; 默认为 0 也就是 PlanningConfig::NO_LEARNING 这是默认模式，别的就是基于学习的模式\n  if ((planning_config_.learning_mode() &#x3D;&#x3D; PlanningConfig::E2E ||\n       planning_config_.learning_mode() &#x3D;&#x3D; PlanningConfig::E2E_TEST) &amp;&amp;\n      history_points_len &gt;&#x3D; FLAGS_min_past_history_points_len)\n  &#123;\n    scenario_type &#x3D; ScenarioDispatchLearning();\n  &#125;\n  else\n  &#123;\n    &#x2F;&#x2F; 选择不基于学习的决策方式\n    scenario_type &#x3D; ScenarioDispatchNonLearning(frame);\n  &#125;\n\n  ADEBUG &lt;&lt; &quot;select scenario: &quot; &lt;&lt; ScenarioType_Name(scenario_type);\n  AINFO &lt;&lt; &quot;选择的场景 -&gt; &quot; &lt;&lt; ScenarioType_Name(scenario_type);\n\n  &#x2F;&#x2F; update PlanningContext\n  UpdatePlanningContext(frame, scenario_type);\n\n  &#x2F;&#x2F; 如果新场景不是当前场景就创建场景，并且更新\n  if (current_scenario_-&gt;scenario_type() !&#x3D; scenario_type) &#123;\n    current_scenario_ &#x3D; CreateScenario(scenario_type); &#x2F;&#x2F; 如果需要就更新场景\n    AINFO &lt;&lt; &quot;更新场景 -&gt; &quot; &lt;&lt; current_scenario_-&gt;Name();\n  &#125;\n  else\n  &#123;\n    AINFO &lt;&lt; &quot;仍然是 -&gt; &quot; &lt;&lt; current_scenario_-&gt;Name() &lt;&lt; &quot; 不更新场景&quot;;\n  &#125;\n&#125;\n\nScenarioDispatchNonLearning因为配置文件默认是 learning_mode() = 0 所以他默认会调用ScenarioDispatchNonLearning方法来更新场景\nScenarioDispatchNonLearning()函数默认从lanefollow场景开始判断，首先根据驾驶员的意图来安排场景，如果不是默认的lanefollow场景，直接输出当前场景；如果是lanefollow场景，会依次判断是否属于别的场景；即剩余场景之间的跳转必须经过lanefollow这个场景\n我们看他的代码\nScenarioType ScenarioManager::ScenarioDispatchNonLearning(const Frame&amp; frame) &#123;\n  &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n  &#x2F;&#x2F; 默认场景: LANE_FOLLOW\n  ScenarioType scenario_type &#x3D; default_scenario_type_; \n\n  &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n  &#x2F;&#x2F; Pad Msg scenario\n  scenario_type &#x3D; SelectPadMsgScenario(frame); &#x2F;&#x2F; 在场景判断时，首先调用函数SelectPadMsgScenario()，根据驾驶员意图来安排场景\n\n  &#x2F;&#x2F; 判断当前场景是不是默认场景\n  if (scenario_type &#x3D;&#x3D; default_scenario_type_) &#123;\n    &#x2F;&#x2F; check current_scenario (not switchable)\n    switch (current_scenario_-&gt;scenario_type()) &#123;\n      case ScenarioType::LANE_FOLLOW:\n      case ScenarioType::PULL_OVER:\n        break;\n      case ScenarioType::BARE_INTERSECTION_UNPROTECTED:\n      case ScenarioType::EMERGENCY_PULL_OVER:\n      case ScenarioType::PARK_AND_GO:\n      case ScenarioType::STOP_SIGN_PROTECTED:\n      case ScenarioType::STOP_SIGN_UNPROTECTED:\n      case ScenarioType::TRAFFIC_LIGHT_PROTECTED:\n      case ScenarioType::TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN:\n      case ScenarioType::TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN:\n      case ScenarioType::VALET_PARKING:\n      case ScenarioType::YIELD_SIGN:\n        &#x2F;&#x2F; must continue until finish\n        &#x2F;&#x2F; 如果当前场景没有处理完毕，那么继续处理。\n        if (current_scenario_-&gt;GetStatus() !&#x3D;\n            Scenario::ScenarioStatus::STATUS_DONE) &#123;\n          scenario_type &#x3D; current_scenario_-&gt;scenario_type(); &#x2F;&#x2F; 改变scenario_type 继续处理当前场景\n        &#125;\n        break;\n      default:\n        break;\n    &#125;\n  &#125;\n\n  &#x2F;*如果是default_scenario_type_ 就开始判断是不是属于别的场景*&#x2F;\n  &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n  &#x2F;&#x2F; ParkAndGo &#x2F; starting scenario\n  if (scenario_type &#x3D;&#x3D; default_scenario_type_) &#123;\n    if (FLAGS_enable_scenario_park_and_go) &#123;\n      scenario_type &#x3D; SelectParkAndGoScenario(frame);\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n  &#x2F;&#x2F; intersection scenarios\n  if (scenario_type &#x3D;&#x3D; default_scenario_type_) &#123;\n    scenario_type &#x3D; SelectInterceptionScenario(frame);\n  &#125;\n\n  &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n  &#x2F;&#x2F; pull-over scenario\n  if (scenario_type &#x3D;&#x3D; default_scenario_type_) &#123;\n    if (FLAGS_enable_scenario_pull_over) &#123;\n      scenario_type &#x3D; SelectPLANE_FOLLOW:\n      case ScenarioType::PULL_OVERullOverScenario(frame);\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n  &#x2F;&#x2F; VALET_PARKING scenario\n  if (scenario_type &#x3D;&#x3D; default_scenario_type_) &#123;\n    scenario_type &#x3D; SelectValetParkingScenario(frame);\n  &#125;\n\n  return scenario_type;\n&#125;\n\nScenarioDispatchNonLearning函数一开始设置了一个默认的场景类型，并且调用SelectPadMsgScenario 函数来检查驾驶员是否有意更改场景。如果驾驶员不需要更改场景，那么进入接下的对比，如果需要直接返回了。那么这里scenario_type 就不会是default_scenario_type_ 那么直接返回场景类型，然后通过**ScenarioDispatch** 函数新建新的场景了。如果不是\n\nSelectPadMsgScenario 函数表示驾驶员需要更改场景scenario_type 就不是默认类型 ScenarioDispatchNonLearning 里的内容直接跳过，不需要再判断属于哪个类型。chang jing\nSelectPadMsgScenario 函数表示驾驶员不需要更改场景，scenario_type 就是默认类型可以进行接下来的判断程序。\n从代码中我们可以看到只有当前场景是LANE_FOLLOW 或者 PULL_OVER 或者当前场景已经处理完毕的时候，我们才能更改为别的场景\n如果当前场景不是默认场景并且并没有处理好那么他将会继续处理场景。\n\nSelectPadMsgScenario\n\n\n\n\n\n\n\n\n检查驾驶员是否有意更改场景\nCreateScenario\n\n\n\n\n\n\n\n\n该函数在ScenarioDispatch函数中被调用，他会根据传入的场景类型来创建场景，并调用该场景的Init 函数进行初始化，每个场景的初始化他会创建第一个默认的Stage\n&#x2F;&#x2F; 调用场景初始化函数 ScenarioManager::CreateScenario\n  if (ptr !&#x3D; nullptr) &#123;\n    AINFO &lt;&lt; &quot;CreateScenario函数调用 创建Scenario -&gt; &quot; &lt;&lt; ScenarioType_Name(scenario_type) &lt;&lt; &quot;成功，并进行初始化&quot;;\n    ptr-&gt;Init();\n  &#125;\n\n&#x2F;&#x2F; 场景初始化\nvoid Scenario::Init() &#123;\n  ACHECK(!config_.stage_type().empty());\n  AINFO &lt;&lt; this-&gt;Name() &lt;&lt; &quot; 场景(Init) 函数调用进行初始化,并开始遍历 Stage&quot;;\n  &#x2F;&#x2F; set scenario_type in PlanningContext\n  auto* scenario &#x3D; injector_-&gt;planning_context()\n                       -&gt;mutable_planning_status()\n                       -&gt;mutable_scenario();\n  scenario-&gt;Clear();\n  scenario-&gt;set_scenario_type(scenario_type());\n\n  for (const auto&amp; stage_config : config_.stage_config()) &#123;\n    stage_config_map_[stage_config.stage_type()] &#x3D; &amp;stage_config;\n  &#125;\n  for (int i &#x3D; 0; i &lt; config_.stage_type_size(); ++i)\n  &#123;\n    auto stage_type &#x3D; config_.stage_type(i);\n    AINFO &lt;&lt; &quot;Stage &quot; &lt;&lt; i &lt;&lt; &quot;  -&gt;  &quot; &lt;&lt; StageType_Name(stage_type);\n    ACHECK(common::util::ContainsKey(stage_config_map_, stage_type))\n        &lt;&lt; &quot;stage type : &quot; &lt;&lt; StageType_Name(stage_type)\n        &lt;&lt; &quot; has no config&quot;;\n  &#125;\n  ADEBUG &lt;&lt; &quot;init stage &quot;\n         &lt;&lt; StageType_Name(config_.stage_type(0));\n  &#x2F;&#x2F; &#x2F;&#x2F; 初始化后分配该场景下的默认stage\n  current_stage_ &#x3D; CreateStage(*stage_config_map_[config_.stage_type(0)], injector_);\n  \n&#125;\n\n\n\nmutable_scenario\n\n\n\n\n\n\n\n\n获取当前场景(Scenario) 这个函数就直接将智能指针(std::unique_ptr&lt;Scenario&gt; current_scenario_;)中的地址返回了。\nreturn current_scenario_.get();\nProcess\n\n\n\n\n\n\n\n\n调用当前Scenario对象的Process()函数，来执行这个场景对应的逻辑.根据日志来看他默认选择的场景是LANE_FOLLOW ，所以这里的Process函数是LANE_FOLLOW下的\nI0202 19:15:18.855336 25410 scenario_manager.cc:826] 选择的场景 -&gt; LANE_FOLLOW\n在实例化Scenario后会调用它的LoadConfig()与void Scenario::Init() 两个函数，读取配置文件，并且初始化当前对象，注册配置文件中定义的该场景拥有的stage。其中会在ScenarioManager -&gt; Init -&gt; RegisterScenarios 中调用LoadConfig 进行注册场景stage。在ScenarioManager -&gt; Init -&gt; CreateScenario中创建好场景之后会调用场景对应的Init函数\n场景的执行在”scenario.cc“和对应的场景目录中，在apollo中每个场景由一个或者多个阶段(stage)注册而来，每个阶段stage又由不同的任务(task)组成。执行一个场景，就是顺序执行不同阶段的不同任务。在每一个规划周期，所谓决策的其中一个作用就是定位到当前所在的scenario以及stage，并且按顺序执行完当前stage中注册的所有task\n&#x2F;&#x2F; 场景的执行在&quot;scenario.cc&quot;和对应的场景目录中，在apollo中每个场景由一个或者多个阶段(stage)注册而来，\n&#x2F;&#x2F; 每个阶段stage又由不同的任务(task)组成。执行一个场景，就是顺序执行不同阶段的不同任务。\n&#x2F;&#x2F; 在每一个规划周期，所谓决策的其中一个作用就是定位到当前所在的scenario以及stage，并且按顺序执行完当前stage中注册的所有task\nScenario::ScenarioStatus Scenario:: Process(\n    const common::TrajectoryPoint&amp; planning_init_point, Frame* frame) &#123;\n  AINFO &lt;&lt; &quot;当前 Stage 是 -&gt; &quot; &lt;&lt; current_stage_-&gt;Name();\n  if (current_stage_ &#x3D;&#x3D; nullptr) &#123;\n    AWARN &lt;&lt; &quot;当前场景为nullptr!&quot;;\n    return STATUS_UNKNOWN;\n  &#125;\n  if (current_stage_-&gt;stage_type() &#x3D;&#x3D; StageType::NO_STAGE) &#123;\n    scenario_status_ &#x3D; STATUS_DONE;\n    return scenario_status_;\n  &#125;\n  auto ret &#x3D; current_stage_-&gt;Process(planning_init_point, frame); &#x2F;&#x2F; 处理当前stage 并且返回处理状态\n  switch (ret) &#123;\n    &#x2F;&#x2F; 异常状态\n    case Stage::ERROR: &#123;\n      AERROR &lt;&lt; &quot;Stage &#39;&quot; &lt;&lt; current_stage_-&gt;Name() &lt;&lt; &quot;&#39; 返回异常&quot;;\n      scenario_status_ &#x3D; STATUS_UNKNOWN;\n      break;\n    &#125;\n    &#x2F;&#x2F; 正在处理状态\n    case Stage::RUNNING: &#123;\n      scenario_status_ &#x3D; STATUS_PROCESSING;\n      break;\n    &#125;\n    &#x2F;&#x2F; 完成状态\n    case Stage::FINISHED: &#123;\n      auto next_stage &#x3D; current_stage_-&gt;NextStage();\n      if (next_stage !&#x3D; current_stage_-&gt;stage_type()) &#123;\n        AINFO &lt;&lt; &quot;由 Stage -&gt; &quot; &lt;&lt; current_stage_-&gt;Name() &lt;&lt; &quot; 转到 Stage -&gt; &quot; &lt;&lt; StageType_Name(next_stage);\n        &#x2F;&#x2F; 如果stage 全部处理完毕，就返回完成状态\n        if (next_stage &#x3D;&#x3D; StageType::NO_STAGE) &#123;\n          scenario_status_ &#x3D; STATUS_DONE;\n          return scenario_status_;\n        &#125;\n        &#x2F;&#x2F; 检查配置文件是否存在\n        if (stage_config_map_.find(next_stage) &#x3D;&#x3D; stage_config_map_.end()) &#123;\n          AERROR &lt;&lt; &quot;stage 配置文件查找失败&quot; &lt;&lt; next_stage;\n          scenario_status_ &#x3D; STATUS_UNKNOWN;\n          return scenario_status_;\n        &#125;\n        &#x2F;&#x2F; 如果当前stage处理完毕，并且配置文件正常，且接下来有未处理的stage 就新建一个stage\n        current_stage_ &#x3D; CreateStage(*stage_config_map_[next_stage], injector_);\n        if (current_stage_ &#x3D;&#x3D; nullptr) &#123;\n          AWARN &lt;&lt; &quot;当前stage 是一个空指针&quot;;\n          return STATUS_UNKNOWN;\n        &#125;\n      &#125;\n      &#x2F;&#x2F; 如果当前场景不为空，且未处于全部状态就返回正在处理，否则返回处理完毕&#96;\n      if (current_stage_ !&#x3D; nullptr &amp;&amp;\n          current_stage_-&gt;stage_type() !&#x3D; StageType::NO_STAGE) &#123;\n        scenario_status_ &#x3D; STATUS_PROCESSING;\n      &#125; else &#123;\n        scenario_status_ &#x3D; STATUS_DONE;\n      &#125;\n      break;\n    &#125;\n    default: &#123;\n      AWARN &lt;&lt; &quot;返回状态异常 -&gt; &quot; &lt;&lt; ret;\n      scenario_status_ &#x3D; STATUS_UNKNOWN;\n    &#125;\n  &#125;\n  return scenario_status_;\n&#125;\n\n\n因为一开始Scenario会调用对应Init函数，所以第一个Process函数执行的Stage 是第一个Stage\n\n开始处理之后，如果当前stage 是没有stage状态，或者当前没有场景就直接返回对应状态\n\n如果场景异常 就返回异常状态\n\n如果场景正在处理，就返回正在处理状态\n\n如果场景处理完毕\n\n如果下一个Stage类型不等于当前Stage，且下一个stage类型是no——stage 就直接返回处理完毕\n如果下一个Stage类型不等于当前Stage，但是配置文件中找不到该类型就返回类型为止\n如果下一个Stage类型不等于当前Stage，且不输入以上两种情况就更新Stage\n\n\n\nTask\n\n\n\n\n\n\n\n\n通过前面的知识点 我们可以知道当执行具体的规划任务的时候，我们会调用Scenario的process函数，依次执行Stage，所以我们需要了解各个场景的stage执行。而apollo 又将每个Stage 又分为不同的task.\nlane_follow\n\n\n\n\n\n\n\n\n这是默认的跟车场景(Scenario) 我们看他的配置文件只有一个stage。所以我们直接看这个stage\nscenario_type: LANE_FOLLOWstage_type: LANE_FOLLOW_DEFAULT_STAGE\nCreateStage\n\n\n\n\n\n\n\n\n看Scenario.h 我们可以看出，CreateStage 函数是纯虚函数，所以我们需要重写该函数。各个不同的场景有着自己不同的创建场景的需求。我们看lane_follow 他就一个Stage，直接判断是不是该场景，然后创建返回就行了\nstd::unique_ptr&lt;Stage&gt; LaneFollowScenario::CreateStage(\n    const ScenarioConfig::StageConfig&amp; stage_config,\n    const std::shared_ptr&lt;DependencyInjector&gt;&amp; injector) &#123;\n  if (stage_config.stage_type() !&#x3D; StageType::LANE_FOLLOW_DEFAULT_STAGE) &#123;\n    AERROR &lt;&lt; &quot;Follow lane 不支持的类型 -&gt;  &quot;\n           &lt;&lt; StageType_Name(stage_config.stage_type());\n    return nullptr;\n  &#125;\n  return std::unique_ptr&lt;Stage&gt;(new LaneFollowStage(stage_config, injector));\n&#125;\n\nProcess\n\n\n\n\n\n\n\n\n前面看到plannear 的process 函数会不断调用stage进行规划，而stage的规划函数也是Process 所以对于场景和stage 具体规划流程都在Process函数当中\n&#x2F;&#x2F; LaneFollowStage 的Process() 函数执行主要的规划逻辑，在函数内部会对变道的效率来进行判断从而选择是否按照变道进行规划，或者保持本车道运行\nStage::StageStatus LaneFollowStage::Process(\n    const TrajectoryPoint&amp; planning_start_point, Frame* frame) &#123;\n  bool has_drivable_reference_line &#x3D; false;\n\n  &#x2F;&#x2F; 参考线的条数\n  ADEBUG &lt;&lt; &quot;Number of reference lines:\\t&quot;\n         &lt;&lt; frame-&gt;mutable_reference_line_info()-&gt;size();\n  AINFO &lt;&lt; &quot;Number of reference lines:\\t&quot; &lt;&lt; frame-&gt;mutable_reference_line_info()-&gt;size();\n  unsigned int count &#x3D; 0;\n  &#x2F;&#x2F; 遍历所有参考线，直到找到可以用来规划的参考线之后退出\n  for (auto&amp; reference_line_info : *frame-&gt;mutable_reference_line_info()) &#123;\n    &#x2F;&#x2F; TODO(SHU): need refactor\n    if (count++ &#x3D;&#x3D; frame-&gt;mutable_reference_line_info()-&gt;size()) &#123;\n      break;\n    &#125;\n    ADEBUG &lt;&lt; &quot;No: [&quot; &lt;&lt; count &lt;&lt; &quot;] Reference Line.&quot;;\n    ADEBUG &lt;&lt; &quot;IsChangeLanePath: &quot; &lt;&lt; reference_line_info.IsChangeLanePath();\n\n    &#x2F;&#x2F; 找到可用来规划的参考线，退出循环\n    if (has_drivable_reference_line) &#123;\n      reference_line_info.SetDrivable(false);\n      break;\n    &#125;\n    &#x2F;&#x2F; 执行具体规任务\n    auto cur_status &#x3D; PlanOnReferenceLine(planning_start_point, frame, &amp;reference_line_info);\n    &#x2F;&#x2F; 如果规划完成\n    if (cur_status.ok()) &#123;\n      &#x2F;&#x2F; 如果发生lanechange，判断reference_line的cost\n      AINFO &lt;&lt; &quot;规划完成&quot;;\n      if (reference_line_info.IsChangeLanePath())\n      &#123;\n        AINFO &lt;&lt; &quot;发生变道!!&quot;;\n        ADEBUG &lt;&lt; &quot;reference line is lane change ref.&quot;;\n        ADEBUG &lt;&lt; &quot;FLAGS_enable_smarter_lane_change: &quot;\n               &lt;&lt; FLAGS_enable_smarter_lane_change;\n\n        &#x2F;&#x2F; 如果规划成功后，还需要判断目标车道的变道cost，如果cost太高，那么就会舍弃掉这条目标车道的reference_line, \n        &#x2F;&#x2F; 此时放弃变道的规划，继续循环使用原车道的reference_line进行规划\n        if (reference_line_info.Cost() &lt; kStraightForwardLineCost &amp;&amp;\n            (LaneChangeDecider::IsClearToChangeLane(&amp;reference_line_info) ||\n             FLAGS_enable_smarter_lane_change)) &#123;\n          &#x2F;&#x2F; If the path and speed optimization succeed on target lane while\n          &#x2F;&#x2F; under smart lane-change or IsClearToChangeLane under older version\n          has_drivable_reference_line &#x3D; true;\n          reference_line_info.SetDrivable(true);\n          LaneChangeDecider::UpdatePreparationDistance(\n              true, frame, &amp;reference_line_info, injector_-&gt;planning_context());\n          ADEBUG &lt;&lt; &quot;\\tclear for lane change&quot;;\n          AINFO &lt;&lt; &quot;变道成功!&quot;;\n        &#125;\n        else\n        &#123;\n          LaneChangeDecider::UpdatePreparationDistance(\n              false, frame, &amp;reference_line_info,\n              injector_-&gt;planning_context());\n          reference_line_info.SetDrivable(false);\n          ADEBUG &lt;&lt; &quot;\\tlane change failed&quot;;\n          AINFO &lt;&lt; &quot;变道失败！继续使用原车道规划&quot;;\n        &#125;\n      &#125;\n      else\n      &#123;\n        ADEBUG &lt;&lt; &quot;reference line is NOT lane change ref.&quot;;\n        &#x2F;&#x2F; 如果没有lanechange，stage执行结果为OK，则has_drivable_reference_line置位true\n        has_drivable_reference_line &#x3D; true;\n      &#125;\n    &#125; else &#123;\n      reference_line_info.SetDrivable(false);\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 根据has_drivable_reference_line这个标志位的结果，返回stage执行的结果\n  return has_drivable_reference_line ? StageStatus::RUNNING\n                                     : StageStatus::ERROR;\n&#125;\n\n根据函数我们可以看出LaneFollowStage的Process函数的作用就是不断遍历参考线，直到找到可以用来规划的参考线。并且如果规划的结果需要变道他会计算变道的cost然后再判断具体是不是需要变道\nPlanOnReferenceLine\n\n\n\n\n\n\n\n\nauto cur_status &#x3D; PlanOnReferenceLine(planning_start_point, frame, &amp;reference_line_info);\n通过代码我们可以看到，stage 的具体规划逻辑实在PlanOnReferenceLine中的\n&#x2F;&#x2F; 具体规划逻辑\nStatus LaneFollowStage::PlanOnReferenceLine(\n    const TrajectoryPoint&amp; planning_start_point, Frame* frame,\n    ReferenceLineInfo* reference_line_info) &#123;\n  &#x2F;&#x2F; 判断是否有lanechange意图，如果有计算cost\n  if (!reference_line_info-&gt;IsChangeLanePath()) &#123;\n    reference_line_info-&gt;AddCost(kStraightForwardLineCost);\n  &#125;\n  ADEBUG &lt;&lt; &quot;planning start point:&quot; &lt;&lt; planning_start_point.DebugString();\n  ADEBUG &lt;&lt; &quot;Current reference_line_info is IsChangeLanePath: &quot;\n         &lt;&lt; reference_line_info-&gt;IsChangeLanePath();\n\n  &#x2F;&#x2F; 先把状态设置ok\n  auto ret &#x3D; Status::OK();\n  &#x2F;&#x2F; 遍历task\n  for (auto* task : task_list_) &#123;\n    &#x2F;&#x2F; 记录开始时间\n    const double start_timestamp &#x3D; Clock::NowInSeconds();\n    &#x2F;&#x2F; 调用task的Execute 进行具体的规划\n    ret &#x3D; task-&gt;Execute(frame, reference_line_info);\n    &#x2F;&#x2F; 记录结束时间\n    const double end_timestamp &#x3D; Clock::NowInSeconds();\n    &#x2F;&#x2F; 统计耗时，单位ms\n    const double time_diff_ms &#x3D; (end_timestamp - start_timestamp) * 1000;\n    ADEBUG &lt;&lt; &quot;after task[&quot; &lt;&lt; task-&gt;Name()\n           &lt;&lt; &quot;]:&quot; &lt;&lt; reference_line_info-&gt;PathSpeedDebugString();\n    ADEBUG &lt;&lt; task-&gt;Name() &lt;&lt; &quot; time spend: &quot; &lt;&lt; time_diff_ms &lt;&lt; &quot; ms.&quot;;\n    AINFO  &lt;&lt; &quot;task -&gt;  &quot; &lt;&lt; task-&gt;Name() &lt;&lt; &quot; 执行耗时 : &quot; &lt;&lt; time_diff_ms &lt;&lt; &quot; ms.&quot;;\n    RecordDebugInfo(reference_line_info, task-&gt;Name(), time_diff_ms);\n\n    if (!ret.ok()) &#123;\n      AERROR &lt;&lt; &quot;Failed to run tasks[&quot; &lt;&lt; task-&gt;Name()\n             &lt;&lt; &quot;], Error message: &quot; &lt;&lt; ret.error_message();\n      AINFO &lt;&lt; &quot;执行失败捏!&quot;;\n      break;\n    &#125;\n    。.......\n\n通过代码我们可以看出他的规划逻辑就是遍历stage对应的task，然后调用task对应的Execute函数\n分割线LANE_CHANGE_DECIDER\n\n\n\n\n\n\n\n\n根据日志我们看出LANE_FOLLOW_DEFAULT_STAGE的第一个task就是LANE_CHANGE_DECIDER\nI0206 19:24:20.367132 18917 scenario.cc:75] 目前正在执行的Stage是 -&gt; LANE_FOLLOW_DEFAULT_STAGE\nI0206 19:24:20.367136 18917 lane_follow_stage.cc:101] Number of reference lines:\t1\nI0206 19:24:20.367144 18917 lane_follow_stage.cc:196] task -&gt;  LANE_CHANGE_DECIDER 执行耗时 : 0.00405312 ms.\nI0206 19:24:20.367161 18917 lane_follow_stage.cc:196] task -&gt;  PATH_REUSE_DECIDER 执行耗时 : 0.00119209 ms.\nI0206 19:24:20.367166 18917 lane_follow_stage.cc:196] task -&gt;  PATH_LANE_BORROW_DECIDER 执行耗时 : 0.00238419 ms.\nI0206 19:24:20.368664 18917 lane_follow_stage.cc:196] task -&gt;  PATH_BOUNDS_DECIDER 执行耗时 : 1.48964 ms.\nI0206 19:24:20.377274 18917 lane_follow_stage.cc:196] task -&gt;  PIECEWISE_JERK_PATH_OPTIMIZER 执行耗时 : 8.58712 ms.\nI0206 19:24:20.379036 18917 lane_follow_stage.cc:196] task -&gt;  PATH_ASSESSMENT_DECIDER 执行耗时 : 1.73497 ms.\nI0206 19:24:20.379052 18917 lane_follow_stage.cc:196] task -&gt;  PATH_DECIDER 执行耗时 : 0.00619888 ms.\nI0206 19:24:20.379058 18917 lane_follow_stage.cc:196] task -&gt;  RULE_BASED_STOP_DECIDER 执行耗时 : 0.00238419 ms.\nI0206 19:24:20.379397 18917 lane_follow_stage.cc:196] task -&gt;  SPEED_BOUNDS_PRIORI_DECIDER 执行耗时 : 0.333786 ms.\nI0206 19:24:20.380827 18917 lane_follow_stage.cc:196] task -&gt;  SPEED_HEURISTIC_OPTIMIZER 执行耗时 : 1.42074 ms.\nI0206 19:24:20.380861 18917 lane_follow_stage.cc:196] task -&gt;  SPEED_DECIDER 执行耗时 : 0.0245571 ms.\nI0206 19:24:20.381150 18917 lane_follow_stage.cc:196] task -&gt;  SPEED_BOUNDS_FINAL_DECIDER 执行耗时 : 0.281811 ms.\nI0206 19:24:20.383031 18917 lane_follow_stage.cc:196] task -&gt;  PIECEWISE_JERK_SPEED_OPTIMIZER 执行耗时 : 1.87016 ms.\nI0206 19:24:20.383045 18917 lane_follow_stage.cc:196] task -&gt;  RSS_DECIDER 执行耗时 : 0.00429153 ms.\n\n他的作用：\n\n判断当前是否进行变道，以及变道的状态，并将结果存在变量lane_change_status中；\n变道过程中将目标车道的reference line放置到首位，变道结束后将当前新车道的reference line放置到首位\n\n默认配置\ndefault_task_config: &#123;\n  task_type: LANE_CHANGE_DECIDER\n  lane_change_decider_config &#123;\n    enable_lane_change_urgency_check: false\n    enable_prioritize_change_lane: false\n    enable_remove_change_lane: false\n    reckless_change_lane: false\n    change_lane_success_freeze_time: 1.5\n    change_lane_fail_freeze_time: 1.0\n  &#125;\n&#125;\n\n在LaneChangeDecider中我们并没有看到Execute函数，但是前面说task执行就会调用task的Execute函数这是为什么呢？\n我们看task 类的Execute的函数\n我们看LaneChangeDecider继自decider类的Execute函数\napollo::common::Status Decider::Execute(\n    Frame* frame, ReferenceLineInfo* reference_line_info) &#123;\n  Task::Execute(frame, reference_line_info);\n  return Process(frame, reference_line_info);\n&#125;\n\n他是重写类Execute函数，并且他的作用就是调用基类task的Execute函数(他的作用就是复制配置文件)后，重新调用Process类。所以一个task的规划逻辑还是在decider的子类的Process函数中\n","slug":"Scenario","date":"2023-01-17T10:49:27.000Z","categories_index":"apollo-源码分析","tags_index":"apollo","author_index":"yuri2078"},{"id":"3b8a14a53e41ce2f72f6537d61475809","title":"yuriSTL","content":"常用知识点引用折叠\n\n\n\n\n\n\n\n\n当有一个为左值时 &amp;&amp; &amp; 都会折叠成 &amp;, 只有都是 &amp;&amp; 才会折叠成&amp;&amp;两个参数指的是 原来的数据类型 和 接受的数据类型\n举例 : 函数接受 T &amp;x。传入 T &amp;&amp; 或者 T &amp;时 x 都为 T &amp; 类型\n函数接受 T &amp;&amp;x。传入 T &amp;时 x 为 T &amp; 类型  传入 T &amp;&amp; 时， x 为 T &amp;&amp;类型\n但是 x 肯定是 &amp; 左值引用，因为他有名字，有名字就是左值引用\nnew 和 delete\n我们用的new 例如，new Person 是分配具体对象内存，并进行初始化操作 new [] 则是分配数组\n我们常用的delete 例如，delete p (p 为 new 出来的对象),他会调用类的析构函数，并释放申请的内存。 delete [] 则是释放数组\nnew 和 delete，new [] 和 delete [] 是一一对应的。\n::operator new(size) 效果和malloc 一样，返回指向size字节地址的void 指针\n::operator delete(ptr) 效果和free一样，释放ptr所指向的地址 \n::operator new 和 ::operator delete 需要一一对应\n::operator new 并不会初始化对象，只是申请内存\n::new(ptr) 参数 叫做placement new 用来初始化对象，比如初始化类，调用对应的构造函数\n\n模板萃取\n\n\n\n\n\n\n\n\n有时候我们需要判断是不是基础数据类型，此时我们可以使用模板存取的方法来判断\n实现方式：\n\n我们定义两个结构体__true_type 表示这是基础类型， __false_type 表示这不是基础类型。 通过函数重载实现不同处理方法\nstruct __true_type &#123;\n&#125;;\n\nstruct __false_type &#123;\n&#125;;\n\nvoid fun(struct __false_type);\nvoid fun(struct __true_type);\n\n了解第一步我们知道 —- 如果要通过重载实现不同处理，我们需要确定输入的类型是__true_type 还是 __false_type 那我们每次都要是实例化不同的结构体，很麻烦。但是我们typedef __true_type __type typedef __true_type __type 后，每次实例化只用__type struct_name 就行，然后我们调用fun(struct_name) 就行。\n&#x2F;&#x2F; 原始情况，不同情况我们需要写不同的代码，不能作到统一\nstruct __true_type struct_name; &#x2F;&#x2F; 基础类型\nstruct __fasle_type struct_name; &#x2F;&#x2F; 非基础类型\nfun(struct_name);\n\n&#x2F;&#x2F;神秘代码的功能就是 typedef 正确类型 __type\n  \nstruct __type struct_name; &#x2F;&#x2F; 我们就能写出通用的代码\nfun(struct_name);\n\n经过第三步我们已经知道要想写出通用代码我们需要将__type 重新定向为真确的类型也就是 __true_type 还是 __false_type. 此时就用到了模板萃取。我们定义一个结构体is_type 他将 __false_type 定义为 __type 。此时我们使用 __type就可以定义__false_type 了\ntemplate &lt;typename T&gt;\nstruct is_type &#123;\n\ttypedef __false_type __type;\n&#125;;\n\n此时你想不对啊，我们传入的参数不可能一定是非基础类型啊，也有可能是int 类型的。那好我们给模板来个特化版本,他将 __true_type 定义为 __type 此时我们使用 __type就可以定义__true_type 了，因为特化版本高于普通模板所以当传入的类型为int 时会优先调用特化版本\ntemplate &lt;&gt;\nstruct is_type&lt;int&gt; &#123;\n\ttypedef __true_type __type;\n&#125;;\n&#x2F;&#x2F; 结构体名字必须和上面一样，是上面的特化版本 \n\n此时我们已经能够处理int 和别的类型了。\n如果T 是 int 类型 会实例化is_type的特化版本struct is_type&lt;int&gt;然后 typedef __true_type __type，所以is_type&lt;T&gt;::__type 就是 __true_type \n如果T 不是 int 类型 会实例化is_type的普通版本 struct is_type然后 typedef __false_type __type，所以is_type&lt;T&gt;::__type 就是 __false_type \n通过上面的操作我们通过模板萃取了int类型和别的类型\ntypename is_type&lt;T&gt;::__type struct_name;\nfun(struct_name);\n\n我们扩大范围，将所有基础类型都特化一个版本，这样只有自定义类型(类&#x2F;结构体) 的 is_type&lt;T&gt;::__type 是 __false_type 别的都是__true_type\n\n完整代码\n&#x2F;&#x2F; 判断是不是基础类型\nstruct __true_type &#123;\n&#125;;\n\n&#x2F;*\n    声明两个结构体一个代表是基础类型 一个代表不是基础类型\n    定义is_type 结构体 如果类型已经确定 他会生成 后面已经确定类型对应的is_type\n    如果类型不是已经确定的 就会生成第一个 通过将 __type 指代不同的结构体\n\t在调用函数时 通过不同的参数重载函数 达到不同的效果\n*&#x2F;\n\nstruct __false_type &#123;\n&#125;;\n\n&#x2F;&#x2F; class 类型 需要析构\ntemplate &lt;typename T&gt;\nstruct is_type &#123;\n\ttypedef __false_type __type;\n&#125;;\n\ntemplate &lt;&gt;\nstruct is_type&lt;bool&gt; &#123;\n\ttypedef __true_type __type;\n&#125;;\n\ntemplate &lt;&gt;\nstruct is_type&lt;int&gt; &#123;\n\ttypedef __true_type __type;\n&#125;;\n......省略一堆特化\n\n使用案例请看 allocator 的 destroy 实现\n\n\n异常退回\n\n\n\n\n\n\n\n\n我写的推出代码我做主！\n\n内存分配失败异常 —- operator::new 返回空指针\n数组访问越界异常 —- 一共3个元素，你访问 [3]\n当前没有元素你却要他返回东西 —- 容器是空的，但你然我返回元素\n\n\n常用函数std::move\n\n\n\n\n\n\n\n\n使用方法： std::move(Tp &amp;&amp;t); 将传入的参数转化为右值返回\n作用： 当你需要使用移动构造的时候，需要传入右值。用move 函数可以将传入的参数转换成右值返回，这样就可以调用移动构造了\n实现原理： 将传入的参数val 去除引用后得到原来的基础类型，然后强制转换为右值返回就行\ntemplate &lt;typename T&gt;\nconstexpr typename remove_reference&lt;T&gt;::__type&amp;&amp; move(T &amp;&amp;val) noexcept&#123;\n\treturn static_cast&lt;typename remove_reference&lt;T&gt;::__type &amp;&amp;&gt;(val);\n&#125;\n\nstd::remove_reference\n\n\n\n\n\n\n\n\n使用方法: std::remove_reference&lt;模板参数&gt;::type 变量名 将type 重新定向为传入的模板参数的去引用类型\n作用： 当你需要数据的去引用类型的时候，比如使用std::move 的源码。需要强制转为 &amp;&amp; 类型，但是如果参数不是&amp;&amp; 类型，同&amp;&amp;强转后会发生引用折叠，此时就会返回一个&amp;类型。所以需要强转为去除引用后，使用去引用的类型 的 &amp;&amp;类型\n实现原理： 重载一个结构体，将T typedef 为 __type ,然后不论他生成的是哪个模板，因为函数重载的原因，__type 总是他的去引用数据类型\n&#x2F;&#x2F; 定义结构体模板\ntemplate &lt;typename T&gt;\nstruct remove_reference &#123;\n\ttypedef T __type;\n&#125;;\n\n&#x2F;&#x2F; 左值显式特化版本\ntemplate &lt;typename T&gt;\nstruct remove_reference&lt;T&amp;&gt; &#123;\n\ttypedef T __type;\n&#125;;\n\n&#x2F;&#x2F; 右值显式特化版本\ntemplate &lt;typename T&gt;\nstruct remove_reference&lt;T&amp;&amp;&gt; &#123;\n\ttypedef T __type;\n&#125;;\n\n\n\nstd::forward\n\n\n\n\n\n\n\n\n使用方法: Person p(std::forward&lt;T&gt; (val)); 将val完美转发到 p 的构造参数行列\n作用： 当你在一个函数里面初始化类的时候，你需要将类使用 传入的参数进行移动构造初始化，比如fun(T &amp;&amp;val),你需要用val 移动初始化一个类Person 此时你使用Person p(val)，他会调用拷贝构造函数，因为，val 是左值，所以需要将val转为右值发送，因为有时你需要拷贝构造函数。你可以重载函数进行此向操作，但太麻烦，此时用了完美转发，就可以避免这个问题！他会将你传入的参数，以原来的数据类型转发过去。\n&#x2F;&#x2F; 完美转发 : 左值转发\ntemplate &lt;typename T&gt;\nconstexpr T&amp;&amp; forward(typename remove_reference&lt;T&gt;::__type&amp; val) noexcept&#123;\n\treturn static_cast&lt;T&amp;&amp;&gt;(val);\n&#125;\n\n&#x2F;*\n  有两个是为了类型一一对应 这里使用了 remove_reference 所以一个固定接受左值引用\n\t一个固定接受右值，当结果是左值的时候，与T&amp;&amp; 折叠，结果仍然是左值\n\t当结果是右值时，与T&amp;&amp;折叠结果仍然是右值，达到完美转发的效果\n\t他并不是所有值进来都转换成右值，这和move是不一样的，也不能和move一样！所以需要区别使用\n\t而不是直接一个函数无脑 返回 T&amp;&amp;\n*&#x2F;\n\n&#x2F;&#x2F; 完美转发 ： 右值转发\ntemplate &lt;typename T&gt;\nconstexpr T&amp;&amp; forward(typename remove_reference&lt;T&gt;::__type&amp;&amp; val) noexcept\n&#123;\n\t&#x2F;&#x2F; 静态断言 如果传入的是个左值就报错\n\tstatic_assert(!is_lvalue_reference&lt;T&gt;().value, &quot;ni bu neng yong forward jiang yi ge zuo zhi zhuan huan cheng you zhi&quot;);\n\treturn static_cast&lt;T&amp;&amp;&gt;(val);\n&#125;\n\n\n\n\n\n\nyuriSTL\n\n\n\n\n\n\n\n\n手搓STL 源码。 目标 -&gt; 一年内，先简单的把他们搓出来\nallocator\n\n\n\n\n\n\n\n\n内存分配器，用来申请内存，并对实例化的对象进行初始化和析构.\n他本身实例化并不进行任何操作\ntemplate &lt;typename T&gt;\nclass allocator\n&#123;\npublic:\n\ttypedef T value_type; &#x2F;&#x2F; 基础数据类型\n\ttypedef T* pointer; &#x2F;&#x2F; 基础数据指针\n  \npublic:\n\tallocator() &#x3D; default;\n\t~allocator() &#x3D; default;\n\nallocate\n\n\n\n\n\n\n\n\n申请n 字节的空间，并返回对应类型的指针\n需求分析：\n\n申请内存\n返回对应指针\n\n案例实现：\n\n使用 operator new 分配内存\n使用static_cast 强转\n\n&#x2F;&#x2F; 分配size个空间，size_type 就是unsigned 类型\n\tstatic pointer allocate(size_type size) noexcept\n\t&#123;\n\t\tif (size &#x3D;&#x3D; 0) &#123;\n\t\t\treturn nullptr;\n    &#125;\n\t\treturn static_cast&lt;pointer&gt;(::operator new(size * sizeof(value_type)));\n\t&#125;\n\ndeallocate\n\n\n\n\n\n\n\n\n销毁申请的空间 —- 直接operator delete 就行\nstatic void deallocate(pointer ptr, size_type size) noexcept\n&#123;\n\t\tif (ptr &#x3D;&#x3D; nullptr) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\t::operator delete(ptr);\n&#125;\n\nconstruct\n\n\n\n\n\n\n\n\n初始化生成的空间 —- 直接使用 placement new 初始化就行. \n template &lt;typename... Args&gt;\nstatic void construct(pointer ptr, Args&amp;&amp;... args) noexcept\n&#123;\n\t&#x2F;&#x2F; 构造类的时候可能有多个参数，这些参数可能是左值，可能是右值，所以我们需要完美转发\n\t&#x2F;&#x2F; 完美转发需要配合万能引用使用，所以Args 必须是 &amp;&amp;\n\t::new(ptr) value_type(yuriSTL::forward&lt;Args&gt;(args)...);\n&#125;\n\ndestroy\n\n\n\n\n\n\n\n\n析构申请的空间 —- 基础类型不需要调用析构函数，所以为了节省资源，需要判断是不是基础类型。只有不是基础 类型才进行析构函数的调用\n简单指针：\n&#x2F;&#x2F; 简单指针，直接调用析构函数就行\ntemplate &lt;typename T&gt;\nvoid destroy(T* ptr) &#123;\n\tptr-&gt;~T();\n&#125;简单指针直接调用析构就行\n\n传入迭代器：   —- 当传入迭代器时，我们需要考虑是不是基础类型，因为基础类型不用析构，所以我们需要节省这部分开销\n通过模板萃取判断是不是基础类型 具体可以看上面模板萃取。不多解释直接上代码\n&#x2F;&#x2F; 是简单类型什么都不用做\ntemplate &lt;typename T&gt;\nvoid destroy__(T* start, T* end, __true_type) &#123; &#125;\n\n&#x2F;&#x2F; 不是简单类型调用析构函数\ntemplate &lt;typename T&gt;\nvoid destroy__(T* start, T* end, __false_type)\n&#123;\n\t&#x2F;&#x2F; 循环调用析构函数\n\tfor (; start !&#x3D; end; start++) &#123;\n\t\tstart-&gt;~T();\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 析构n个数据\ntemplate &lt;typename T&gt;\nvoid destroy(T* start, T* end)\n&#123;\n\t&#x2F;&#x2F; 判断是不是基础类型\n\ttypename is_type&lt;T&gt;::__type type;\n\t&#x2F;&#x2F; 通过另一个函数完成最终析构\n\tdestroy__(start, end, type);\n&#125;\n\n\n\nvector\n\n\n\n\n\n\n\n\n向量模板库，类似与数组，他可以随即访问元素，但是只能从后面插入并不能从正面插入。且插入删除数据效率较低。必要时可能还要重新开辟内存\n实现原理： 直接申请管理维护一串连续的空间就行\ntemplate &lt;typename T&gt;\nclass vector final\n&#123;\npublic:\n\ttypedef T value_type; &#x2F;&#x2F; 数据类型\n\ttypedef T* iterator; &#x2F;&#x2F; 指针&#x2F;迭代器\n  typedef T&amp; reference; &#x2F;&#x2F; 引用\n\n&#x2F;&#x2F; 成员变量\nprivate:\n\tvalue_type* begin_; &#x2F;&#x2F; 指向一块内存的起始地址\n\tvalue_type* end_; &#x2F;&#x2F; 最后一个元素的下一个位置\n\tvalue_type* tail_; &#x2F;&#x2F; 内存块的最后一块地址\n\tallocator&lt;T&gt; alloc; &#x2F;&#x2F; 新建分配内存的工具\n\nvector()默认构造函数\n\n\n\n\n\n\n\n\n默认构造函数 —- 啥也不干，申请16 个对象的空间就行，并把尾指针指向相应位置就好\n\n申请空间\n异常返回\n更新3个指针\n\nvector() noexcept\n&#123;\n   &#x2F;&#x2F; 申请空间\n\tbegin_ &#x3D; alloc.allocate(16); \n   &#x2F;&#x2F; 异常返回\n\tif (begin_ &#x3D;&#x3D; nullptr) &#123;\n\t\tyuriSTL::log(&quot;内存分配失败捏!&quot;); &#x2F;&#x2F; 以红色字体终端打印消息\n\t\texit(1); &#x2F;&#x2F; 并且退出程序，错误代码1\n\t&#125;\n\t&#x2F;&#x2F; 更新指针位置\n\tend_ &#x3D; begin_; \n\ttail_ &#x3D; begin_ + 16;\n&#125;\n\n拷贝构造函数\n\n\n\n\n\n\n\n\n传入一个vector 对象，用该对象就行拷贝构造\n\n申请一样大小的空间\n异常返回\n更新指针\n使用拷贝构造初始化\n\nvector(vector&lt;value_type&gt; &amp;v) noexcept\n\t&#123;\n\t\t&#x2F;&#x2F; 新建一块和他一样大的内存\n    begin_ &#x3D; alloc.allocate(v.max_size());\n  \t&#x2F;&#x2F; 异常判断\n\t\tif (begin_ &#x3D;&#x3D; nullptr) &#123;\n\t\t\tyuriSTL::log(&quot;内存分配失败捏!&quot;);\n\t\t\texit(1);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 更新指针\n\t\tconst int size &#x3D; v.size();\n\t\tend_ &#x3D; begin_ + size;\n\t\ttail_ &#x3D; begin_ + v.max_size();\n\t\t&#x2F;&#x2F; 调用构造函数进行构造\n\t\tfor (int i &#x3D; 0; i &lt; size; i++) &#123;\n\t\t\talloc.construct(begin_ + i, *(v.begin() + i));\n\t\t&#125;\n\t&#125;\n\n移动构造函数\n\n\n\n\n\n\n\n\n传入一个vector对象，将他的资源移动过来\n\n移动资源\n将原来的地址设为nullptr 防止重新利用\n\n&#x2F;&#x2F; 移动构造函数\n\tvector(vector&lt;value_type&gt; &amp;&amp;v) noexcept\n\t&#123;\n\t\t&#x2F;&#x2F; 移动资源\n\t\tbegin_ &#x3D; v.begin_;\n\t\tend_ &#x3D; v.end_;\n\t\ttail_ &#x3D; v.tail_;\n\n\t\t&#x2F;&#x2F; 将原来的地址设置为nullptr\n\t\tv.begin_ &#x3D; nullptr;\n\t\tv.end_ &#x3D; nullptr;\n\t\tv.tail_ &#x3D; nullptr;\n\t&#125;\n\n申请n个元素的空间\n\n\n\n\n\n\n\n\n直接申请n个元素的空间，但是并不需要进行初始化，是申请内存就行\n\n申请空间\n异常返回\n更新指针\n\n&#x2F;&#x2F; 使用n个对象初始化\n\texplicit vector(const size_type n)\n\t&#123;\n\t\t&#x2F;&#x2F; 申请空间\n\t\tbegin_ &#x3D; alloc.allocate(n);\n\t\t&#x2F;&#x2F; 异常返回\n\t\tif (begin_ &#x3D;&#x3D; nullptr) &#123;\n\t\t\tyuriSTL::log(&quot;内存分配失败捏!&quot;);\n\t\t\texit(1);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 更新指针\n\t\tend_ &#x3D; begin_;\n\t\ttail_ &#x3D; begin_ + n;\n\t&#125;\n\n初始化n个元素\n\n\n\n\n\n\n\n\n直接申请n个元素的空间，并且进行初始化就行捏\n\n申请空间\n异常返回\n更新指针\n初始化元素\n\n&#x2F;&#x2F; 初始化n个元素\n\tvector(const size_type n, const value_type &amp;val)\n\t&#123;\n\t\t&#x2F;&#x2F; 申请空间\n\t\tbegin_ &#x3D; alloc.allocate(n);\n\t\t&#x2F;&#x2F; 异常返回\n\t\tif (begin_ &#x3D;&#x3D; nullptr) &#123;\n\t\t\tyuriSTL::log(&quot;内存分配失败捏!&quot;);\n\t\t\texit(1);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 更新指针\n\t\tend_ &#x3D; begin_ + n;\n\t\ttail_ &#x3D; begin_ + n;\n\t\t&#x2F;&#x2F; 初始化元素\n\t\tfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\t\talloc.construct(begin_ + i, val);\n\t\t&#125;\n\t&#125;\n\n~vector()\n\n\n\n\n\n\n\n\n析构函数 析构掉对象，并释放掉申请的内存，并将她重新赋值为nulllptr就行\n&#x2F;&#x2F; 析构函数\n\t~vector() \n\t&#123;\n\t\t&#x2F;&#x2F; 调用函数对类进行析构\n\t\talloc.destroy(begin_, end_);\n\t\t&#x2F;&#x2F; 删除掉申请的内存\n\t\tif (begin_) &#123;\n\t\t\talloc.deallocate(begin_);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 将他们设置为nullptr 防止被重新利用\n\t\tbegin_ &#x3D; nullptr;\n\t\tend_ &#x3D; nullptr;hu shi hua\n\t\ttail_ &#x3D; nullptr;\n\t&#125;\n\npush_back\n\n\n\n\n\n\n\n\n从末尾插入一个元素，并进行初始化。如果是左值插入，直接传递参数调用构造函数就行，但是如果是右值就需要使用完美转发了。不然都会调用拷贝构造函数\n\n判断剩余空间是否够\n插入并初始化\n更新指针\n\n&#x2F;&#x2F; 从尾部插入元素 左值\n\tvoid push_back(const value_type&amp; val)\n\t&#123;\n\t\t&#x2F;&#x2F; 判断空间是不是满了\n\t\tif (end_ &#x3D;&#x3D; tail_) &#123;\n\t\t\trelloc(); &#x2F;&#x2F; 如果空间满了则重新分配空间默认 大小 X 2\n\t\t&#125;\n\t\t&#x2F;&#x2F; 插入，并更新指针\n\t\talloc.construct(end_++, val);\n\t&#125;\n\n&#x2F;&#x2F; 从尾部插入元素 右值\n\tvoid push_back(value_type&amp;&amp; val)\n\t&#123;\n\t\t&#x2F;&#x2F; 判断空间是不是满了\n\t\tif (end_ &#x3D;&#x3D; tail_) &#123;\n\t\t\trelloc();\n\t\t&#125;\n\t\t&#x2F;&#x2F; 通过完美转发传递参数\n\t\talloc.construct(end_++, yuriSTL::forward&lt;value_type&gt;(val));\n\t&#125;\n\nsize\n\n\n\n\n\n\n\n\n 返回当前元素个数\n&#x2F;&#x2F; 返回当前元素个数\n    const int size() &#123;\n        return end_ - begin_;\n    &#125;\n\nmax_size\n\n\n\n\n\n\n\n\n返回容器最大元素个数\n&#x2F;&#x2F; 返回最大元素个数\n    const int max_size() &#123;\n        return tail_ - begin_;\n    &#125;\n\nempty\n\n\n\n\n\n\n\n\n判断容器是不是为空\n&#x2F;&#x2F; 判断容器是否为空\n\tconst bool empty() &#123; \n\t  return end_ &#x3D;&#x3D; begin_; \n\t&#125;\n\nfront\n\n\n\n\n\n\n\n\n如果容器不为空就返回第一个元素的引用\n&#x2F;&#x2F; 返回首部元素\n\treference front() \n\t&#123;\n\t\tif (empty()) &#123;\n\t\t\tyuriSTL::log(&quot;当前元素为空!&quot;);\n\t\t\texit(3);\n\t\t&#125;\n\t\treturn *begin_;\n\t&#125;\n\nback\n\n\n\n\n\n\n\n\n如果容器不为空就返回最后一个元素的引用\n&#x2F;&#x2F; 返回末尾元素\n\treference back()\n\t&#123;\n\t\tif (empty()) &#123;\n\t\t\tyuriSTL::log(&quot;当前元素为空!&quot;);\n\t\t\texit(3);\n\t\t&#125;\n\t\treturn *(end_ - 1);\n\t&#125;\n\nbegin\n\n\n\n\n\n\n\n\n返回迭代器的起始位置 —- 因为是向量直接返回申请的地址首地址就行\niterator begin() noexcept &#123; \n  return begin_; \n&#125;\n\nend\n\n\n\n\n\n\n\n\n返回迭代器的末尾位置 —- 返回最后一个元素的下一个地址就行\n&#x2F;&#x2F; 返回末尾迭代器\n\titerator end() noexcept &#123; \n\t  return end_;\n  &#125;\n\ndata\n\n\n\n\n\n\n\n\n返回数据的开始地址\niterator data() noexcept &#123; \n  return begin_; \n&#125;\n\nat\n\n\n\n\n\n\n\n\n返回某个元素的引用，会检查是否越界。\n&#x2F;&#x2F; 返回对应元素个数\n\treference at(const int k)\n\t&#123;\n\t\tif (k &gt;&#x3D; end_ - begin_) &#123;\n\t\t\tyuriSTL::log(&quot;错误！超出内存范围!&quot;);\n\t\t\texit(2);\n\t\t&#125;\n    return *(begin_ + k);\n\t&#125;\n\noperator[]\n\n\n\n\n\n\n\n\n返回指定下标的引用\n&#x2F;&#x2F; 重载[] 返回对应下标元素\n\treference operator[](int k)\n\t&#123;\n      if (k &gt;&#x3D; end_ - begin_) &#123;\n\t\t\t  yuriSTL::log(&quot;错误！超出内存范围!&quot;);\n\t\t\t  exit(2);\n      &#125;\n      return *(begin_ + k);\n\t&#125;\n\noperator&#x3D;\n\n\n\n\n\n\n\n\n重载等号返回自身的引用\n&#x2F;&#x2F; 重载等号\n\treference operator&#x3D;(cosnt vector&lt;value_type&gt; &amp;v)\n\t&#123;\n\t\t&#x2F;&#x2F; 调用函数对之前的数据进行析构\n\t\talloc.destroy(begin_, end_);\n\t\t&#x2F;&#x2F; 删除掉之前申请的内存\n\t\talloc.deallocate(begin_);\n\t\t&#x2F;&#x2F; 重新申请内存\n\t\tbegin_ &#x3D; alloc.allocate(v.max_size());\n\t\t&#x2F;&#x2F; 判断是否异常\n    if (begin_ &#x3D;&#x3D; nullptr) &#123;\n\t\t\tyuriSTL::log(&quot;内存分配失败捏!&quot;);\n\t\t\texit(1);\n\t\t&#125;\n\t\t&#x2F;&#x2F; 更新指针\n\t\tend_ &#x3D; begin_ + v.size();\n\t\ttail_ &#x3D; begin_ + v.max_size();\n\t\t&#x2F;&#x2F; 完成初始化操作\n\t\tfor (int i &#x3D; 0; i &lt; v.size(); i++) &#123;\n\t\t\t*(begin_ + i) &#x3D; *(v.begin_ + i);\n\t\t&#125;\n\n\t\treturn *this;\n\t&#125;\n\n","slug":"yuriSTL","date":"2023-01-15T12:40:13.000Z","categories_index":"c/c++","tags_index":"c/c++,STL","author_index":"yuri2078"},{"id":"c00933af42671bcc3f6c5189813864ff","title":"vscode-apollo-debug","content":"更高效的阅读源码使用vscode 单步调试重新编译planning\naem enter 进入工作空间\nbuildtool build --dbg --packages planning_customization 以dbg模式重新编译planning\n\n开始单步调试\n先使用vscode ssh 连接docker 容器\n\n新建 launch 文件\n\n打开apollo 的 /apollo_workspace 工作空间\n\n在vscode 中新建一个文件夹名为.vscode\n\n在.vscode 中新建一个launch.json 文件\n\n文件内容如下\n\n\n\n\n\n\n\n\n\n基于apollo aem 安装版本，源码编译的请自己修改相应配置\n&#123;\n    &quot;version&quot;: &quot;0.2.0&quot;,\n    &quot;configurations&quot;: [\n        &#123;\n            &quot;name&quot;: &quot;apollo-dbg&quot;,\n            &quot;type&quot;: &quot;cppdbg&quot;,\n            &quot;request&quot;: &quot;launch&quot;,\n            &quot;program&quot;: &quot;&#x2F;opt&#x2F;apollo&#x2F;neo&#x2F;bin&#x2F;mainboard&quot;, &#x2F;&#x2F; 源码编译的自行更改为对应mainboard 位置\n          \t&#x2F;&#x2F; 如果需要调试别的模块，请改成对应的dag 文件就行\n            &quot;args&quot;: [&quot;-d&quot;,&quot;&#x2F;apollo_workspace&#x2F;modules&#x2F;planning&#x2F;dag&#x2F;planning.dag&quot;], &#x2F;&#x2F; planning dag 位置\n            &quot;stopAtEntry&quot;: false,\n            &quot;cwd&quot;: &quot;&#x2F;apollo_workspace&quot;, &#x2F;&#x2F; 源码编译的请改为 &#x2F;apollo\n            &quot;environment&quot;: [],\n            &quot;externalConsole&quot;: false,\n            &quot;MIMode&quot;: &quot;gdb&quot;,\n            &quot;setupCommands&quot;: [\n                &#123;\n                    &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;,\n                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,\n                    &quot;ignoreFailures&quot;: true\n                &#125;\n            ],\n            &quot;miDebuggerPath&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;gdb&quot;\n        &#125;\n    ]\n&#125;\n\n\n在需要调试的位置打上断点\n\n\n\n\n\n\n\n\n\n在没有开启Routing 模块之前，请不要把断电打在 planning_base_-&gt;Init(config_); 这条语句之前\n不然会每隔 50ms AERROR 一次 Routing is not ready.\n因为在这个Init 函数中，Start 函数 参考线提供器,会另启动一个线程,执行一个定时任务,每隔50ms提供一次参考线\n\n\n点击这里开始调试\n\n等一会，然后等他停在你打的断点这里就成功了\n\n\n\n\n\n\n\n\n\n到这里你就可以开始调试了，你可以使用调试菜单就行单步调试了\n\n\n\n灵活使用调试菜单\n变量区域在图上 1 号区域，可以看到此时程序运行临时变量 全局变量的值，需要看直接去看就行\n调试按钮\n\n\n\n\n\n\n\n\n每个序号对应2 号区域每个按钮\n\n继续 — 他会直接继续运行程序，知道遇到下一个断点，或程序结束\n单步跳过 — 单步跳过代码，遇到函数会直接跳过，并不会进入函数\n单步进入 — 单步进入代码，如果是普通语句会直接跳过，如果是函数之类的会直接跳到函数内部\n单步退出 — 单步退出代码，效果就是单步退出单步进入的代码\n重新开始 — 重新开始调试\n结束调试 — 结束本次调试\n\n使用AINFO 打印日志\n\n\n\n\n\n\n\n\n因为 apollo 使用的是google 的glog 所以，如果有别的需求的也可以去看看glog 的使用方法 \n使用方法\n\n\n\n\n\n\n\n\n我直介绍最简单的方法，知道这个也够了。如果需要别的方法，也可以去找glog 使用方法，然后自己进行修改\nAINFO 打印日志if (FLAGS_use_navigation_mode) &#123;\n    planning_base_ &#x3D; std::make_unique&lt;NaviPlanning&gt;(injector_); &#x2F;&#x2F;相对地图规划器\n  &#125; else &#123;\n    planning_base_ &#x3D; std::make_unique&lt;OnLanePlanning&gt;(injector_); &#x2F;&#x2F;默认规划器\n  &#125;\n\n举例子，当我想知道开始这个planning_base_ 究竟是哪个的时候，我们直接在这段代码后面打印 他的name 就行,apollo 大部分的类都提供了name 接口，直接打印就行\nAINFO &lt;&lt; &quot;本次选择的规划器是 -&gt; &quot; &lt;&lt; planning_base_-&gt;Name();\n\n所以直接 AINFO &lt;&lt; “你想要而内容&quot; 就行。他会默认换行，但是如果很多  &lt;&lt; 他不会每个都换行，而是同一个AINFO 的内容在一行\n日志apollo 的 日志 都在/opt/apollo/neo/data/log/ 下面。如果是源码版本则是在/apollo/data/log/ 下\n每个 模块名.INFO (例如 : planning.INFO ) 都是对应模块最新一次的日志，而过去的日志回以日期命名存放在目录下面\n快速阅览日志\n\n\n\n\n\n\n\n\n在工作目录建立硬连接，这样就可以在工作目录直接看到日志了\n如果需要别的日志的直接吧planning 改成对应模块的名字就行了\nln -s &#x2F;opt&#x2F;apollo&#x2F;neo&#x2F;data&#x2F;log&#x2F;planning.INFO &#x2F;apollo_workspace&#x2F; \n\n","slug":"vscode-apollo-debug","date":"2023-01-13T11:33:33.000Z","categories_index":"apollo","tags_index":"apollo,vscode","author_index":"yuri2078"},{"id":"3eaaacbdaffc7d8287c3cb18668c7e62","title":"planning_OnLanePlanning（2）","content":"OnLanePlanning 源码分析\n\n\n\n\n\n\n\n\n因为入口Init 中，默认选择的规划器是 OnLanePlanning 所以我们主要介绍OnLanePlanning \nplanning_base\n\n\n\n\n\n\n\n\n这里的planning_base 不是真的planning_base 基类，而是代码中对 规划器的变量名\nbool PlanningComponent::Init() &#123;\n  AINFO &lt;&lt; &quot;planning component init 函数调用!&quot;;\n  injector_ &#x3D; std::make_shared&lt;DependencyInjector&gt;();\n  if (FLAGS_use_navigation_mode) &#123;\n    planning_base_ &#x3D; std::make_unique&lt;NaviPlanning&gt;(injector_); &#x2F;&#x2F;相对地图规划器\n  &#125; else &#123;\n    planning_base_ &#x3D; std::make_unique&lt;OnLanePlanning&gt;(injector_); &#x2F;&#x2F;默认规划器\n  &#125;\n  AINFO &lt;&lt; &quot;本次选择的规划器是 -&gt; &quot; &lt;&lt; planning_base_-&gt;Name();\n\t\t。。。。。 中间省略一些代码 。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。\n  AINFO &lt;&lt; &quot;正在执行planning_base 的初始化 &quot;;\n  planning_base_-&gt;Init(config_); &#x2F;&#x2F; 我们看到init 函数，他直接调用了对应规划器的init 函数\n\n在上文中提到，在init 函数中，会设置一个默认规划器初始规划其是 OnLanePlanning\nplanning_base_ = std::make_unique&lt;OnLanePlanning&gt;(injector_);\n而在init函数的中间他会率先执行 planning_base_ 的 init函数也就是 OnLanePlanning 的init函数\nplanning_base_ -&gt; Init(config_);\nplannerDispatcher\n\n\n\n\n\n\n\n\n在OnLanePlanning 的构造函数中指定了 OnLanePlannerDispatcher (第5行)\n我们发现他的构造函数只有一条语句 也就是说，一开始OnLanePlanning 选择的plannerDispatcher 就是OnLanePlannerDispatcher (这不废话？不选自己对应的难道选别人的？)\nclass OnLanePlanning : public PlanningBase &#123;\n public:\n  explicit OnLanePlanning(const std::shared_ptr&lt;DependencyInjector&gt;&amp; injector) : PlanningBase(injector) &#123;\n    AINFO &lt;&lt; &quot;onlane planning 类构造函数 新建合适的planner&quot;;\n    planner_dispatcher_ &#x3D; std::make_unique&lt;OnLanePlannerDispatcher&gt;();\n  &#125;\n\n所以，后续的 planner_dispathcer 都是指向的 OnLanePlannerDispatcher 类\nInit 函数\n\n\n\n\n\n\n\n\n在OnLanePlanner 的init 函数中指定了 planner 为 PUBLIC_ROAD (默认planner) (第44行)\nStatus OnLanePlanning::Init(const PlanningConfig&amp; config) &#123;\n  AINFO &lt;&lt; &quot;on_lane_planning 初始化 &quot;;\n  config_ &#x3D; config;\n  &#x2F;&#x2F; 检查config文件，这里并不完全，也可以添加其他检查项\n  if (!CheckPlanningConfig(config_)) &#123;\n    return Status(ErrorCode::PLANNING_ERROR, &quot;配置文件错误捏! &quot; + config_.DebugString());\n  &#125;\n  \n  &#x2F;&#x2F; TaskFactory  工厂类在 planningBase init 中初始化\n  PlanningBase::Init(config_); &#x2F;&#x2F; 基础规划其初始化\n\n  &#x2F;&#x2F; planner_dispatcher 在OnLanePlannner 构造函数中创建\n  &#x2F;&#x2F; planner_factory 路径规划工厂类注册，包含rtk publick_road lattice等\n\n  planner_dispatcher_-&gt;Init();\n\n&#x2F;&#x2F; 交通配置文集 modules&#x2F;planning&#x2F;conf&#x2F;traffic_rule_config.pb.txt\n  ACHECK(apollo::cyber::common::GetProtoFromFile(\n      FLAGS_traffic_rule_config_filename, &amp;traffic_rule_configs_))\n      &lt;&lt; &quot;加载交通配置文件失败!&quot;\n      &lt;&lt; FLAGS_traffic_rule_config_filename;\n\n  &#x2F;&#x2F; clear planning history\n  &#x2F;&#x2F; 清除规划历史\n  injector_-&gt;history()-&gt;Clear();\n\n  &#x2F;&#x2F; clear planning status\n  &#x2F;&#x2F; 清除规划状态\n  injector_-&gt;planning_context()-&gt;mutable_planning_status()-&gt;Clear();\n\n  &#x2F;&#x2F; load map\n  &#x2F;&#x2F; 加载地图\n  hdmap_ &#x3D; HDMapUtil::BaseMapPtr();\n  ACHECK(hdmap_) &lt;&lt; &quot;加载地图失败！&quot;;\n\n  &#x2F;&#x2F; instantiate reference line provider\n  AINFO &lt;&lt; &quot;启动参考线提供器,会另启动一个线程,执行一个定时任务,每隔50ms提供一次参考线&quot;;\n  reference_line_provider_ &#x3D; std::make_unique&lt;ReferenceLineProvider&gt;(injector_-&gt;vehicle_state(), hdmap_); \n  reference_line_provider_-&gt;Start(); &#x2F;&#x2F; 生成参考线\n\n  &#x2F;&#x2F; dispatch planner\n  &#x2F;&#x2F; 创建planner object 这里的配置文集那是 PUBLIC_ROAD planner\n  &#x2F;&#x2F; 为Planning分配具体的Planner\n  planner_ &#x3D; planner_dispatcher_-&gt;DispatchPlanner(config_, injector_);\n\n  if (!planner_) &#123;\n    AINFO &lt;&lt; &quot;planner 为nullptr 分配失败!&quot;;\n    return Status(ErrorCode::PLANNING_ERROR, &quot;planning is not initialized with config : &quot; + config_.DebugString());\n  &#125;else &#123;\n    AINFO &lt;&lt; &quot;分配planner -&gt; &quot;  &lt;&lt; planner_-&gt;Name(); \n  &#125;\n\n  if (config_.learning_mode() !&#x3D; PlanningConfig::NO_LEARNING) &#123;\n    PlanningSemanticMapConfig renderer_config;\n    ACHECK(apollo::cyber::common::GetProtoFromFile(\n        FLAGS_planning_birdview_img_feature_renderer_config_file,\n        &amp;renderer_config))\n        &lt;&lt; &quot;Failed to load renderer config&quot;\n        &lt;&lt; FLAGS_planning_birdview_img_feature_renderer_config_file;\n\n    BirdviewImgFeatureRenderer::Instance()-&gt;Init(renderer_config);\n  &#125;\n\n  start_time_ &#x3D; Clock::NowInSeconds();\n\n  return planner_-&gt;Init(config_); &#x2F;&#x2F; 返回对planner 进行初始化的结果\n&#125;\n\n\n\nRunOnce 函数\n\n\n\n\n\n\n\n\n以规划模式OnLanePlanning，执行RunOnce。在RunOnce中先执行交通规则，再规划轨迹。规划轨迹的函数是 Plan。\n简单总结：\n\n\n\n\n\n\n\n\n不知道planning大概由哪些组成可以看我之前的文章 planning 入口\n\n我把整个planning 模块的结构分为四层，除了第一层component ,其他几个都是在planning_compoent 的init 函数中被确认的\nOnLanePlanner 的构造函数中指定了第二层的 OnLanePlannerDispatcher  (planning_base)\nOnLanePlanner 的Init函数中指定了第三层的 OnLanePlannerDispatcher (planerDispatcher)\nOnLanePlanner 的Init函数中指定了第四层的 PUBLIC_ROAD (planner)\n\n\n在init 函数中他会读取文件，清除历史记录，并且分配planner。\n在Init 函数中，他会启动另一个线程开始生成参考线每50ms 生成一次，此时需要routing 输入\nPlanner 初始化 会生成一个管理场景的对象，用来管理场景。\nRunOnce 在planning_compoent 中被不断调用。\n\n","slug":"planning-OnLanePlanning","date":"2023-01-11T11:24:12.000Z","categories_index":"apollo-源码分析","tags_index":"apollo","author_index":"yuri2078"},{"id":"1e2fbbe6f8df83a5d7f4d6a9281e7fa7","title":"planning_component（1）","content":"apollo planning 模块分析\n\n\n\n\n\n\n\n\n只做简单分析，教程来自 知乎 -&gt; 自动驾驶Player\n更加详细的内容请去看 原文\n前言\n\n\n\n\n\n\n\n\n这里是我的个人理解不是官方理解，也不是原文的理解\nplanning 结构\nPlanning_component 入口 (作为cyber 组件的入口，我把它当作第一层)\n\n\n\n\n\n\n\n\n\n这个作为planning 模块的入口主要的作用就是两点\n1、对一些基础的东西进行初始化 (init 函数)\n2、作为cyber 组件 不断执行规划逻辑 (Proc 函数)\n\n三个规划器 （默认的是 OnLanePlanning）\n\n\n\n\n\n\n\n\n\n我认为这是planning 的第二层。 在 component 中选择规划器进行下一步的规划\n\nNavinPlanning 处理普通道路  \nOnLanePlanning 处理情况复杂的人行横道  主要的应用场景是开放道路的自动驾驶\nOpenSpasePlanning 处理泊车或者断路掉头情况   主要的应用场景是自主泊车和狭窄路段的掉头\n\n\n两个路径规划器\n\n\n\n\n\n\n\n\n\n每个规划器会调用自己对应的路径规划器，然后来进行路径规划。\n他在OnLanePlanning 的构造函数中就被构造，然后初始化\n他的作用就是选择创建对应的 planner \n\non_lane_planner_dispatcher (OpenSpasePlanning 、 OnLanePlanning 都是用的这个)\nnavi_planner_dispatcher (NavinPlanning 用的这个)\n\n\n几个 planner \n\n\n\n\n\n\n\n\n\n每个planner 承担了具体的规划逻辑(Plan 函数)\n主要介绍 on_lane_planner_dispatcher 下默认的 public_road_planner\n\n\nplanning 规划流程\n在入口planning_component 中进行初始化(Init 函数只执行一次)\n选择对应的规划器，并进行初始化\n加载配置，检查配置文件\n读取一系列的配置数据\n\n\n在入口planning_component 中执行具体的规划逻辑(Proc 函数，不断执行)\n检查路由\n执行具体规划逻辑\n发布新路线\n\n\n\ncyber 组件每个组件的入口函数是 Proc 函数\n\napollo 是基于 cyber 通信框架的\n\n具体可以去看我的另外一篇文章 cyberRT开发教程\n\n下面是一个最基础的cyber 组件框架 （.h 文件） planning 的差不多也是如此\n#ifndef MY_COMPONENTS\n#define MY_COMPONENTS\n\n#include &quot;cyber&#x2F;cyber.h&quot; &#x2F;&#x2F; cyber 基础头文件\n#include &quot;cyber&#x2F;component&#x2F;component.h&quot; &#x2F;&#x2F; component 基础头文件\n#include &quot;cyber&#x2F;demo_cpp&#x2F;components&#x2F;Student.pb.h&quot; &#x2F;&#x2F; 通信载体protobuf 文件编译成的c++ 文件\n\nusing apollo::cyber::Component;\nusing apollo::cyber::demo_cpp::Student;\n\n&#x2F;&#x2F;继承需要添加数据模板\nclass my_components : public Component&lt;Student&gt; \n&#123;\nprivate:\n    &#x2F;* data *&#x2F;\npublic:\n\n    bool Init() override; &#x2F;&#x2F;表示重写函数，初始化函数\n    bool Proc(const std::shared_ptr&lt;Student&gt; &amp;stu) override; &#x2F;&#x2F;数据处理函数\n    \n&#125;;\n\nCYBER_REGISTER_COMPONENT(my_components) &#x2F;&#x2F;注册组件\n#endif\n\n简单cyber 组件的组成Conponent 类知识点\n\n他继承自Component 类，他是所有通信模块的基类\n\n他的原型  他是继承自ConponentBase 这个我就不管了，这是隔壁cyber的东西\ntemplate &lt;typename M0, typename M1, typename M2,  typename M3&gt; &#x2F;&#x2F; 接受四个模板类型 也就是消息载体 - protobuf\nclass Component&lt;M0, M1, M2, M3&gt; : public ComponentBase &#123; \n\nComponent&lt;M0, M1, M2, M3&gt; 由此看出他最多接收4个数据类型。\n\n\n\n\n\n\n\n\n\n他需要的都是通信载体，也就是protobuf 类信息，如果不知道这是啥，可以百度捏。简单来说就是自定义数据类\n\n\nInit 函数\n\n\n\n\n\n\n\n\n 继承自Component_base  纯虚类，所以需要重写\n函数原型 virtual bool Init() = 0;\n知识点\n\nInit 函数来自于Conponent_base 类 \n他不接受任何参数，并且会在执行Proc 函数之前被调用\n用途是 初始化\n\nProc 函数\n\n\n\n\n\n\n\n\n继承自 Conponent 纯虚类，所以需要重写\n函数原型  - planning 模块对应的函数原型\nvirtual bool Proc(const std::shared_ptr&lt;M0&gt;&amp; msg,\n                  const std::shared_ptr&lt;M1&gt;&amp; msg1,\n                  const std::shared_ptr&lt;M2&gt;&amp; msg2, \n                  const std::shared_ptr&lt;M2&gt;&amp; msg3) &#x3D; 0;\n\n知识点 \n\n他最多只能接受四个msg\n我们需要在Proc 函数中完成对传入的消息载体的处理\n这里是处理消息的主要地方\n\n注册组件CYBER_REGISTER_COMPONENT(my_components) &#x2F;&#x2F;对组件进行注册\n别的模块\n\n\n\n\n\n\n\n\n通过上面对简单组件的了解我门可以知道\n\napollo 的模块也是一个cyber组件\n每个模块通过接受消息，然后处理消息，最后将消息发送出去（通过cyber 通信框架）\ncyber 采用的通信协议是谷歌的protobuf 所以Component 类需要接受的四个消息都是由protobuf编译来的\n一个组件的入口函数是proc函数，但之前他会执行init 函数就行初始化\nProc 函数才是组件的主体处理逻辑\n\n常用类\n\n\n名称\n说明\n\n\n\nEgoInfo类\n包含了自车信息，例如：当前位置点，车辆状态，外围Box等。\n\n\nFrame类\n包含了一次Planning计算循环中的所有信息。\n\n\nFrameManager类\nFrame的管理器，每个Frame会有一个整数型id。\n\n\nLocalView类\nPlanning计算需要的输入，下文将看到其定义。\n\n\nObstacle类\n描述一个特定的障碍物。障碍物会有一个唯一的id来区分。\n\n\nPlanningContext类\nPlanning全局相关的信息，例如：是否正在变道。这是一个单例。\n\n\nReferenceLineInfo类\n车辆行驶的参考线，下文会专门讲解。\n\n\npath文件夹\n描述车辆路线信息。包含：PathData，DiscretizedPath，FrenetFramePath三个类。\n\n\nspeed文件夹\n描述车辆速度信息。包含SpeedData，STPoint，StBoundary三个类。\n\n\ntrajectory文件夹\n描述车辆轨迹信息。包含DiscretizedTrajectory，PublishableTrajectory，TrajectoryStitcher三个类。\n\n\nplanning_gflags.h\n定义了模块需要的许多常量，例如各个配置文件的路径。\n\n\nplanning 模块入口\n\n\n\n\n\n\n\n\n有了上面的基础相信你已经可以很好的阅读planning的基础源码了，让我们一起来看看planning的cyber组件吧\n本文的源码基于 apollo-8.0 edu 版本\n两个源码重要的地方都有注释\nplanning_component.hnamespace apollo &#123;\nnamespace planning &#123;\n\nclass PlanningComponent final &#x2F;&#x2F; final\n    : public cyber::Component&lt;prediction::PredictionObstacles, canbus::Chassis,\n                              localization::LocalizationEstimate&gt; &#123;\n public:\n  PlanningComponent() &#x3D; default; &#x2F;&#x2F;默认构造函数\n\n  ~PlanningComponent() &#x3D; default; &#x2F;&#x2F;默认析构函数\n\n public:\n  bool Init() override;\n\n  bool Proc(const std::shared_ptr&lt;prediction::PredictionObstacles&gt;&amp; rediction_obstacles, &#x2F;&#x2F; 预测的障碍物信息(prediction_obstacles)\n            const std::shared_ptr&lt;canbus::Chassis&gt;&amp; chassis, &#x2F;&#x2F; 车辆底盘(chassis)信息(车辆的速度，加速度，航向角等信息)\n            const std::shared_ptr&lt;localization::LocalizationEstimate&gt;&amp; localization_estimate)  &#x2F;&#x2F; 车辆当前位置(localization_estimate)\n            override; &#x2F;&#x2F; 表示重写函数\n\n private:\n  void CheckRerouting();\n  bool CheckInput();\n\n private:\n  std::shared_ptr&lt;cyber::Reader&lt;perception::TrafficLightDetection&gt;&gt; traffic_light_reader_; &#x2F;&#x2F; 读取红绿灯信息\n  std::shared_ptr&lt;cyber::Reader&lt;routing::RoutingResponse&gt;&gt; routing_reader_; &#x2F;&#x2F; 读取路由模块信息\n  std::shared_ptr&lt;cyber::Reader&lt;planning::PadMessage&gt;&gt; pad_msg_reader_;\n  std::shared_ptr&lt;cyber::Reader&lt;relative_map::MapMsg&gt;&gt; relative_map_reader_; &#x2F;&#x2F; 读取相对地图信息\n  std::shared_ptr&lt;cyber::Reader&lt;storytelling::Stories&gt;&gt; story_telling_reader_;\n\n  std::shared_ptr&lt;cyber::Writer&lt;ADCTrajectory&gt;&gt; planning_writer_; &#x2F;&#x2F; 将规划好的线路，发布到Control模块订阅的Topic中\n  std::shared_ptr&lt;cyber::Writer&lt;routing::RoutingRequest&gt;&gt; rerouting_writer_; &#x2F;&#x2F; 是否需要重新规划路线\n  std::shared_ptr&lt;cyber::Writer&lt;PlanningLearningData&gt;&gt; planning_learning_data_writer_;\n\n  std::mutex mutex_;\n  perception::TrafficLightDetection traffic_light_;\n  routing::RoutingResponse routing_;\n  planning::PadMessage pad_msg_;\n  relative_map::MapMsg relative_map_;\n  storytelling::Stories stories_;\n\n  LocalView local_view_;   &#x2F;&#x2F; 用于存放模块运行需要的数据\n\n  std::unique_ptr&lt;PlanningBase&gt; planning_base_; &#x2F;&#x2F; 规划器基类\n  std::shared_ptr&lt;DependencyInjector&gt; injector_;\n\n  PlanningConfig config_;\n  MessageProcess message_process_;\n&#125;;\n\n&#x2F;&#x2F; 在cyber中注册组件\nCYBER_REGISTER_COMPONENT(PlanningComponent)\n\n&#125;  &#x2F;&#x2F; namespace planning\n&#125;  &#x2F;&#x2F; namespace apollo\n\nplanning_component.ccnamespace apollo &#123;\nnamespace planning &#123;\n\nusing apollo::cyber::ComponentBase;\nusing apollo::hdmap::HDMapUtil;\nusing apollo::perception::TrafficLightDetection;\nusing apollo::relative_map::MapMsg;\nusing apollo::routing::RoutingRequest;\nusing apollo::routing::RoutingResponse;\nusing apollo::storytelling::Stories;\n\n&#x2F;&#x2F;初始化函数，用于初始化planning模块\nbool PlanningComponent::Init() &#123;\n  AINFO &lt;&lt; &quot;planning component init 函数调用!&quot;;\n  injector_ &#x3D; std::make_shared&lt;DependencyInjector&gt;();\n\n  &#x2F;&#x2F;NavinPlanning 处理普通道路  \n  &#x2F;&#x2F;OnLanePlanning 处理情况复杂的人行横道  主要的应用场景是开放道路的自动驾驶。\n  &#x2F;&#x2F;OpenSpasePlanning 处理泊车或者断路掉头情况   主要的应用场景是自主泊车和狭窄路段的掉头\n\n\n&#x2F;&#x2F;选择相应的规划器 默认是OnLanePlanning 模块\n  AINFO &lt;&lt; &quot;选择相应的规划器 默认是OnLanePlanning 模块 &quot;;\n  if (FLAGS_use_navigation_mode) &#123;\n    planning_base_ &#x3D; std::make_unique&lt;NaviPlanning&gt;(injector_); &#x2F;&#x2F;相对地图规划器\n    AINFO &lt;&lt; &quot;默认选择的是 : naviplanning&quot;;\n  &#125; else &#123;\n    planning_base_ &#x3D; std::make_unique&lt;OnLanePlanning&gt;(injector_); &#x2F;&#x2F;默认规划器\n    AINFO &lt;&lt; &quot;默认选择的是 : onlaneplanning&quot;;\n  &#125;\n\n&#x2F;&#x2F;加载config 文件\n  AINFO &lt;&lt; &quot;正在加载配置文件&quot;;\n  ACHECK(ComponentBase::GetProtoConfig(&amp;config_))\n      &lt;&lt; &quot;加载配置文件失败! 失败文件路径 ： &quot;\n      &lt;&lt; ComponentBase::ConfigFilePath();\n\n&#x2F;&#x2F; 这一句不知道干啥的\n  if (FLAGS_planning_offline_learning ||\n      config_.learning_mode() !&#x3D; PlanningConfig::NO_LEARNING) &#123;\n    if (!message_process_.Init(config_, injector_)) &#123;\n      AERROR &lt;&lt; &quot;failed to init MessageProcess&quot;;\n      return false;\n    &#125;\n  &#125;\n\n&#x2F;&#x2F;执行OnLanePlanning 的初始化\n  AINFO &lt;&lt; &quot;正在执行planning_base 的初始化 &quot;;\n  planning_base_-&gt;Init(config_);\n\n  &#x2F;&#x2F;获取路由（routig）模块信息\n  AINFO &lt;&lt; &quot;获取路由 routing信息&quot;;\n  routing_reader_ &#x3D; node_-&gt;CreateReader&lt;RoutingResponse&gt;(  &#x2F;&#x2F;新建reader\n      config_.topic_config().routing_response_topic(),\n      [this](const std::shared_ptr&lt;RoutingResponse&gt;&amp; routing) &#123;\n        AINFO &lt;&lt; &quot; 收到路由数据：运行路由回调。&quot;\n              &lt;&lt; routing-&gt;header().DebugString();\n        std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n        routing_.CopyFrom(*routing);\n      &#125;);\n\n  &#x2F;&#x2F;读取红绿灯\n  AINFO &lt;&lt; &quot;读取红绿灯信息&quot;;\n  traffic_light_reader_ &#x3D; node_-&gt;CreateReader&lt;TrafficLightDetection&gt;(\n      config_.topic_config().traffic_light_detection_topic(),\n      [this](const std::shared_ptr&lt;TrafficLightDetection&gt;&amp; traffic_light) &#123;\n        ADEBUG &lt;&lt; &quot;Received traffic light data: run traffic light callback.&quot;;\n        std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n        traffic_light_.CopyFrom(*traffic_light);\n      &#125;);\n\n  pad_msg_reader_ &#x3D; node_-&gt;CreateReader&lt;PadMessage&gt;(\n      config_.topic_config().planning_pad_topic(),\n      [this](const std::shared_ptr&lt;PadMessage&gt;&amp; pad_msg) &#123;\n        ADEBUG &lt;&lt; &quot;Received pad data: run pad callback.&quot;;\n        std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n        pad_msg_.CopyFrom(*pad_msg);\n      &#125;);\n\n  story_telling_reader_ &#x3D; node_-&gt;CreateReader&lt;Stories&gt;(\n      config_.topic_config().story_telling_topic(),\n      [this](const std::shared_ptr&lt;Stories&gt;&amp; stories) &#123;\n        ADEBUG &lt;&lt; &quot;Received story_telling data: run story_telling callback.&quot;;\n        std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n        stories_.CopyFrom(*stories);\n      &#125;);\n\n&#x2F;&#x2F;是否使用导航模式\n  AINFO &lt;&lt; &quot;判断是否使用导航模式&quot;;\n  if (FLAGS_use_navigation_mode) &#123;\n    &#x2F;&#x2F;读取相对地图\n    AINFO &lt;&lt; &quot;使用导航模式，正在读取相对地图&quot;;\n    relative_map_reader_ &#x3D; node_-&gt;CreateReader&lt;MapMsg&gt;(\n        config_.topic_config().relative_map_topic(),\n        [this](const std::shared_ptr&lt;MapMsg&gt;&amp; map_message) &#123;\n          ADEBUG &lt;&lt; &quot;Received relative map data: run relative map callback.&quot;;\n          std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n          relative_map_.CopyFrom(*map_message);\n        &#125;);\n  &#125;\n  &#x2F;&#x2F;发布规划好的线路\n  planning_writer_ &#x3D; node_-&gt;CreateWriter&lt;ADCTrajectory&gt;(\n      config_.topic_config().planning_trajectory_topic());\n\n  &#x2F;&#x2F;发布重新规划请求\n  rerouting_writer_ &#x3D; node_-&gt;CreateWriter&lt;RoutingRequest&gt;(\n      config_.topic_config().routing_request_topic());\n\n  planning_learning_data_writer_ &#x3D; node_-&gt;CreateWriter&lt;PlanningLearningData&gt;(\n      config_.topic_config().planning_learning_data_topic());\n\n  return true;\n&#125;\n\nbool PlanningComponent::Proc(\n    const std::shared_ptr&lt;prediction::PredictionObstacles&gt;&amp; prediction_obstacles, &#x2F;&#x2F; 预测的障碍物信息(prediction_obstacles)\n    const std::shared_ptr&lt;canbus::Chassis&gt;&amp; chassis, &#x2F;&#x2F; 车辆底盘(chassis)信息(车辆的速度，加速度，航向角等信息)\n    const std::shared_ptr&lt;localization::LocalizationEstimate&gt;&amp; localization_estimate) &#x2F;&#x2F; 车辆当前位置(localization_estimate) \n&#123;\n  AINFO &lt;&lt; &quot;planning—component Proc 函数调用!&quot;;\n  ACHECK(prediction_obstacles !&#x3D; nullptr);  &#x2F;&#x2F; 检查障碍物信息是不是为空\n\n  &#x2F;&#x2F; check and process possible rerouting request\n  &#x2F;&#x2F; 检查是否需要重新规划路线\n  CheckRerouting();\n\n  &#x2F;&#x2F; process fused input data\n  &#x2F;&#x2F; 数据放入local_view 中，并且检查输入的数据\n  local_view_.prediction_obstacles &#x3D; prediction_obstacles;\n  local_view_.chassis &#x3D; chassis;\n  local_view_.localization_estimate &#x3D; localization_estimate;\n  &#123;\n    std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n    if (!local_view_.routing ||\n        hdmap::PncMap::IsNewRouting(*local_view_.routing, routing_)) &#123;\n      local_view_.routing &#x3D;\n          std::make_shared&lt;routing::RoutingResponse&gt;(routing_);\n    &#125;\n  &#125;\n  &#123;\n    std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n    local_view_.traffic_light &#x3D;\n        std::make_shared&lt;TrafficLightDetection&gt;(traffic_light_);\n    local_view_.relative_map &#x3D; std::make_shared&lt;MapMsg&gt;(relative_map_);\n  &#125;\n  &#123;\n    std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n    local_view_.pad_msg &#x3D; std::make_shared&lt;PadMessage&gt;(pad_msg_);\n  &#125;\n  &#123;\n    std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n    local_view_.stories &#x3D; std::make_shared&lt;Stories&gt;(stories_);\n  &#125;\n\n  if (!CheckInput()) &#123;\n    AERROR &lt;&lt; &quot;Input check failed&quot;;\n    return false;\n  &#125;\n\n  if (config_.learning_mode() !&#x3D; PlanningConfig::NO_LEARNING) &#123;\n    &#x2F;&#x2F; data process for online training\n    message_process_.OnChassis(*local_view_.chassis);\n    message_process_.OnPrediction(*local_view_.prediction_obstacles);\n    message_process_.OnRoutingResponse(*local_view_.routing);\n    message_process_.OnStoryTelling(*local_view_.stories);\n    message_process_.OnTrafficLightDetection(*local_view_.traffic_light);\n    message_process_.OnLocalization(*local_view_.localization_estimate);\n  &#125;\n\n  &#x2F;&#x2F; publish learning data frame for RL test\n  if (config_.learning_mode() &#x3D;&#x3D; PlanningConfig::RL_TEST) &#123;\n    PlanningLearningData planning_learning_data;\n    LearningDataFrame* learning_data_frame &#x3D;\n        injector_-&gt;learning_based_data()-&gt;GetLatestLearningDataFrame();\n    if (learning_data_frame) &#123;\n      planning_learning_data.mutable_learning_data_frame()\n                            -&gt;CopyFrom(*learning_data_frame);\n      common::util::FillHeader(node_-&gt;Name(), &amp;planning_learning_data);\n      planning_learning_data_writer_-&gt;Write(planning_learning_data);\n    &#125; else &#123;\n      AERROR &lt;&lt; &quot;fail to generate learning data frame&quot;;\n      return false;\n    &#125;\n    return true;\n  &#125;\n\n  ADCTrajectory adc_trajectory_pb;\n\n  &#x2F;&#x2F; 执行注册好的planning信息，并且生成线路\n  planning_base_-&gt;RunOnce(local_view_, &amp;adc_trajectory_pb); \n  auto start_time &#x3D; adc_trajectory_pb.header().timestamp_sec();\n  common::util::FillHeader(node_-&gt;Name(), &amp;adc_trajectory_pb);\n\n  &#x2F;&#x2F; modify trajectory relative time due to the timestamp change in header\n  const double dt &#x3D; start_time - adc_trajectory_pb.header().timestamp_sec();\n  for (auto&amp; p : *adc_trajectory_pb.mutable_trajectory_point()) &#123;\n    p.set_relative_time(p.relative_time() + dt);\n  &#125;\n  &#x2F;&#x2F; 发布信息\n  planning_writer_-&gt;Write(adc_trajectory_pb);\n\n  &#x2F;&#x2F; record in history\n  auto* history &#x3D; injector_-&gt;history();\n  history-&gt;Add(adc_trajectory_pb);\n\n  return true;\n&#125;\n\nvoid PlanningComponent::CheckRerouting() &#123;\n  AINFO &lt;&lt; &quot;检查路由函数调用!&quot;;\n  auto* rerouting &#x3D; injector_-&gt;planning_context()\n                        -&gt;mutable_planning_status()\n                        -&gt;mutable_rerouting();\n  if (!rerouting-&gt;need_rerouting()) &#123;\n    return;\n  &#125;\n  common::util::FillHeader(node_-&gt;Name(), rerouting-&gt;mutable_routing_request());\n  rerouting-&gt;set_need_rerouting(false);\n  rerouting_writer_-&gt;Write(rerouting-&gt;routing_request());\n&#125;\n\nbool PlanningComponent::CheckInput() &#123;\n  AINFO &lt;&lt; &quot;检查输入函数调用!&quot;;\n  ADCTrajectory trajectory_pb;\n  auto* not_ready &#x3D; trajectory_pb.mutable_decision()\n                        -&gt;mutable_main_decision()\n                        -&gt;mutable_not_ready();\n\n  if (local_view_.localization_estimate &#x3D;&#x3D; nullptr) &#123;\n    not_ready-&gt;set_reason(&quot;localization not ready&quot;);\n  &#125; else if (local_view_.chassis &#x3D;&#x3D; nullptr) &#123;\n    not_ready-&gt;set_reason(&quot;chassis not ready&quot;);\n  &#125; else if (HDMapUtil::BaseMapPtr() &#x3D;&#x3D; nullptr) &#123;\n    not_ready-&gt;set_reason(&quot;地图没有准备好!&quot;);\n  &#125; else &#123;\n    &#x2F;&#x2F; nothing\n  &#125;\n\n  if (FLAGS_use_navigation_mode) &#123;\n    if (!local_view_.relative_map-&gt;has_header()) &#123;\n      not_ready-&gt;set_reason(&quot;relative map not ready&quot;);\n    &#125;\n  &#125; else &#123;\n    if (!local_view_.routing-&gt;has_header()) &#123;\n      not_ready-&gt;set_reason(&quot;路由没有准备好!&quot;);\n    &#125;\n  &#125;\n\n  if (not_ready-&gt;has_reason()) &#123;\n    AERROR &lt;&lt; not_ready-&gt;reason() &lt;&lt; &quot;; skip the planning cycle.&quot;;\n    common::util::FillHeader(node_-&gt;Name(), &amp;trajectory_pb);\n    planning_writer_-&gt;Write(trajectory_pb);\n    return false;\n  &#125;\n  return true;\n&#125;\n\n&#125;  &#x2F;&#x2F; namespace planning\n&#125;  &#x2F;&#x2F; namespace apoll\n\nInit 函数他主要做三件事\n\n选择规划器\n读取并检查配置文件\n读取并检查输入的数据\n\nProc 函数planning 的 Proc 函数需要接收三个消息分别是,他们也是plannning启动的关键输入\n\nconst std::shared_ptr&lt;prediction::PredictionObstacles&gt; &#x2F;&#x2F; 预测的障碍物信(prediction_obstacles)\nconst std::shared_ptr&lt;canbus::Chassis&gt;&#x2F;&#x2F; 车辆底盘(chassis)信息(车辆的速度，加速度，航向角等信息)\nconst std::shared_ptr&lt;localization::LocalizationEstimate&gt;  &#x2F;&#x2F; 车辆当前位置(localization_estimate)\n\n他的任务就是不断进行规划\n\n检查数据\n生成路线，并将新的路线发布\n\nLog file created at: 2023&#x2F;01&#x2F;11 18:53:45\nRunning on machine: in-dev-docker\nLog line format: [IWEF]mmdd hh:mm:ss.uuuuuu threadid file:line] msg\nI0111 18:53:45.310637 20642 class_loader_utility.h:79] registerclass:PlanningComponent,apollo::cyber::ComponentBase,&#x2F;opt&#x2F;apollo&#x2F;neo&#x2F;packages&#x2F;planning-dev&#x2F;latest&#x2F;lib&#x2F;libplanning_component.so\nI0111 18:53:45.315501 20642 planning_component.cc:43] planning component init 函数调用! &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nI0111 18:53:45.315992 20642 planning_component.cc:52] 选择相应的规划器 默认是OnLanePlanning 模块 \nI0111 18:53:45.316018 20642 planning_component.cc:58] 默认选择的是 : onlaneplanning\nI0111 18:53:45.316021 20642 planning_component.cc:62] 正在加载配置文件\nI0111 18:53:45.318209 20642 planning_component.cc:77] 正在执行planning_base 的初始化 \nI0111 18:53:45.828123 20642 planning_component.cc:81] 获取路由 routing信息\nI0111 18:53:45.828958 20642 planning_component.cc:92] 读取红绿灯信息\nI0111 18:53:45.829712 20642 planning_component.cc:118] 判断是否使用导航模式\nE0111 18:53:45.880179 20647 reference_line_provider.cc:195] Routing is not ready.\nE0111 18:53:45.940057 20648 reference_line_provider.cc:195] Routing is not ready.\n\nI0111 18:53:50.352406 20652 planning_component.cc:149] planning—component Proc 函数调用! &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nI0111 18:53:50.352429 20652 planning_component.cc:239] 检查路由函数调用!\nE0111 18:53:50.352438 20652 pnc_map.cc:267] Route is empty.\nI0111 18:53:50.352522 20652 planning_component.cc:252] 检查输入函数调用!\nE0111 18:53:50.352545 20652 planning_component.cc:279] 路由没有准备好!; skip the planning cycle.\nE0111 18:53:50.352632 20652 planning_component.cc:185] Input check failed\nE0111 18:53:50.400401 20649 reference_line_provider.cc:195] Routing is not ready.\nE0111 18:53:50.450472 20657 reference_line_provider.cc:195] Routing is not ready.\nI0111 18:53:50.451936 20650 planning_component.cc:149] planning—component Proc 函数调用! &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nI0111 18:53:50.451952 20650 planning_component.cc:239] 检查路由函数调用!\nE0111 18:53:50.451958 20650 pnc_map.cc:267] Route is empty.\nI0111 18:53:50.452006 20650 planning_component.cc:252] 检查输入函数调用!\nE0111 18:53:50.452024 20650 planning_component.cc:279] 路由没有准备好!; skip the planning cycle.\nE0111 18:53:50.452095 20650 planning_component.cc:185] Input check failed\nE0111 18:53:50.510488 20644 reference_line_provider.cc:195] Routing is not ready.\nI0111 18:53:50.552870 20645 planning_component.cc:149] planning—component Proc 函数调用! &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n\n总结 ：\n\n通过日志文件我们发现Init 函数只会执行一次，而Proc函数则是在规划期间一直执行的\ninit函数只是起到了初始化的作用\n真正进行规划的Proc函数\n\nc++ 知识点\nstd::unique_ptr 智能指针 -&gt; 独占指针，该指针指向的空间不能共享，只能move，并且生存周期结束会释放对应的内存\nstd::shared_ptr 智能指针 -&gt; 共享指针，该指针指向的空间可以共享，能够计数，并且生存周期结束会释放对应的内存\nfinal 表示该类禁止继承\noverride 表示重写函数\ndefault 表示自动生成的默认构造&#x2F;析构函数\nnamespace 命名空间\nusing  使用命名空间&#x2F;别名\n\n总结\nplanning 模块继承自 Component 类，他需要接收三个模板类型分别是\n\nconst std::shared_ptr&lt;prediction::PredictionObstacles&gt; &#x2F;&#x2F; 预测的障碍物信(prediction_obstacles)\nconst std::shared_ptr&lt;canbus::Chassis&gt;&#x2F;&#x2F; 车辆底盘(chassis)信息(车辆的速度，加速度，航向角等信息)\nconst std::shared_ptr&lt;localization::LocalizationEstimate&gt;  &#x2F;&#x2F; 车辆当前位置(localization_estimate)\n\n\n以上三个数据类型对应了三个protobuf文件里面存储者各种数据 需要的可以去看看\n\n\n\n\n\n\n\n\n\nvscode 安装protobuf 插件既可以舒适的浏览portobuf文件，如果还需要深入了解各种含义可以自行百度\n\n/apollo_workspace/modules/common_msgs/prediction_msgs/prediction_obstacle.proto \n/apollo_workspace/modules/common_msgs/chassis_msgs/chassis.proto\n/apollo_workspace/modules/common_msgs/localization_msgs/localization.proto\n\n\nplanning 默认选择的是OnLanePlanning 规划器，所以后续会以这个为主讲解\n\nplanning 执行所检查的配置文件大多在/apollo_workspace/modules/planning/conf 中可以找到\n\n因为默认选择onlaneplanning 所以以后的planning_base 默认都是指向OnLanePlanning类\nplanning_base_ &#x3D; std::make_unique&lt;OnLanePlanning&gt;(injector_);\n\nvscode 中按抓ctrl + 函数名可以直接跳转\n\n\n","slug":"planning-component","date":"2023-01-11T05:35:05.000Z","categories_index":"apollo-源码分析","tags_index":"apollo","author_index":"yuri2078"},{"id":"aac30bd76fa2c868122ae785358f2450","title":"vscode-apollo","content":"使用vscode 查看apollo源码下载vscode\n\n\n\n\n\n\n\n\n如果使用的wsl请自己百度vscode 链接wsl\n\n官方下载连接\n\n下载下载应该是 code_1.74.2-1671533413_amd64.deb\n\n打开终端输入\ncd Downloads \nsudo dpkg -i code_1.74.2-1671533413_amd64.deb\n\n等安装完成之后直接终端输入code 或者 在桌面打开就行\n\n\n安装插件\n进入vscode后点击这里搜索插件进行安装\n一共需要安装5个插件\nc&#x2F;c++  搜索之后他会自动安装三个插件，等待就行\nC&#x2F;C++ Extension Pack \nC&#x2F;C++ Themes &#x2F;&#x2F;c&#x2F;c++ 自带的主题插件，可以不要\nChinese &#x2F;&#x2F;中文插件，英语好的也可以不要\ndocker \nDev Containers\n\n\n\n进入容器\n安装完成之后进入容器\n\n\n\n\n\n\n\n\n\n如果这里的箭头不是绿色的就先去终端启动一下容器\n\n\n然后他会问你是否进去点击got it 就行\n\n然后他会进入一个新得vscode 等待这里的进度条跑完\n\n进度结束之后，点击这里，然后选择打开一个文件夹，选择&#x2F;apollo_workspace 就行了\n\n\n\n\n\n\n\n\n\n这里目录选择&#x2F;apollo_workspace 就行，选择Planning 会有头文件报错\n\n\n点击插件功能 把刚刚在本地安装的模块再在容器里面安装一遍\n\n\n\n\n\n\n\n\n\n容器内别的可以不要，c&#x2F;c++ 的一定要，不然一堆报错\n\n\n然后就可以阅读源码了，不要不知道的东西，可以直接按住ctrl + 函数名 就行跳转. 并且也有了语法提示\n\n\n\n\n","slug":"vscode-apollo","date":"2023-01-10T12:04:19.000Z","categories_index":"apollo","tags_index":"apollo,vscode","author_index":"yuri2078"},{"id":"a77004d67ce0985b0c015233df92b27d","title":"apollo-8.0安装教程","content":"apollo 8.0 安装教程\n\n\n\n\n\n\n\n\n本文基于官方软件包方式安装教程\n更新系统sudo apt-get update\nsudo apt-get upgrade\n\n安装docker\n\n\n\n\n\n\n\n\n如果提示curl 未知 直接终端输入 sudo apt-get install curl 就行\nwget http:&#x2F;&#x2F;apollo-pkg-beta.bj.bcebos.com&#x2F;docker_install.sh\nbash docker_install.sh\n\ndokcer 更换国内源\n\n\n\n\n\n\n\n\n需要的更换某些情况下国内源会快一点\n\n终端输入sudo vim /etc/docker/daemon.json\n\n按 i 进入插入编辑模式\n\n复制下面的内容粘贴进终端去\n\n\n\n\n\n\n\n\n\n终端粘贴命令是 ctrl + shift + v\n&#123;\n  &quot;registry-mirrors&quot;: [\n    &quot;https:&#x2F;&#x2F;hub-mirror.c.163.com&quot;,\n    &quot;https:&#x2F;&#x2F;ustc-edu-cn.mirror.aliyuncs.com&quot;,\n    &quot;https:&#x2F;&#x2F;ghcr.io&quot;,\n    &quot;https:&#x2F;&#x2F;mirror.baidubce.com&quot;\n  ]\n&#125;\n\n按ESC 退出编辑模式 输入 :wq! 保存并且退出\n\n终端输入 sudo systemctl restart docker 重启docker服务\n\n输入docker info 查看是否换源成功\n\n最后一段输出以下内容就是成功\nInsecure Registries:\n 127.0.0.0&#x2F;8\nRegistry Mirrors:\n https:&#x2F;&#x2F;hub-mirror.c.163.com&#x2F;\n https:&#x2F;&#x2F;ustc-edu-cn.mirror.aliyuncs.com&#x2F;\n https:&#x2F;&#x2F;ghcr.io&#x2F;\n https:&#x2F;&#x2F;mirror.baidubce.com&#x2F;\nLive Restore Enabled: false\n   \n\n安装Apollo 包管理工具\n添加apt 源\nsudo bash -c &quot;echo &#39;deb https:&#x2F;&#x2F;apollo-pkg-beta.cdn.bcebos.com&#x2F;neo&#x2F;beta bionic main&#39; &gt;&gt; &#x2F;etc&#x2F;apt&#x2F;sources.list&quot;\nwget -O - https:&#x2F;&#x2F;apollo-pkg-beta.cdn.bcebos.com&#x2F;neo&#x2F;beta&#x2F;key&#x2F;deb.gpg.key | sudo apt-key add -\nsudo apt update\n\n安装aem 工具\nsudo apt install apollo-neo-env-manager-dev\n\n\n\n输入aem -h 查看是否安装成功\n\n看到以下输出就是成功\nUsage:\n    aem [OPTION]\n\nOptions:\n    start : start a docker container with apollo development image.\n    start_gpu : start a docker container with apollo gpu support development image.\n    enter : enter into the apollo development container.\n    stop : stop all apollo development container.\n    install_core : install the core module of apollo.\n    bootstrap : run dreamview and monitor module.\n    build : build package in workspace.\n    install : install package in workspace.\n    init: init single workspace. \n    update: update core modules of apollo.\n\n安装英伟达驱动\n\n\n\n\n\n\n\n\n如果仅仅学习规划和控制就没必要安装英伟达驱动捏,当然你要想看看有无gpu是否有区别，也可以装\n\n安装英伟达驱动\nsudo apt-get update \nsudo apt-add-repository multiverse \nsudo apt-get update \nsudo apt-get install nvidia-driver-455\n\n安装完了输入nvidia-smi  查看是否安装成功\nSun Jan  8 19:54:14 2023       \n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 525.60.11    Driver Version: 525.60.11    CUDA Version: 12.0     |\n|-------------------------------+----------------------+----------------------+\n| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp  Perf  Pwr:Usage&#x2F;Cap|         Memory-Usage | GPU-Util  Compute M. |\n|                               |                      |               MIG M. |\n|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|\n|   0  NVIDIA GeForce ...  Off  | 00000000:29:00.0  On |                  N&#x2F;A |\n| 33%   36C    P0     2W &#x2F;  38W |    942MiB &#x2F;  2048MiB |      6%      Default |\n|                               |                      |                  N&#x2F;A |\n+-------------------------------+----------------------+----------------------+\n                                                                               \n+-----------------------------------------------------------------------------+\n| Processes:                                                                  |\n|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |\n|        ID   ID                                                   Usage      |\n|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|\n|    0   N&#x2F;A  N&#x2F;A      1057      G   &#x2F;usr&#x2F;lib&#x2F;xorg&#x2F;Xorg                369MiB |\n|    0   N&#x2F;A  N&#x2F;A      1485      G   &#x2F;usr&#x2F;bin&#x2F;kwin_x11                 202MiB |\n|    0   N&#x2F;A  N&#x2F;A      1554      G   &#x2F;usr&#x2F;bin&#x2F;plasmashell               43MiB |\n|    0   N&#x2F;A  N&#x2F;A      1636      G   &#x2F;usr&#x2F;bin&#x2F;latte-dock                19MiB |\n|    0   N&#x2F;A  N&#x2F;A      2618      G   &#x2F;usr&#x2F;bin&#x2F;krunner                    6MiB |\n|    0   N&#x2F;A  N&#x2F;A      2987      G   ...tePerProcess --no-sandbox       75MiB |\n|    0   N&#x2F;A  N&#x2F;A      3189      G   ...127400283826853805,131072      123MiB |\n|    0   N&#x2F;A  N&#x2F;A     41342      G   ...RendererForSitePerProcess       46MiB |\n|    0   N&#x2F;A  N&#x2F;A     49537      G   ...AAAAAAAAA&#x3D; --shared-files       39MiB |\n+-----------------------------------------------------------------------------+\n\n\n安装docker容器 英伟达支持\ndistribution&#x3D;$(. &#x2F;etc&#x2F;os-release;echo $ID$VERSION_ID) \ncurl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;nvidia-docker&#x2F;gpgkey | sudo apt-key add - \ncurl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;nvidia-docker&#x2F;$distribution&#x2F;nvidia-docker.list | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;nvidia-docker.list \nsudo apt-get -y update \nsudo apt-get install -y nvidia-docker2\n\n终端输入 sudo systemctl restart docker   重启docker\n\n\n创建 并进去Apollo 容器\n克隆官方项目\n\n\n\n\n\n\n\n\n\n如果提示git 找不到 就先执行sudo apt-get install git\ngit clone https:&#x2F;&#x2F;github.com&#x2F;ApolloAuto&#x2F;application-demo.git\ncd application-demo\n\n下载docker镜像\n\n\n\n\n\n\n\n\n\n前面没有换源，此处可能会非常慢捏。\naem start\n\n最后终端出现如下就OK\nCopying files from &#96;&#x2F;etc&#x2F;skel&#39; ...\n[ OK ] Congratulations! You have successfully finished setting up Apollo Dev Environment.\n[ OK ] To login into the newly created apollo_neo_dev_yuri container, please run the following command:\n[ OK ]   aem enter\n[ OK ] Enjoy!\n\n\n\n\n输入 aem enter 进入工作空间 安装dreamView 和 planning\n\n\n\n\n\n\n\n\n\n\n\n在安装前需要先进入Apollo 工作空间 \n\n如果需要profile 模块，可以看官方教程 \n\n\n\n\n\n\n\n\n\n看第二个，将场景在本地仿真\n\n安装dreamview \nsudo apt install apollo-neo-dreamview-dev apollo-neo-monitor-dev\n\n\n\n启动dreamview 然后打开8888端口就可以看到了\naem bootstrap start\n\n安装planning 模块 和 预测模块\nbuildtool build --packages planning_customization\nbuildtool install --legacy predition-\n\n如果这里报ERROR 就是之前文件拷贝不全，执行下面的语句就行\ngit clone https:&#x2F;&#x2F;github.com&#x2F;ApolloAuto&#x2F;application-demo.git\nsudo cp -r application-demo&#x2F;* &#x2F;apollo\n\n\n\n之后如果修改了源码，直接重新编译一遍planning模块就行\n\n\n","slug":"apollo-8-0-install","date":"2023-01-08T11:29:44.000Z","categories_index":"apollo","tags_index":"apollo,教程","author_index":"yuri2078"},{"id":"afb3e22159f1b2638a47027d02f4117a","title":"障碍物绕行仿真调试","content":"障碍物绕行仿真调试\n\n\n\n\n\n\n\n\n通过本次实验了解仿真练习\n添加仿真场景\n打开控制台 进行仿真实验免费包申请\n选择 左侧仿真 -&gt;  场景编辑 -&gt; 添加需要的场景\n如果不会 请参考官方教程\n之后在个人场景集 中添加你需要的场景\n\nDreamview 仿真\n\n\n\n\n\n\n\n\n云端实验室启动直接 .&#x2F;scripts&#x2F;bootstrap_neo.sh 就行\n\n sudo systemctl start docker 启动docker服务\ndocker start apollo_dev_用户名 启动apollo容器\nbash docker/scripts/dev_into.sh 在当前终端中进入apollo docker容器\nbash scripts/bootstrap.sh 启动dreamview \n访问 http://localhost:8888 查看dreamview界面\n\n进行障碍物绕行实验\n打开 SIm Control  选项\n\n\n左侧 Profile 模块中下载自己的场景\n\n在模块功能中 打开 预测 规划 路径 这三个模块\n\n在路由中 选择路径 ，之后点击发送路径就行\n\n查看效果\n\n更改conf文件，修改横向超车距离\n\n文件位置/apollo/modules/planning/conf/planning.conf \n\n修改这一行数据为1.5 就可以吧横向超车距离改为1.5 米\n\n\n","slug":"Obstacle-bypass","date":"2023-01-07T10:38:58.000Z","categories_index":"apollo","tags_index":"apollo","author_index":"yuri2078"},{"id":"8fb19d80ddcd0356e241a041c1f55c1c","title":"apollo_github版本配置","content":"\n\n\n\n\n\n\n\n\n\n来源 : apollo 官方 github参考 : apollo profile操作方法\n克隆 apollo 仓库一般建议克隆在home目录就行\ngit clone -b dv_plugin_manager_support  https:&#x2F;&#x2F;github.com&#x2F;ApolloAuto&#x2F;apollo.git\n#如果提示报错就终端输入，或者地址改成ssh链接\ngit config --global http.postBuffer 524288000\n\n\n安装插件\n进入apollo社区 https://apollo.baidu.com/community\n登陆控制台\n点击右上角 进入个人信息\n点击第三个选项 服务权益\n点击第二个仿真\n点击插件安装 然后生成 选择第二个github版本\n复制命令\n终端输入命令 (不是docker容器)\n\n构建apollo\n终端依次输入以下命令\n #cd 进apollo目录\ncd apollo \nrm -rf &#x2F;apollo&#x2F;.cache&#x2F;&#123;bazel,build,repos&#125;\n.&#x2F;apollo.sh config --noninteractive\n\n#我也不知道这两个命令是不是必要的，反正我输入了。\n\n新建容器 ./docker/scripts/dev_start.sh 也可以使用bash docker/scripts/dev_start.sh\n\n进入docker容器 ./docker/scripts/dev_into.sh\n\n在docker容器里面重新输入一遍刚刚生成的插件命令\n\n./apollo.sh build开始构建系统\n\n如果不想全部构建，也可以只构建你想要的东西\n\n如果下载go套件报错,在docker输入以下命令解决\n sudo vim sudo vim &#x2F;etc&#x2F;hosts\n#在底部插入下面所有内容就行。\n#Download 下载\n203.208.41.32 dl.google.com\n203.208.41.32 dl-ssl.google.com\n\n#Groups\n203.208.41.32 groups.google.com\n\n#Google URL Shortener\n203.208.41.32 goo.gl\n\n#Google App Engine\n203.208.41.32 appengine.google.com\n\n\n\n\n\n\n\n\n\n\n\n报错教程参考 ： 解决dl.google报错\n","slug":"apollo-github","date":"2022-10-22T06:48:14.000Z","categories_index":"apollo","tags_index":"apollo,教程","author_index":"yuri2078"},{"id":"58c1bf6ecb41acfadcd68abb30fef1e2","title":"apollo学习路径","content":"apollo 学习路径必要知识点掌握c++ 学习前言： 因为Cyber使用的c++ 封装的api 并且在组件部分就已经没有Python实现了，所以学习c++ 还有有必要的，但是又不用全部学习下去。 后面的stl容器，用的也比较少。 以我目前的学习状况来看， 对模板的使用，只要知道怎么用就行了\n目前为止我们需要掌握基础的东西就行。了解c++ 基本的结构，以及类的相关要求就行\n视频教程0基础我推荐黑马的c++ 教程 老师将的很详细，而且每隔一段时间就有案例。能够很好的总结自己目前阶段学习的成果\n哔哩哔哩 黑马官方教程 ： 黑马c++教程  \n\n\n\n\n\n\n\n\n\n前言： \n划分的时间不是固定的，学的快的可以多练习以下，学的慢的也可以放慢速度。遇到不会的东西都可以来问我。但是需要注意可以慢，但是不能慢太多不然后面的进度你跟不上。\n第一部分： c++ 基础入门  (学习时间 建议 3周 ) \n\n第一周：第一节 -&gt; c++ 初识    - —  第四节 -&gt; 程序流程结构 （前面都比较简单，一周熟悉基本结构）\n第二周：第五节 -&gt; 数组           —– 第六节 -&gt; 函数 （数组和函数是基本的东西，在后续的学习中经常使用）\n第三周：第七节 -&gt; 指针           —– 第八节 -&gt; 结构体 (指针很重要，不用学习的特别花哨，但是需要掌握 )\n总结 ： 三周时间，掌握基础的结构，理解c++ 的基本数据类型 前面也基本都是c语言的内容，有基础学习起来也特别快。 这三周要做的事情是熟练掌握基本结构，能够使用c++ 解决一些基本的问题。\n课程对应 哔哩哔哩视频 1 - 72节\n学习要求： 能够独立完成 视频 73 节的通讯录管理系统项目\n\n第二部分:   c++ 核心编程  （学习时间 建议 5 周 ）\n\n前言：这里是 c++ 的核心编程是非常重要的部分。也是c++ 的核心以及灵魂所在。是必须要重点掌握的地方\n第四周：第一节 -&gt; 内存分区模型 —- 第三节 -&gt; 函数提高 (看着多，其实需要掌握的地方不多)\n第五周 :  第四节 : 4.1 封装  —-  4.2 对象的初始化和清理 （第一周先要熟练掌握对象的基本结构、构造、析构）\n第六周 :  第四节:  4.3 c++对象模型和this指针 —- 4.5 运算符重载 （这里看着多需要掌握的不多更多是理解）\n第七周： 第四节: 4.6 继承 （需要重点掌握，花一周时间好好理解。 不要跟着敲出来就觉得会了。多自己写写）\n第八周 :  第四节 :  4.7多态  （需要重点掌握，花一周时间好好理解。 不要跟着敲出来就觉得会了。多自己写写）\n总结： 这一部分面向对象核心编程，是属于c++ 核心的地方。一定要好好学习。 其中 第四周 更多是了解，不要看到源代码不知道是什么意思。第五周封装 和实例化对象则是以后开发绕不开的东西。 对一个类的基本了解和基本使用是必须要掌握的。 后面第六周的运算符重载不用每个都看。重点掌握怎么重载，以及重载 &lt;&lt; 这种符号时需要传入的是引用。别的大概理解就行。\n对应哔哩哔哩视频的 84 -184节\n学习要求 : 熟练掌握类的 创建 析构 拷贝 继承 多态\n\n总结 ： 总结：这个视频看到 184 节 模板-类模板案例-封装 这一节就行了，后面的stl容器，可以先不用看。中途提到的对于文件的操作也可以选择不看。 学完这两个部分，对于c++ 的基础核心语法，已经算是掌握了。\n书籍教程\nc++ prime plus 中文版第六版 电子版 链接: https://pan.baidu.com/s/1WXc_hfJhJKL4c8InAVXHMg  提取密码: cg2f\n\nGitHub 学习 大佬写的c++ prime plus 原书代码和解答 GitHub 可能需要梯子\n\n\n提前了解： 因为apollo 是构建在docker容器当中，所以需要了解基础的linux命令。 打开Ubuntu 然后按住 Ctrl +  Alt + t\n就能打开终端。 终端就是输入linux命令的地方。后续提到的指令都是在这里面输入。 \n打开终端输入 pwd 查看当前目录 一般是 &#x2F;home&#x2F; {你的用户名} linux是多用户多任务的。 home 目录用来存放各个用户的数据， 每个用户都有自己的目录文件夹，互不干扰。但是他们共享 基本的linux文件 也就是除了home目录以外的东西\n比如 存放可执行文件的bin 目录 &#x2F;usr&#x2F;bin&#x2F; \n熟悉linux 常用&#x2F;基础 的指令常用指令掌握\npwd（英文全拼：print work directory） 命令用于显示工作目录。\n#用法 pwd 就行\n\n&gt; pwd #查看目前所在目录\n&#x2F;home&#x2F;yuri\n\nls  — list directory contents 命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。\n#用法 ls 【目录名】 不加参数则默认当前目录 \n# ls 查看当前目录\n# ls &#x2F;home 查看&#x2F;home 目录\n\n&gt; ls #输入ls 查看当前目录下所有（非隐藏）文件 展示出来的东西就是当前目录下所有东西了\nDesktop    Downloads  Pictures  Templates  apollo  images  myPacket      vimrc\nDocuments  Music      Public    Videos     blog    miku    packettracer  yuri\n\n\ncd  （英文全拼：change directory）命令用于切换当前工作目录。 \n#用法 cd [目录名] cd .. linux中 用 . 表示当前目录 用.. 表示上级目录\n# cd &#x2F;home&#x2F;yuri 进入&#x2F;home&#x2F;yuri目录\n# cd .. 进入上级目录\n\n&gt; pwd #输入pwd查看当前目录 是 &#x2F;home&#x2F;yuri\n&#x2F;home&#x2F;yuri\n\n&gt; ls #输入ls 查看目录下有哪些文件 我们以进入Musi文件为例\nDesktop    Downloads  Pictures  Templates  apollo  images  myPacket      vimrc\nDocuments  Music      Public    Videos     blog    miku    packettracer  yuri\n\n&gt; cd Music #cd music 进入music文件夹       \n\n&gt; pwd #输入 pwd 查看当前是不是在 &#x2F;home&#x2F;yuri 下的 Music 文件夹里\n&#x2F;home&#x2F;yuri&#x2F;Music\n\n\ncp（英文全拼：copy file）命令主要用于复制文件或目录 加上 -rf 复制一整个文件夹\n# 用法 cp  [文件1] [复制新文件的名字] (不加目录默认当前目录) 以下操作仅仅对文件，文件夹需要加参数 -rf\n# cp file file2 复制当前目录下的file文件到当前目录下，并且命名为file2\n# cp file &#x2F;home&#x2F;yuri&#x2F;file2 复制当前目录下的file文件到&#x2F;home&#x2F;yuri目录下，并且命名为file2\n\n&gt; ls            #输入ls查看当前目录下有什么 发现有一个文件 一个文件夹\n\nCloudMusic  神话.flac\n&gt; ls CloudMusic  #查看这个文件夹里有什么？  发现什么都没有     \n          \n&gt; cp 神话.flac CloudMusic  #将当前目录下的神话.flac 复制到 CloudMusic \n             \n&gt; ls CloudMusic  #查看文件夹下面是不是已经有文件了  发现已经有了\n\n神话.flac\n\n# cp -rf [文件夹名字] [新文件夹名字]\n\n&gt; cp -rf CloudMusic CloudMusic_cp #复制cloudmusic 文件夹 并命名成cloudmusic_cp\n\n&gt; ls #\nCloudMusic  CloudMusic_cp  神话.flac\n\n\nmv 和上面 cp 命令使用情况基本一样 在对文件夹使用时 可以不用加 -rf 参数\n\n.&#x2F;  执行可执行文件 输入 .&#x2F;可执行文件名字 即可执行一个可执行文件\n&gt; ls\nhello  hello.cpp \n# 使用g++ 将hello.cpp 编译为一个可执行文件 hello （linux 可执行文件一般没有后缀，不像win 的 .exe）\n\n&gt; .&#x2F;hello    #执行可执行文件      \nhello world\n\nmkdir make directories 的缩写，用于创建新目录\n&gt; ls  #查看文件下文件\nhello  #只有一个hello文件夹\n&gt; mkdir hhh #新建hhh 目录\n&gt;ls\nhello hhh #再次查看发现有了\n\n# 注意： 新建的目录必要存在 比如mkdir hhh&#x2F;test_1&#x2F;test_2 如果中间 test_1 不存在就会报错\n\nmkdir -p hhh&#x2F;test_1&#x2F;test_2 递归创建目录 即使test_1 不存在\n\nclear 清空终端的命令 \n\nsudo 暂时获取root权限命令\n\n待补充\n\n\nbazel 的使用参考 以及后续学习菜鸟教程： linux命令\n正式开始学习​\t\n","slug":"apollo学习路径","date":"2022-10-01T05:37:54.000Z","categories_index":"apollo","tags_index":"apollo","author_index":"yuri2078"},{"id":"9d467d8176371f5545251578b9100d29","title":"cyber RT 开发教程","content":"apollo Cyber c++ 实现\n\n\n\n\n\n\n\n\n前言： 本文是基于赵老师的视频：CyberRT教程 ，文中所有东西都是基于arch + vscode  1.72\n建议： 使用前先去cyber&#x2F;setup.bash 将export GLOG_alsologtostderr&#x3D;0  这句话修改成1，因为后续的所有内容均在终端中输出，需要将这个日志设置改为1\n使用vscode 环境\nvscode 插件\nBazel \nbazel  build工具\nc&#x2F;c++ 必要插件\ndocker 连接docker容器\njupytr\njupytr keymap\nprotobuf \nRemote 远程链接docker插件\nChinese 中文汉化插件\n\n编译第一个hello项目新建文件\n在vscode中打开docker容器 选择 attach visual studio code\n\n在新的vscode中打开容器 选择打开文件夹 选择apollo 目录就行了\n\n在Cyber 文件夹中新建 demo_cpp 文件夹 用来存放以后的cpp代码\n\n新建一个helloworld.cc文件夹\n#include &quot;cyber&#x2F;cyber.h&quot;\n\nint main(int argc, char const *argv[])\n&#123;\n    &#x2F;* code *&#x2F;\n    apollo::cyber::Init(argv[0]);\n    AINFO &lt;&lt; &quot;hello world&quot;;\n    return 0;\n&#125;\n\n\n在个更目录下新建BUILD文件， 输入cc后 自动补全选择cc_binary，删除不要的第三个空的补全，并把具体内容补全\n\n# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_binary\ncc_binary(\n    name &#x3D; &quot;helloworld&quot;, #项目名字\n    srcs &#x3D; [&quot;helloworld.cc&quot;], #项目文件\n    deps &#x3D; [&quot;&#x2F;&#x2F;cyber&quot;], #固定写法\n)\n\n开始构建项目\n终端运行 bazel build cyber/demo_cpp/... 构建项目下所有文件，终端出现以下内容就是成功\n\n修改cyber &#x2F;setup.bash 文件  —- export GLOG_alsologtostderr=1  #把这里改成 1 原来是0 大概35行左右\n\n\n查看bazel-bin&#x2F;cyber&#x2F;文件夹下面是不是有一个demo_cpp文件夹，里面有一个hellowrold文件 直接执行就行了\n\n输入source cyber/setup.bash 命令 令配置立即生效\n\n输入./bazel-bin/cyber/demo_cpp/helloworld 执行程序 终端输出如图就是成功\n\n\nbazel 的基本使用\n在cyber文件夹下新建demo_base_bazel文件夹\n\n在demo_base_bazel文件夹下 新建 pro1_helloworld 文件夹 用来存放项目\n\n在pro1_helloworld文件夹下 新建WORKSPACE文件标识这是一个bazel项目\n\n在pro1_helloworld 新建 demo_pkt 文件夹存放文件\n\n在demo_pkt文件夹下新建 cpp文件 比如简单打印hello bazel\n\n新建BUILD 文件 输入cc 补全\n\n编辑build文件\n # https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_binary\ncc_binary(\n    name &#x3D; &quot;hello&quot;,\n    srcs &#x3D; [&quot;hello.cc&quot;],\n)\n\n文件基本目录\n\n新建终端 cd 进 pro1_helloworld 工程目录就行\n\n输入 bazel build demo_pkt/...然后编译成功会生成一些文件夹\n\n\n\n\n\n然后进入bazel-bin&#x2F;demo_pkt&#x2F;目录运行 hello就行了\n\n\nbazel 其余编译方法补全\nbazel run demo_pkt:hello编译并运行 build文件中hello项目\nbazel build demo_pkt:hello只编译 hello\n建立WORKSPACE文件的目录为工程根目录\n\nbazel 实现库依赖实现库的同包依赖新建demo_lib 文件夹然后新建WORKSPACE 表明根目录 并在里面新建 lib_hello 文件夹，所有文件都在下面\n编写头文件get_name.h\n#ifndef GET_NAME\n#define GET_NAME\n\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nstd::string get_name(const std::string &amp;name);\n\n#endif\n\n编写具体实现#include &quot;get_name.h&quot;\n\nstd::string get_name(const std::string &amp;name)&#123;\n   return &quot;hello &quot; + name;\n&#125;\n\n新建BUILD文件可以 输入cc 补全 libnary\n# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_library\ncc_library(\n    name &#x3D; &quot;getName&quot;, #\n    srcs &#x3D; [&quot;get_name.cc&quot;], #具体实现文件\n    hdrs &#x3D; [&quot;get_name.h&quot;], #头文件\n)\n\n开始构建cd 进lib_hello 文件夹输入bazel build ... 编译库文件\n新建helloworld源代码\n#include &quot;get_name.h&quot;\n\nint main(int argc, char const *argv[])\n&#123;\n    std::cout &lt;&lt; get_name(&quot;yuri is yes!&quot;) &lt;&lt; std::endl;\n    return 0;\n&#125;\n\n更改build文件\n# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_library\ncc_library(\n    name &#x3D; &quot;get_name_lib&quot;,\n    srcs &#x3D; [&quot;get_name.cc&quot;],\n    hdrs &#x3D; [&quot;get_name.h&quot;],\n)\n\n\n# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_binary\ncc_binary(\n    name &#x3D; &quot;hello_world&quot;, #编译的可执行文件名称\n    srcs &#x3D; [&quot;helloWorld.cc&quot;], #需要执行的文件\n    deps &#x3D; [&quot;:get_name_lib&quot;], #需要添加的头文件\n)\n\n\n\n输入 bazel run :hello_world 看到输出就是成功\n实现库的跨包依赖更目录新建文件夹 用来存放别的文件\n新建hello.cc文件#include &quot;lib_hello&#x2F;get_name.h&quot; &#x2F;&#x2F;必须包含lib目录下的头文件，不能直接包含.h\n\nint main(int argc, char const *argv[])\n&#123;\n    std::cout &lt;&lt; get_name(&quot;yuri is very yes!&quot;) &lt;&lt; std::endl;\n    return 0;\n&#125;\n\n\n\n\n新建build文件# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_binary\ncc_binary(\n    name &#x3D; &quot;hello&quot;,\n    srcs &#x3D; [&quot;hello.cc&quot;],\n    deps &#x3D; [&quot;&#x2F;&#x2F;lib_hello:get_name_lib&quot;], #添加lib_hello文件夹下面build文件夹中的get_name_lib 文件\n)\n\n\n\n实现不同包的引用\n被调用的包的build文件添加生声明package(default_visibility = [&quot;//visibility:public&quot;])\n表明这个包被所有的包共享\n\n在被调用的包里添加指定调用包*visibility* = [&quot;//other_lib:__pkg__&quot;]  指定根目录下的文件夹\n\n\n文件基本目录结构\n构建cd 进 目录进行build就行了\nprotobuf 的基本使用方式使用protobuf进行c++ 开发\nprotocol buffers （ProtoBuf）是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。\nProtocol Buffers 是一种灵活，高效，自动化机制的结构数据序列化方法－可类比 XML，但是比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单。\njson\\xml都是基于文本格式，protobuf是二进制格式。\n编写proto并且编译编写proto 文件新建demo_protobuf 文件夹\n在文件夹里面新建student.proto 文件\n&#x2F;&#x2F;proto文件主要由三部分组成\n\n&#x2F;&#x2F;第一部分 proto 的版本号\nsyntax &#x3D; &quot;proto2&quot;;\n\n&#x2F;&#x2F;声明包\n\npackage apollo.cyber.demo_protobuf;\n\n&#x2F;&#x2F;声明消息\n&#x2F;&#x2F;使用关键字message 就当class使用就行\n&#x2F;&#x2F;数据分为 字段规则 数据类型 名字 编号\n\nmessage Student &#123;\n\n    required string name &#x3D; 1; &#x2F;&#x2F;required -- 必须要的参数\n    optional int64 age &#x3D; 2; &#x2F;&#x2F;optional -- 可以省略的参数\n    optional double height &#x3D; 3; \n    repeated string books &#x3D; 4; &#x2F;&#x2F;repeated -- 可以输入多个数据\n&#125;\n\n编写build文件package(default_visibility &#x3D; [&quot;&#x2F;&#x2F;visibility:public&quot;]) #使这个包的文件共享\n\n#把proto文档生成为lib文件\nproto_library(\n    name &#x3D; &quot;student_proto&quot;,\n    srcs &#x3D; [&quot;student.proto&quot;],\n)\n\n#把已经有了的proto 文档编译成cc文档\ncc_proto_library(\n    name &#x3D; &quot;student_cc&quot;,\n    deps &#x3D; [&quot;:student_proto&quot;],\n)\n\n编译输入bazel build cyber&#x2F;demo_protobuf&#x2F;…既可以编译了\n然后就可以看到cc文件了\n用c++ 使用刚刚编译的proto文件main.cc 源代码#include &quot;cyber&#x2F;demo_protobuf&#x2F;test_01&#x2F;student.pb.h&quot;\n\nint main(int argc, char const *argv[])\n&#123;\n    apollo::cyber::demo_protobuf::Student stu; &#x2F;&#x2F;声明新的对象\n\n    &#x2F;&#x2F;添加新的数据\n    stu.set_name(&quot;yuri&quot;); \n    stu.set_age(18);\n    stu.set_height(166);\n    stu.add_books(&quot;终将成为你，安达与岛村&quot;);\n\n    &#x2F;&#x2F;打印数据\n\n    std::cout &lt;&lt; &quot;打印数据 ------- \\n&quot;;\n    std::cout &lt;&lt; &quot;name : &quot; &lt;&lt; stu.name() &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;age : &quot; &lt;&lt; stu.age() &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;height : &quot; &lt;&lt; stu.height() &lt;&lt; std::endl;\n    auto books &#x3D; stu.books();\n    for(auto begin &#x3D; books.begin(); begin !&#x3D; books.end();begin++)&#123;\n        std::cout &lt;&lt; &quot; &quot; &lt;&lt; *begin;\n    &#125;\n    std::cout &lt;&lt; &quot;\\n输出结束\\n&quot;;\n    return 0;\n&#125;\n\n\nbuild 文件package(default_visibility &#x3D; [&quot;&#x2F;&#x2F;visibility:public&quot;]) #使这个包的文件共享\n\n#把proto文档生成为lib文件\nproto_library(\n    name &#x3D; &quot;student_proto&quot;,\n    srcs &#x3D; [&quot;student.proto&quot;],\n)\n\n#把已经有了的proto 文档编译成cc文档\ncc_proto_library(\n    name &#x3D; &quot;student_cc&quot;,\n    deps &#x3D; [&quot;:student_proto&quot;],\n)\n\n\ncc_binary(\n    name &#x3D; &quot;main&quot;,\n    srcs &#x3D; [&quot;main.cpp&quot;],\n    deps &#x3D; [&quot;:student_cc&quot;],\n)\n\n构建执行输入bazel build … 编译即可，然后执行就行\n\ncyber RT 通信机制c&#x2F;c++实现\n话题通信\n\n\n\n\n\n\n\n\n话题通信的目的是实现数据的传输。 一方发布数据，然后一方接受数据。二者是同时进行的。并且是一直进行通信的\n实现过程： 发布方发布数据，接收方接收数据\n编写proto 文件（信息载体）也可以用之前的文件\nsyntax &#x3D; &quot;proto2&quot;;\npackage apollo.cyber.demo_protobuf;\n\nmessage Student &#123;\n\n    required string name &#x3D; 1; &#x2F;&#x2F;required -- 必须要的参数\n    optional int64 age &#x3D; 2; &#x2F;&#x2F;optional -- 可以省略的参数\n    optional double height &#x3D; 3; \n    repeated string books &#x3D; 4; &#x2F;&#x2F;repeated -- 可以输入多个数据\n&#125;\n\n编写talker.cc 文件（发布方）#include &quot;cyber&#x2F;cyber.h&quot;\n#include &quot;cyber&#x2F;demo_protobuf&#x2F;test_01&#x2F;student.pb.h&quot;\n\nusing apollo::cyber::demo_protobuf::Student;\nusing namespace apollo;\nint main(int argc, char const *argv[])\n&#123;\n    \n    apollo::cyber::Init(argv[0]);\n    \n    auto talker_node &#x3D; cyber::CreateNode(&quot;ergou&quot;); &#x2F;&#x2F;创建节点 名称为ergou\n    auto talker &#x3D; talker_node-&gt;CreateWriter&lt;Student&gt;(&quot;chatter&quot;); &#x2F;&#x2F;创建监听者， 名称为chatter\n\n    uint64_t sq &#x3D; 0; &#x2F;&#x2F;设置计数器\n\n    cyber::Rate rate(0.5); &#x2F;&#x2F;设置发送频率是每秒0.5次\n\n    while(cyber::OK())\n    &#123;\n        sq++;\n        AINFO &lt;&lt; &quot;发送第 &quot; &lt;&lt; sq &lt;&lt; &quot; 条数据\\n&quot;; &#x2F;&#x2F;提示发送数据\n\n        &#x2F;&#x2F;写入数据\n        auto stu &#x3D; std::make_shared&lt;Student&gt;();\n        stu-&gt;set_name(&quot;yuri&quot;);\n        stu-&gt;set_age(sq);\n        stu-&gt;set_height(170);\n        stu-&gt;add_books(&quot;终将成为你!&quot;);\n        stu-&gt;add_books(&quot;安达与岛村!&quot;);\n\n        talker-&gt;Write(stu); &#x2F;&#x2F;写入数据\n\n        rate.Sleep(); &#x2F;&#x2F;调用睡眠函数\n    &#125;\n\n    cyber::WaitForShutdown(); &#x2F;&#x2F;设置结束后删除节点\n\n    return 0;\n&#125;\n\n\n编写listener.cc 文件 （接收方）#include &quot;cyber&#x2F;demo_protobuf&#x2F;test_01&#x2F;student.pb.h&quot;\n#include &quot;cyber&#x2F;cyber.h&quot;\n\nusing apollo::cyber::demo_protobuf::Student;\n\nvoid cp(const std::shared_ptr&lt;Student&gt; &amp;stu)\n&#123;\n    AINFO &lt;&lt; &quot;----- 接收到数据 开始打印数据 -----&quot;;\n    AINFO &lt;&lt; &quot;name : &quot; &lt;&lt; stu-&gt;name();\n    AINFO &lt;&lt; &quot;age : &quot; &lt;&lt; stu-&gt;age();\n    for (auto begin &#x3D; stu-&gt;books().begin(); begin !&#x3D; stu-&gt;books().end();begin++)&#123;\n      AINFO &lt;&lt; &quot;books : &quot; &lt;&lt; *begin;\n    &#125;\n&#125;\n\nint main(int argc, char const *argv[])\n&#123;\n    apollo::cyber::Init(argv[0]);\n\n    AINFO &lt;&lt; &quot;订阅方法创建&quot;;\n\n    auto listener_node &#x3D; apollo::cyber::CreateNode(&quot;curhui&quot;); &#x2F;&#x2F;创建监听节点\n    auto listener &#x3D; listener_node-&gt;CreateReader&lt;Student&gt;(&quot;chatter&quot;, cp); &#x2F;&#x2F;接受到数据会调用cp函数，这里的名字需要和talker对应\n\n    apollo::cyber::WaitForShutdown(); &#x2F;&#x2F;等待程序结束删除节点\n\n    return 0;\n&#125;\n\n配置build文件# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_binary\ncc_binary(\n    name &#x3D; &quot;talker&quot;, #项目名字\n    srcs &#x3D; [&quot;talker.cc&quot;], #项目文件\n    deps &#x3D; [\n        &quot;&#x2F;&#x2F;cyber&quot;,\n        &quot;&#x2F;&#x2F;cyber&#x2F;demo_protobuf&#x2F;test_01:student_cc&quot;\n    ], #固定写法\n)\n\n# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_binary\ncc_binary(\n    name &#x3D; &quot;listener&quot;,\n    srcs &#x3D; [&quot;listener.cc&quot;],\n    deps &#x3D; [\n        &quot;&#x2F;&#x2F;cyber&quot;,\n        &quot;&#x2F;&#x2F;cyber&#x2F;demo_protobuf&#x2F;test_01:student_cc&quot;\n    ], \n)\n\n运行分开终端分别运行talker和listener程序\n服务通信\n\n\n\n\n\n\n\n\n服务通信不同与话题通信他是不是一直进行的。他是当有数据传输的时候进行通信。没有的时候就没有，但是当有数据进入的时候需要立马响应。可以理解为 更换目的地之后，你需要立马处理新的数据。\n编写proto文件需要两个message 一个用来接收，一个用来发送\nsyntax &#x3D; &quot;proto2&quot;;\n\npackage apollo.cyber.demo_cpp;\n\n&#x2F;&#x2F;用来发送数据，需要提供连个参数，用来相加\nmessage Request &#123;\n    required int32 num_1 &#x3D; 1;\n    required int32 num_2 &#x3D; 2;\n&#125;\n\n&#x2F;&#x2F;接收数据，只用一个参数，用来存储他们的和就行了\nmessage Response &#123;\n    required int64 sum &#x3D; 1;\n&#125;\n\n\n\n编写server.cc文件 （服务端） 用来处理数据\n#include &quot;cyber&#x2F;cyber.h&quot;\n#include &quot;cyber&#x2F;demo_cpp&#x2F;reques&#x2F;request.pb.h&quot;\n\nusing apollo::cyber::demo_cpp::Request;\nusing apollo::cyber::demo_cpp::Response;\n\nvoid cp(const std::shared_ptr&lt;Request&gt; &amp;request, const std::shared_ptr&lt;Response&gt; &amp;response)\n&#123;\n    &#x2F;&#x2F;设置数据\n    int32_t num_1 &#x3D; request-&gt;num_1();\n    int32_t num_2 &#x3D; request-&gt;num_2();\n\n    AINFO &lt;&lt; &quot;客户端请求的数据是 : num_1 &quot; &lt;&lt; num_1 &lt;&lt; &quot; num_2 &quot; &lt;&lt; num_2;\n    \n    &#x2F;&#x2F;设置需要传送出去的参数\n    response-&gt;set_sum(num_1 + num_2); &#x2F;&#x2F;设置sum的数数据\n&#125;\n\nint main(int argc, char const *argv[])\n&#123;\n  apollo::cyber::Init(argv[0]);\n\n  AINFO &lt;&lt; &quot;服务端程序启动&quot;;\n\n  auto server_node &#x3D; apollo::cyber::CreateNode(&quot;addints&quot;);\n  auto server &#x3D; server_node-&gt;CreateService&lt;Request, Response&gt;(&quot;addints&quot;,cp); &#x2F;&#x2F;设置接收到数据时的处理函数\n\n  apollo::cyber::WaitForShutdown();\n\n  return 0;\n&#125;\n\n\n编写client.cc 文件（客户端）用来发送数据\n#include &quot;cyber&#x2F;cyber.h&quot;\n#include &quot;cyber&#x2F;demo_cpp&#x2F;reques&#x2F;request.pb.h&quot;\n\nusing apollo::cyber::demo_cpp::Request;\nusing apollo::cyber::demo_cpp::Response;\n\nint main(int argc, char const *argv[])\n&#123;\n    apollo::cyber::Init(argv[0]);\n    AINFO &lt;&lt; &quot;客户端启动捏&quot;;\n\n    auto client_node &#x3D; apollo::cyber::CreateNode(&quot;client&quot;); &#x2F;&#x2F;建立通信节点\n    auto client &#x3D; client_n新建demo_protobuf 文件夹\n\n在文件夹里面新建student.proto 文件ode-&gt;CreateClient&lt;Request,Response&gt;(&quot;addints&quot;); &#x2F;&#x2F;设置客户机\n\n    &#x2F;&#x2F;防止出现没有参数的情况\n    if(argc !&#x3D; 3)\n    &#123;\n        AINFO &lt;&lt; &quot;请输入三个参数&quot;;\n        return 1;\n    &#125;\n\n    &#x2F;&#x2F;新建接收数据对象\n    auto request &#x3D; std::make_shared&lt;Request&gt;();\n    request-&gt;set_num_1(atoll(argv[1]));\n    request-&gt;set_num_2(atoll(argv[2]));\n\n    AINFO &lt;&lt; &quot;发送数据 num_1 &quot; &lt;&lt; request-&gt;num_1() &lt;&lt; &quot; num_2 &quot;\n            &lt;&lt; request-&gt;num_2();\n            \n    auto response &#x3D; client-&gt;SendRequest(request); &#x2F;&#x2F;发送数据，并且把返回的数据赋值给response\n    AINFO &lt;&lt; &quot;处理结果为 : &quot; &lt;&lt; response-&gt;sum(); &#x2F;&#x2F;打印数据\n\n    apollo::cyber::WaitForShutdown();\n\n    return 0;\n&#125;\n\n\n\n编写build 文件package(default_visibility &#x3D; [&quot;&#x2F;&#x2F;visibility:public&quot;])\n\n# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_library\nproto_library(\n    name &#x3D; &quot;request_proto&quot;,\n    srcs &#x3D; [&quot;request.proto&quot;],\n)\n\n# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_library\ncc_proto_library(\n    name &#x3D; &quot;request_cc&quot;,\n    deps &#x3D; [&quot;:request_proto&quot;],\n)\n\n# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_binary\ncc_binary(\n    name &#x3D; &quot;server&quot;,\n    srcs &#x3D; [&quot;server.cc&quot;],\n    deps &#x3D; [\n        &quot;&#x2F;&#x2F;cyber&quot;,\n        &quot;&#x2F;&#x2F;cyber&#x2F;demo_cpp&#x2F;reques:request_cc&quot;\n    ],\n)\n\ncc_binary(\n    name &#x3D; &quot;client&quot;,\n    srcs &#x3D; [&quot;client.cc&quot;],\n    deps &#x3D; [\n        &quot;&#x2F;&#x2F;cyber&quot;,\n        &quot;&#x2F;&#x2F;cyber&#x2F;demo_cpp&#x2F;reques:request_cc&quot;\n    ],\n)\n\n运行携带参数运行数据\n参数用于共享一些数据，比如车身的最大速度， 长度宽度之类的。最大的特点 ：  共享\n编写server端 （服务端）#include &quot;cyber&#x2F;cyber.h&quot;\n#include &quot;cyber&#x2F;parameter&#x2F;parameter.h&quot;\n#include &quot;cyber&#x2F;parameter&#x2F;parameter_server.h&quot;\n\nusing apollo::cyber::ParameterServer;\nusing apollo::cyber::Parameter;\n\nint main(int argc, char const *argv[])\n&#123;\n    apollo::cyber::Init(argv[0]);\n    AINFO &lt;&lt; &quot;服务端启动\\n&quot;;\n\n    std::shared_ptr&lt;apollo::cyber::Node&gt; server_node &#x3D; apollo::cyber::CreateNode(&quot;param&quot;); &#x2F;&#x2F;创建节点\n    std::shared_ptr&lt;ParameterServer&gt; server &#x3D; std::make_shared&lt;ParameterServer&gt;(server_node); &#x2F;&#x2F;创建话题\n\n    &#x2F;&#x2F;设置参数\n    server-&gt;SetParameter(Parameter(&quot;age&quot;, 18));\n    server-&gt;SetParameter(Parameter(&quot;yuri&quot;, &quot;yes&quot;));\n\t\n    &#x2F;&#x2F;打印参数\n    Parameter *parame_1 &#x3D; new Parameter;\n    server-&gt;GetParameter(&quot;age&quot;, parame_1);\n    AINFO &lt;&lt; parame_1-&gt;Name() &lt;&lt; &quot; age is &quot; &lt;&lt; parame_1-&gt;AsInt64() &lt;&lt; std::endl;\n    server-&gt;GetParameter(&quot;yuri&quot;, parame_1);\n    AINFO &lt;&lt; parame_1-&gt;Name() &lt;&lt; &quot; yuri is &quot; &lt;&lt; parame_1-&gt;AsString() &lt;&lt; std::endl;\n\n    AINFO &lt;&lt; &quot;获取所有参数 ----- \\n&quot;;\n    std::vector&lt;Parameter&gt; parameter;\n    server-&gt;ListParameters(&amp;parameter);\n    for (auto begin &#x3D; parameter.begin(); begin !&#x3D; parameter.end();begin++)\n    &#123;\n        AINFO &lt;&lt; &quot;打印 name :&quot; &lt;&lt; begin-&gt;Name() &lt;&lt; &quot;type name : &quot; &lt;&lt; begin-&gt;TypeName() &lt;&lt; std::endl;\n        AINFO &lt;&lt; &quot;打印所有参数 &quot; &lt;&lt; begin-&gt;DebugString(); &#x2F;&#x2F;以字符串形式打印所有参数\n    &#125;\n\n    apollo::cyber::WaitForShutdown();\n    delete parame_1;\n    return 0;\n&#125;\n\n\n编写 client端 （客户端）#include &quot;cyber&#x2F;cyber.h&quot;\n#include &quot;cyber&#x2F;parameter&#x2F;parameter.h&quot;\n#include &quot;cyber&#x2F;parameter&#x2F;parameter_client.h&quot;\n\nusing apollo::cyber::ParameterClient;\nusing apollo::cyber::Parameter;\n\nint main(int argc, char const *argv[])\n&#123;\n    apollo::cyber::Init(argv[0]);\n    AINFO &lt;&lt; &quot;服务方式启动\\n&quot;;\n\n    std::shared_ptr&lt;apollo::cyber::Node&gt; client_node &#x3D; apollo::cyber::CreateNode(&quot;param_client&quot;); &#x2F;&#x2F;创建节点\n    std::shared_ptr&lt;ParameterClient&gt; client &#x3D; std::make_shared&lt;ParameterClient&gt;(client_node,&quot;param&quot;); &#x2F;&#x2F;创建话题\n\n\n    Parameter *parame_1 &#x3D; new Parameter;\n    client-&gt;GetParameter(&quot;age&quot;, parame_1); &#x2F;&#x2F;添加数据\n    AINFO &lt;&lt; parame_1-&gt;Name() &lt;&lt; &quot; age is &quot; &lt;&lt; parame_1-&gt;AsInt64() &lt;&lt; std::endl; &#x2F;&#x2F;打印数据\n    client-&gt;GetParameter(&quot;yuri&quot;, parame_1);\n    AINFO &lt;&lt; parame_1-&gt;Name() &lt;&lt; &quot; yuri is &quot; &lt;&lt; parame_1-&gt;AsString() &lt;&lt; std::endl;\n\n    AINFO &lt;&lt; &quot;获取所有参数 ----- \\n&quot;;\n    std::vector&lt;Parameter&gt; parameter;\n    client-&gt;ListParameters(&amp;parameter);\n    for (auto begin &#x3D; parameter.begin(); begin !&#x3D; parameter.end();begin++)\n    &#123;\n      AINFO &lt;&lt; &quot;打印 name :&quot; &lt;&lt; begin-&gt;Name()\n            &lt;&lt; &quot;type name : &quot; &lt;&lt; begin-&gt;TypeName() &lt;&lt; std::endl;\n    &#125;\n\n    apollo::cyber::WaitForShutdown();\n    delete parame_1;\n    return 0;\n&#125;\n\nbuild 文件# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_binary\ncc_binary(\n    name &#x3D; &quot;para_server&quot;,\n    srcs &#x3D; [&quot;para_server.cc&quot;],\n    deps &#x3D; [\n        &quot;&#x2F;&#x2F;cyber&quot;,\n        &quot;&#x2F;&#x2F;cyber&#x2F;parameter&quot;\n    ],\n)\n\ncc_binary(\n    name &#x3D; &quot;para_client&quot;,\n    srcs &#x3D; [&quot;para_client.cc&quot;],\n    deps &#x3D; [\n        &quot;&#x2F;&#x2F;cyber&quot;,\n        &quot;&#x2F;&#x2F;cyber&#x2F;parameter&quot;\n    ],\n)\n\n运行组件( 一 )\n\n\n\n\n\n\n\n\n组件是apollo 非常重要的一部分，他可以处理来自不同部件发送的数据。然后重新整合 发送\n简单来说就是 处理接收的数据，然后进行过滤 计算，然后重新发送出去\n\n编写components 类，继承components \n重写Proc 和 init 函数\n编写dag和lunach 文件\n编写build 文件\n他最多支持 4 消息通道\n\nproto文件编写syntax &#x3D; &quot;proto2&quot;;\n\npackage apollo.cyber.demo_cpp;\n\nmessage Student &#123;\n    required string name &#x3D; 1;\n    required int64 age &#x3D; 2;\n    repeated string loves &#x3D; 3;\n&#125;\n\n编写talker文件（发布方）#include &quot;cyber&#x2F;cyber.h&quot;\n#include &quot;cyber&#x2F;demo_cpp&#x2F;components&#x2F;Student.pb.h&quot;\n\nusing apollo::cyber::demo_cpp::Student;\nusing namespace apollo;\nint main(int argc, char const *argv[])\n&#123;\n    \n    apollo::cyber::Init(argv[0]);\n    \n    auto talker_node &#x3D; cyber::CreateNode(&quot;ergou&quot;); &#x2F;&#x2F;创建节点 名称为ergou\n    auto talker &#x3D; talker_node-&gt;CreateWriter&lt;Student&gt;(&quot;chatter&quot;); &#x2F;&#x2F;创建监听者， 名称为chatter\n\n    uint64_t sq &#x3D; 0; &#x2F;&#x2F;设置计数器\n\n    cyber::Rate rate(0.5); &#x2F;&#x2F;设置发送频率是每秒0.5次\n\n    while(cyber::OK())\n    &#123;\n        sq++;\n        AINFO &lt;&lt; &quot;发送第 &quot; &lt;&lt; sq &lt;&lt; &quot; 条数据\\n&quot;; &#x2F;&#x2F;提示发送数据\n\n        &#x2F;&#x2F;写入数据\n        auto stu &#x3D; std::make_shared&lt;Student&gt;();\n        stu-&gt;set_name(&quot;yuri&quot;);\n        stu-&gt;set_age(sq);\n        stu-&gt;add_loves(&quot;终将成为你&quot;);\n        stu-&gt;add_loves(&quot;安达与岛村&quot;);\n\n\n        talker-&gt;Write(stu); &#x2F;&#x2F;写入数据\n\n        rate.Sleep(); &#x2F;&#x2F;调用睡眠函数\n    &#125;\n\n    cyber::WaitForShutdown(); &#x2F;&#x2F;设置结束后删除节点\n\n    return 0;\n&#125;\n\n\n\n\n类头文件编写#ifndef MY_COMPONENTS\n#define MY_COMPONENTS\n\n#include &quot;cyber&#x2F;cyber.h&quot;\n#include &quot;cyber&#x2F;component&#x2F;component.h&quot;\n#include &quot;cyber&#x2F;demo_cpp&#x2F;components&#x2F;Student.pb.h&quot;\n\nusing apollo::cyber::Component;\nusing apollo::cyber::demo_cpp::Student;\n\n&#x2F;&#x2F;继承需要添加数据模板\nclass my_components : public Component&lt;Student&gt; \n&#123;\nprivate:\n    &#x2F;* data *&#x2F;\npublic:\n\n    bool Init() override; &#x2F;&#x2F;表示重写函数，初始化函数\n    bool Proc(const std::shared_ptr&lt;Student&gt; &amp;stu) override; &#x2F;&#x2F;数据数据函数\n    \n&#125;;\n\nCYBER_REGISTER_COMPONENT(my_components) &#x2F;&#x2F;注册组件\n#endif\n\ncpp函数编写#include &quot;my_components.h&quot;\n\nbool my_components::Init() &#123;\n\tAINFO &lt;&lt; &quot;------------ 初始化中 ------------&quot;;\n\treturn true;\n&#125;\n\nbool my_components::Proc(const std::shared_ptr&lt;Student&gt;&amp; stu)\n&#123;\n\tAINFO &lt;&lt; &quot;数据输出!&quot;;\n\tAINFO &lt;&lt; &quot;name : &quot; &lt;&lt; stu-&gt;name();\n\tAINFO &lt;&lt; &quot;age : &quot; &lt;&lt; stu-&gt;age();\n\tfor (auto begin &#x3D; stu-&gt;loves().begin(); begin !&#x3D; stu-&gt;loves().end(); begin++) &#123;\n\t\tAINFO &lt;&lt; &quot;loves &quot; &lt;&lt; *begin;\n\t&#125;\n\treturn true;\n&#125;\n\n\nlaunch 文件编写&lt;cyber&gt; \n    &lt;module&gt;\n        &lt;name&gt; my moudle&lt;&#x2F;name&gt; &lt;!--模块名字--&gt;\n        &lt;dag_conf&gt;&#x2F;apollo&#x2F;cyber&#x2F;demo_cpp&#x2F;components&#x2F;cpt.dag&lt;&#x2F;dag_conf&gt; &lt;!-- dag 目录位置--&gt;\n        &lt;process_name&gt; my_cpt &lt;&#x2F;process_name&gt;\n    &lt;&#x2F;module&gt;\n&lt;&#x2F;cyber&gt;\n\ndag 文件编写module_config &#123;\n\n    module_library : &quot;&#x2F;apollo&#x2F;bazel-bin&#x2F;cyber&#x2F;demo_cpp&#x2F;components&#x2F;my_components.so&quot;\n\n    components &#123;\n\n        class_name : &quot;my_components&quot;\n\n        config &#123;\n            name : &quot;my_components&quot;\n            readers &#123;\n                channel : &quot;chatter&quot; \n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nbuild 文件编写\nload(&quot;&#x2F;&#x2F;tools&#x2F;install:install.bzl&quot;,&quot;install&quot;)\n\n# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_library\nproto_library(\n    name &#x3D; &quot;Student_proto&quot;,\n    srcs &#x3D; [&quot;Student.proto&quot;],\n)\n\n# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_library\ncc_proto_library(\n    name &#x3D; &quot;Student_proto_cc&quot;,\n    deps &#x3D; [&quot;:Student_proto&quot;],\n)\n\n# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_library\ncc_library(\n    name &#x3D; &quot;my_components_lib&quot;,\n    srcs &#x3D; [&quot;my_components.cc&quot;],\n    hdrs &#x3D; [&quot;my_components.h&quot;],\n    deps &#x3D; [\n        &quot;&#x2F;&#x2F;cyber&quot;,\n        &quot;&#x2F;&#x2F;cyber&#x2F;component&quot;,\n        &quot;&#x2F;&#x2F;cyber&#x2F;demo_cpp&#x2F;components:Student_proto_cc&quot;\n    ],\n)\n\n# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_binary\ncc_binary(\n    name &#x3D; &quot;my_components.so&quot;,\n    linkshared &#x3D; True, \n    linkstatic &#x3D; False,\n    deps &#x3D; [&quot;:my_components_lib&quot;],\n)\n\n# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_binary\ncc_binary(\n    name &#x3D; &quot;talker&quot;,\n    srcs &#x3D; [&quot;talker.cc&quot;],\n    deps &#x3D; [\n        &quot;&#x2F;&#x2F;cyber&quot;,\n        &quot;:Student_proto_cc&quot;\n    ],\n)\n\nfilegroup(\n    name &#x3D; &quot;conf&quot;,\n    srcs &#x3D; [\n        &quot;:cpt.dag&quot;,\n        &quot;:cpt.launch&quot;,\n    ],\n)\n\ninstall (\n    name &#x3D; &quot;install&quot;,\n    data &#x3D; [\n        &quot;:conf&quot;,\n    ],\n\n    runtime_dest &#x3D; &quot;cyber&#x2F;demo_cpp&#x2F;components&quot;,\n    targets &#x3D; [\n        &quot;:talker&quot;,\n        &quot;:my_components.so&quot;,\n    ],\n)\n\n\n\n运行\n使用  mainboard -d cyber/demo_cpp/components/cpt.dag 运行 dag文件\n使用 cyber_launch start cyber/demo_cpp/components/cpt.launch 运行 launch 文件\n上面随便选一种方式运行就行，然后运行talker 文件就行了。 打开终端就可以看到效果了\n如果使用cyber_launch start运行，除了Ctrl c 还可以使用 cyber_launch  stop 命令结合\n\n\n组件 （二）\n\n\n\n\n\n\n\n\n本次需要实现 两个数据的检测，所以需要两个数据发布方\n这次需要接受双通道的消息，所以需要同步更改dag文件\n到这里，信息就不止一个了，不同的信息有不同的发送频率。比如，talker 1 每两秒发送一次数据，talker 2每 1秒发送一次数据，这里组件会以频率较慢的一个为基础，并且同时获取发送过来的频率较快的那个的数据，并且舍弃掉之前的数据。\n**编写 proto文件 **syntax &#x3D; &quot;proto2&quot;;\n\npackage apollo.cyber.demo_cpp;\n\nmessage Radar &#123;\n    required string name  &#x3D; 1;\n    required int64 age  &#x3D; 2;\n    optional int64  length  &#x3D; 3;\n&#125;\n\n编写两个talker 文件（发布方）1、前发布者\n#include &quot;cyber&#x2F;cyber.h&quot;\n#include &quot;cyber&#x2F;demo_cpp&#x2F;components_2&#x2F;radar.pb.h&quot;\n\nusing apollo::cyber::demo_cpp::Radar;\n\nint main(int argc, char const *argv[])\n&#123;\n\tapollo::cyber::Init(argv[0]);\n\tAINFO &lt;&lt; &quot;前雷达检测系统初始化成功!!!&quot;;\n\tauto talker_front_node &#x3D; apollo::cyber::CreateNode(&quot;talker_front_node&quot;);\n\tauto talker_front &#x3D; talker_front_node-&gt;CreateWriter&lt;Radar&gt;(&quot;front_radar&quot;);\n\n\tuint64_t sq &#x3D; 0;\n\n\tapollo::cyber::Rate rate(0.25);\n\n\twhile (apollo::cyber::OK())\n\t&#123;\n\t\tAINFO &lt;&lt; &quot;前雷达发送第 &quot; &lt;&lt; sq &lt;&lt; &quot;条信息&quot;;\n\t\tstd::shared_ptr&lt;Radar&gt; radar &#x3D; std::make_shared&lt;Radar&gt;();\n\n\t\tradar-&gt;set_age(sq);\n\t\tradar-&gt;set_name(&quot;yuri_front&quot;);\n\t\tradar-&gt;set_length(666);\n\n\t\ttalker_front-&gt;Write(radar);\n\n\t\tsq++;\n\n\t\trate.Sleep();\n\t&#125;\n\n\tapollo::cyber::WaitForShutdown();\n\n\treturn 0;\n&#125;\n\n\n2、后发布者\n#include &quot;cyber&#x2F;cyber.h&quot;\n#include &quot;cyber&#x2F;demo_cpp&#x2F;components_2&#x2F;radar.pb.h&quot;\n\nusing apollo::cyber::demo_cpp::Radar;\n\nint main(int argc, char const *argv[])\n&#123;\n\tapollo::cyber::Init(argv[0]);\n\tAINFO &lt;&lt; &quot;后雷达检测系统初始化成功!!!&quot;;\n\tauto talker_back_node &#x3D; apollo::cyber::CreateNode(&quot;talker_back_node&quot;);\n\tauto talker_back &#x3D; talker_back_node-&gt;CreateWriter&lt;Radar&gt;(&quot;back_radar&quot;);\n\n\tuint64_t sq &#x3D; 0;\n\n\tapollo::cyber::Rate rate(0.5);\n\n\twhile (apollo::cyber::OK())\n\t&#123;\n\t\tAINFO &lt;&lt; &quot;后面雷达发送第 &quot; &lt;&lt; sq &lt;&lt; &quot;条信息&quot;;\n\t\tstd::shared_ptr&lt;Radar&gt; radar &#x3D; std::make_shared&lt;Radar&gt;();\n\n\t\tradar-&gt;set_age(sq);\n\t\tradar-&gt;set_name(&quot;yuri_back&quot;);\n\t\tradar-&gt;set_length(666);\n\n\t\ttalker_back-&gt;Write(radar);\n\n\t\tsq++;\n\n\t\trate.Sleep();\n\t&#125;\n\n\tapollo::cyber::WaitForShutdown();\n\n\treturn 0;\n&#125;\n\n\n\n\n编写类头文件#ifndef MY_COMPONENTS_2_H\n#define MY_COMPONENTS_2_H\n\n#include &quot;cyber&#x2F;component&#x2F;component.h&quot;\n\n#include &quot;cyber&#x2F;demo_cpp&#x2F;components_2&#x2F;radar.pb.h&quot;\n\nusing apollo::cyber::Component;\nusing apollo::cyber::demo_cpp::Radar;\n\nclass My_components_2 : public Component&lt;Radar, Radar&gt; &#x2F;&#x2F;有两个消息，所有需要两个消息载体\n&#123;\nprivate:\n\tstd::shared_ptr&lt;apollo::cyber::Writer&lt;Radar&gt;&gt; writer; &#x2F;&#x2F;申明一个writer对象，用于发布新的数据\n\tuint64_t sq &#x3D; 0; &#x2F;&#x2F;用来计数，统计执行的次数\n\npublic:\n\tbool Init() override; \n\tbool Proc(const std::shared_ptr&lt;Radar&gt;&amp; front,const std::shared_ptr&lt;Radar&gt;&amp; back) override; \n&#125;;\n\nCYBER_REGISTER_COMPONENT(My_components_2) &#x2F;&#x2F;注册组件\n\n#endif\n\n编写cc文件#include &quot;cyber&#x2F;demo_cpp&#x2F;components_2&#x2F;my_components_2.h&quot;\n\nbool My_components_2::Init()\n&#123;\n    AINFO &lt;&lt; &quot;组件初始化成功&quot;;\n\tthis-&gt;writer &#x3D; this-&gt;node_-&gt;CreateWriter&lt;Radar&gt;(&quot;my_components_2&quot;); &#x2F;&#x2F;初始化时，新建一个writer话题，用于后续写入东西\n\treturn true;\n&#125;\n\nbool My_components_2::Proc(const std::shared_ptr&lt;Radar&gt; &amp;front, const std::shared_ptr&lt;Radar&gt; &amp;back)\n&#123;\n\tAINFO &lt;&lt; &quot;信息接受成功！正在处理数据&quot;;\n\tstd::shared_ptr&lt;Radar&gt; radar &#x3D; std::make_shared&lt;Radar&gt;();\n\tradar-&gt;set_age(front-&gt;age() + back-&gt;age());\n\tradar-&gt;set_name(&quot;front + back&quot;);\n\tradar-&gt;set_length(front-&gt;length() + back-&gt;length());\n\n\tthis-&gt;writer-&gt;Write(radar); &#x2F;&#x2F;每次执行，写入新的东西 \n\n\tAINFO &lt;&lt; &quot;处理完毕！ 这是第 &quot; &lt;&lt; this-&gt;sq++ &lt;&lt; &quot; 条数据&quot;;\n\n\treturn true;\n&#125;\n\n编写dag 文件module_config &#123;\n\n    module_library : &quot;&#x2F;apollo&#x2F;bazel-bin&#x2F;cyber&#x2F;demo_cpp&#x2F;components_2&#x2F;my_components_2.so&quot;\n\n    components &#123;\n\n        class_name : &quot;My_components_2&quot; \n\n        config &#123;\n            name : &quot;My_components_2&quot;\n            readers &#123;\n                channel : &quot;front_radar&quot; \n            &#125;\n            readers &#123;\n                channel : &quot;back_radar&quot; \n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n编写launch 文件&lt;cyber&gt; \n    &lt;module&gt;\n        &lt;name&gt; my moudle&lt;&#x2F;name&gt; &lt;!--模块名字--&gt;\n        &lt;dag_conf&gt;&#x2F;apollo&#x2F;cyber&#x2F;demo_cpp&#x2F;components&#x2F;cpt.dag&lt;&#x2F;dag_conf&gt; &lt;!-- dag 目录位置--&gt;\n        &lt;process_name&gt; my_cpt &lt;&#x2F;process_name&gt;\n    &lt;&#x2F;module&gt;\n&lt;&#x2F;cyber&gt;\n\n执行仍然可以输入两个命令进行执行。并且可以使用  cyber_channel list 命令查看当前有多少话题\n然后输入cyber_channel echo 话题名字，查看话题内容\n\n\n组件（三）\n\n\n\n\n\n\n\n\n定时器组件\n用于每秒钟执行proc 函数，和前面组件的使用大同小异\n编写头文件#ifndef TIMECOMPONENT_H\n#define TIMECOMPONENT_H\n\n\n#include &quot;cyber&#x2F;component&#x2F;timer_component.h&quot;\n#include &quot;cyber&#x2F;cyber.h&quot;\n\nusing apollo::cyber::TimerComponent;\n\nclass My_TimeComponent: public TimerComponent\n&#123;\nprivate:\n\tuint64_t sq;\n\npublic:\n\tbool Init() override;\n\tbool Proc() override;\n&#125;;\n\nCYBER_REGISTER_COMPONENT(My_TimeComponent)\n#endif\n\n编写具体实现#include &quot;cyber&#x2F;demo_cpp&#x2F;timeComponent&#x2F;timeComponent.h&quot;\n\nbool My_TimeComponent::Init()\n&#123;\n    AINFO &lt;&lt; &quot;定时器组件初始化成功!&quot;;\n\tthis-&gt;sq &#x3D; 0;\n\treturn true;\n&#125;\n\nbool My_TimeComponent::Proc()\n&#123;\n\tsq++;\n\tAINFO &lt;&lt; &quot;处理数据中&quot; &lt;&lt; sq;\n\treturn true;\n&#125;\n\n编写launch文件&lt;cyber&gt; \n    &lt;module&gt;\n        &lt;name&gt; my moudle&lt;&#x2F;name&gt; &lt;!--模块名字--&gt;\n        &lt;dag_conf&gt;&#x2F;apollo&#x2F;cyber&#x2F;demo_cpp&#x2F;timeComponent&#x2F;cpt.dag&lt;&#x2F;dag_conf&gt; &lt;!-- dag 目录位置--&gt;\n        &lt;process_name&gt; my_cpt &lt;&#x2F;process_name&gt;\n    &lt;&#x2F;module&gt;\n&lt;&#x2F;cyber&gt;\n\n编写dag文件interval 表示每秒钟执行多少次proc函数\nmodule_config &#123;\n\n    module_library : &quot;&#x2F;apollo&#x2F;bazel-bin&#x2F;cyber&#x2F;demo_cpp&#x2F;timeComponent&#x2F;timeComponent.so&quot;\n\n    timer_components &#123;\n\n        class_name : &quot;My_TimeComponent&quot;\n\n        config &#123;\n            name : &quot;timeComponent&quot;\n            interval : 10\n        &#125;\n    &#125;\n&#125;\n\n编写build文件load(&quot;&#x2F;&#x2F;tools&#x2F;install:install.bzl&quot;,&quot;install&quot;)\n\n# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_library\ncc_library(\n    name &#x3D; &quot;timeComponent_lib&quot;,\n    srcs &#x3D; [&quot;timeComponent.cc&quot;],\n    hdrs &#x3D; [&quot;timeComponent.h&quot;],\n    deps &#x3D; [&quot;&#x2F;&#x2F;cyber&quot;],\n)\n\n# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_binary\ncc_binary(\n    name &#x3D; &quot;timeComponent.so&quot;,\n    linkshared &#x3D; True,\n    linkstatic &#x3D; False,\n    deps &#x3D; [&quot;:timeComponent_lib&quot;],\n)\n\nfilegroup(\n    name &#x3D; &quot;conf&quot;,\n    srcs &#x3D; [\n        &quot;:cpt.dag&quot;,\n        &quot;:cpt.launch&quot;,\n    ],\n)\n\ninstall (\n    name &#x3D; &quot;install&quot;,\n    data &#x3D; [\n        &quot;:conf&quot;,\n    ],\n\n    runtime_dest &#x3D; &quot;cyber&#x2F;demo_cpp&#x2F;timeComponent&quot;,\n    targets &#x3D; [\n        &quot;:timeComponent.so&quot;,\n    ],\n)\n\n执行\n开发工具CyberRecord\n\n\n\n\n\n\n\n\n介绍： 用工具提高开发效率\nCyberRecord 用来持久化存储数据，不用一直放在内存当中。可以将他写入到磁盘文件中\n学完之后我们就可以对数据进行 延迟、反复使用，也可以对数据进行二次处理\n编写wirter文件这里的proto文件我选择用前面的，也可以用自己重新生成的\n#include &quot;cyber&#x2F;cyber.h&quot;\n#include &quot;cyber&#x2F;demo_protobuf&#x2F;test_01&#x2F;student.pb.h&quot;\n#include &quot;cyber&#x2F;record&#x2F;record_writer.h&quot;\n\nusing apollo::cyber::demo_protobuf::Student;\nusing apollo::cyber::record::RecordWriter;\n\nint main(int argc, char const *argv[])\n&#123;\n\tapollo::cyber::Init(argv[0]);\n\tAINFO &lt;&lt; &quot;写信息初始化成功!&quot;;\n\n\tRecordWriter record_wiriter;\n\t&#x2F;&#x2F;设置每个文件达到多少kb后新建另外一个文件\n\trecord_wiriter.SetSizeOfFileSegmentation(0);\n\t&#x2F;&#x2F;设置每到多少秒钟之后新建另外一个文件\n\trecord_wiriter.SetIntervalOfFileSegmentation(0); \n\t&#x2F;&#x2F;需要写入的文件，文件必须不存在，否则保存捏\n\trecord_wiriter.Open(&quot;&#x2F;apollo&#x2F;cyber&#x2F;demo_cpp&#x2F;tools&#x2F;mytest.record&quot;); \n\t&#x2F;&#x2F;获得文件名字\n\tAINFO &lt;&lt; &quot;file : &quot; &lt;&lt; record_wiriter.GetFile(); \n\n\t&#x2F;&#x2F;新建话题名称是record\n\tstd::string channel &#x3D; &quot;record&quot;; \n\t&#x2F;&#x2F;第一个是发布话题的名字，第二个是数据类型，第三个参数是消息描述\n\trecord_wiriter.WriteChannel(channel, &quot;apollo.cyber.demo_protobuf.Student&quot;,&quot;test for record&quot;);\n\n    for (size_t i &#x3D; 0; i &lt; 20; i++)\n    &#123;\n\t\t&#x2F;&#x2F;先给消息添加内容\n\t\tauto stu &#x3D; std::make_shared&lt;Student&gt;();\n\t\tstu-&gt;set_age(18);\n\t\tstu-&gt;set_name(&quot;yuri&quot;);\n\t\tstu-&gt;set_height(i);\n\t\tstu-&gt;add_books(&quot;yuri&quot;);\n\t\tstu-&gt;add_books(&quot;终将成为你!&quot;);\n\t\tstu-&gt;add_books(&quot;安达与岛村！&quot;);\n\n\t\tstd::string contant;\n\t\t&#x2F;&#x2F;将消息转化成字符串存进去\n\t\tstu-&gt;SerializeToString(&amp;contant);\n\t\t&#x2F;&#x2F;写入文件内容，写入序号，以及写入话题\n\t\trecord_wiriter.WriteMessage(channel,*stu,i);\n\t&#125;\n\n\t&#x2F;&#x2F;关闭文件\n\trecord_wiriter.Close();\n\n\treturn 0;\n&#125;\n\n\n编写reader文件#include &quot;cyber&#x2F;record&#x2F;record_reader.h&quot;\n#include &quot;cyber&#x2F;record&#x2F;record_message.h&quot;\n#include &quot;cyber&#x2F;cyber.h&quot;\n\nusing apollo::cyber::record::RecordMessage;\nusing apollo::cyber::record::RecordReader;\n\nint main(int argc, char const *argv[])\n&#123;\n\tapollo::cyber::Init(argv[0]);\n    AINFO &lt;&lt; &quot;初始化成功！ 正在读取文件---&quot;;\n\n\t&#x2F;&#x2F;建立reader需要添加读取的文件目录\n\tRecordReader record_reader(&quot;&#x2F;apollo&#x2F;cyber&#x2F;demo_cpp&#x2F;tools&#x2F;mytest.record&quot;);\n\n\t&#x2F;&#x2F;设置话题\n\tstd::string channel &#x3D; &quot;record&quot;;\n\n\t&#x2F;&#x2F;读取文件中对应话题的内容\n\tsize_t msg_number &#x3D;  record_reader.GetMessageNumber(channel); &#x2F;&#x2F;消息条数\n\tstd::string msg_type &#x3D;  record_reader.GetMessageType(channel); &#x2F;&#x2F;消息类型\n\tstd::string msg_desc &#x3D; record_reader.GetProtoDesc(channel); &#x2F;&#x2F;消息描述\n\n\tAINFO &lt;&lt; &quot;信息获取成功!&quot;;\n\tAINFO &lt;&lt; &quot;总共获取到了 &quot; &lt;&lt; msg_number &lt;&lt; &quot; 条信息!&quot;;\n\tAINFO &lt;&lt; &quot;信息类型 : &quot; &lt;&lt; msg_type;\n\tAINFO &lt;&lt; &quot;信息描述 : &quot; &lt;&lt; msg_desc;\n\n\t&#x2F;&#x2F;创建整合读取消息的对象\n\tRecordMessage recore_message;\n    for (size_t i &#x3D; 0; i &lt; msg_number; i++)\n    &#123;   \n\t\t&#x2F;&#x2F;读取消息，并且存放起来\n\t\tif(record_reader.ReadMessage(&amp;recore_message))\n        &#123;\n\t\t\tAINFO &lt;&lt; &quot;第 &quot; &lt;&lt; i &lt;&lt; &quot; 条信息！  &quot;\n\t\t\t      &lt;&lt; &quot;  hannel_name : &quot; &lt;&lt; recore_message.channel_name &#x2F;&#x2F;话题名字\n\t\t\t      &lt;&lt; &quot;  contant : &quot; &lt;&lt; recore_message.content &#x2F;&#x2F;具体存入的消息内容\n                  &lt;&lt; &quot;  time :&quot; &lt;&lt; recore_message.time; &#x2F;&#x2F;写入消息时的序号\n        &#125;else&#123;\n\t\t\tAINFO &lt;&lt; &quot;获取信息失败!&quot;;\n\t\t&#125;\n\t&#125;\n\n\treturn 0;\n&#125;\n\n\n编写build文件# https:&#x2F;&#x2F;docs.bazel.build&#x2F;versions&#x2F;master&#x2F;be&#x2F;c-cpp.html#cc_binary\ncc_binary(\n    name &#x3D; &quot;record_writer&quot;,\n    srcs &#x3D; [&quot;record_writer.cc&quot;],\n    deps &#x3D; [\n        &quot;&#x2F;&#x2F;cyber&#x2F;demo_protobuf&#x2F;test_01:student_cc&quot;,\n        &quot;&#x2F;&#x2F;cyber&quot;\n    ],\n)\n\ncc_binary(\n    name &#x3D; &quot;record_reader&quot;,\n    srcs &#x3D; [&quot;record_reader.cc&quot;],\n    deps &#x3D; [\n        &quot;&#x2F;&#x2F;cyber&quot;\n    ],\n)\n\n执行先执行writer文件写入文件，然后再执行reader文件读取文件内容\n\ncyber RT 常用命令\n\n\n\n\n\n\n\n\n应用场景： 提高我们的开发效率。检测节点是否运行正常。判断节点信息发送频率是否符合预期。\n可以使用命令cyber_pp  -h(help) 或者 cyber_pp 命令 -h\nroleid           5214286195303063771 角色ID\nhostname         in-dev-docker 主机\nprocessid        44769 进程号\nnodename         ergou 节点名字\nmsgtype          apollo.cyber.demo_protobuf.Student 发送信息的类型\n\n\n\ncyber_node\n\n\n\n\n\n\n\n\n查询关于节点相关的信息\ncyber_node list 查看所有节点\ncyber_node info ergou 查看ergou的详细信息\ncyber_node info -a 查看所有节点信息\n\n\ncyber_channel\n\n\n\n\n\n\n\n\n查询关于话题相关的信息\ncyber_channel list      显示所有正在运行的话题\ncyber_channel info      显示某个话题的具体信息\ncyber_channel echo      将话题的信息打印到屏幕上\ncyber_channel hz        显示话题信息发布的频率\ncyber_channel bw        显示话题信息发布的带宽\ncyber_channel type      显示话题信息类型\n\ncyber_service\n\n\n\n\n\n\n\n\n查询关于服务相关的信息\ncyber_service list      列出所有正在运行的服务\ncyber_service info      打印相关服务的信息\n\n\n\ncyber_launch\n\n\n\n\n\n\n\n\n关于launch文件相关的信息\ncyber_launch start ...launch 启动launch文件\ncyber_launch stop  ...launch 关闭launch文件\n\n\n\ncyber_monitor\n\n\n\n\n\n\n\n\n综合类的信息。更灵活的小时话题的相关信息\ncyber_monitor 直接进去 按 q或者 esc 退出 ---- 默认显示所有话题的发布数据的频率\nOption:\n   -h print help info\n   -c 指定一个话题\n   q | Q | Esc -- 退出\n   Backspace -- 返回上一步\n   h | H -- 输出提示信息\n\nCommon Commands for Topology and Channel Message:\n   PgDn | d -- 下一页\n   PgUp | u -- 上一页\n\n   Up Arrow -- move up one line\n   Down Arrow -- move down one line\n   Right Arrow -- enter the selected Channel or Repeated Datum\n   Left Arrow -- go back to the upper level\n\n   Enter -- 进入指定话题信息显示\n   a | A -- the same with Left Arrow key\n   d | D -- the same with Right Arrow key\n   w | W -- the same with Up Arrow key\n   s | S -- the same with Down Arrow key\n\nCommands for Topology message: 消息显示相关问题\n   f | F -- 显示消息发布帧率\n   t | T --\t显示消息发布类型\n\n   Space -- 关闭或打开消息\n\nCommands for Channel:\n   i | I -- 显示话题读写相关信息\n   b | B -- 显示消息内容\n\nCommands for Channel Repeated Datum:\n   n | N -- 重复字段下一个元素 比如多个books\n   m | M -- 重复字段上一个元素\n   , -- enable|disable to show all repeated items\n\n\n\ncyber_record\n\n\n\n\n\n\n\n\n实现消息的录制和重放\ninfo    显示一个已经存在的Record 的文件的信息\nplay    回放一个Record文件 play -f 文件 回放文件\nrecord  录制一个Record文件 record -a -o 文件 录制为文件\nsplit   分割一个Record文件\nrecover 复制Record文件 recover -f 文件 -o 文件2 复制文件1命名为文件2\n\nrecord_file:    cyber&#x2F;demo_cpp&#x2F;tools&#x2F;mytest.record\nversion:        1.0 版本号\nduration:       0.000000 Seconds 录制时间\nbegin_time:     1970-01-01-08:00:00 开始时间\nend_time:       1970-01-01-08:00:00\nsize:           3802 Bytes (3.712891 KB) 录制大小\nis_complete:    true 是否已经结束\nmessage_number: 20 录制的消息个数\nchannel_number: 1 话题个数\nchannel_info:   \n                record     话题名称                                             20 messages: apollo.cyber.demo_protobuf.Student 消息类型\n\n\n\n常用api常用api上面都有介绍，下面介绍不怎么用的\napi查询链接 ：  apolloCyberRT\ntime 时间api#include &quot;cyber&#x2F;cyber.h&quot;\n\nusing apollo::cyber::Time;\n\nint main(int argc, char const *argv[])\n&#123;\n\tTime t_1; &#x2F;&#x2F;默认构造函数，获取默认时间 1970.1.1.8：00：000\n\tTime t_2(6666); &#x2F;&#x2F;整形构造函数，获取默认时间加上 6666ns\n\tTime t_3(120.0); &#x2F;&#x2F;double构造函数，获取默认时间加上 120s\n\n\tAINFO &lt;&lt; &quot;t_1 : &quot; &lt;&lt; t_1;\n\tAINFO &lt;&lt; &quot;t_2 : &quot; &lt;&lt; t_2;\n\tAINFO &lt;&lt; &quot;t_3 : &quot; &lt;&lt; t_3;\n\tAINFO &lt;&lt; &quot;t_2(s) : &quot; &lt;&lt; t_2.ToSecond(); &#x2F;&#x2F;转换成秒\n\tAINFO &lt;&lt; &quot;t_2(ns) : &quot; &lt;&lt; t_2.ToNanosecond(); &#x2F;&#x2F;转换成纳秒\n\tAINFO &lt;&lt; &quot;t_2(ms) : &quot; &lt;&lt; t_2.ToMicrosecond(); &#x2F;&#x2F;转换成微秒\n\tAINFO &lt;&lt; &quot;t_3(s) : &quot; &lt;&lt; t_3.ToSecond();\n\n\t&#x2F;&#x2F;获取最大或者最小时间\n\t&#x2F;&#x2F;默认添加的是ns 而ns是long long 类型，所有默认最大值是 2^64 - 1\n\n\tAINFO &lt;&lt; &quot;max time (s) &quot; &lt;&lt; Time::MAX.ToSecond(); &#x2F;&#x2F;最大时间\n\tAINFO &lt;&lt; &quot;min time (s) &quot; &lt;&lt; Time::MIN.ToSecond(); &#x2F;&#x2F;最小时间\n\tAINFO &lt;&lt; &quot;t_1 is zeor ? &quot; &lt;&lt; t_1.IsZero(); &#x2F;&#x2F;判断是不是0\n\tAINFO &lt;&lt; &quot;t_2 is zeor ? &quot; &lt;&lt; t_2.IsZero(); &#x2F;&#x2F;只有当时间为默认时间时，才会是0\n\n\n\tAINFO &lt;&lt; &quot;现在时间 : &quot; &lt;&lt; Time::Now(); &#x2F;&#x2F;返回现在时间\n\tTime::SleepUntil(Time(Time::Now().ToSecond() + 10));  &#x2F;&#x2F;休眠 直到 --- 设置的时间\n\tAINFO &lt;&lt; &quot;现在时间 : &quot; &lt;&lt; Time::Now();\n\n\tAINFO &lt;&lt; &quot;系统已经运行了 : &quot; &lt;&lt; Time::MonoTime().ToSecond(); &#x2F;&#x2F;返回系统开机运行的时间，这里返回docker容器启动的时间\n\n\treturn 0;\n&#125;\n\n\nduration 持续时间api#include &quot;cyber&#x2F;cyber.h&quot;\n#include &quot;cyber&#x2F;time&#x2F;duration.h&quot;\n\nusing apollo::cyber::Duration;\nusing apollo::cyber::Time;\n\nint main(int argc, char const *argv[])\n&#123;\n\tDuration d_1(5.0); &#x2F;&#x2F;创建5s的持续时间\n    &#x2F;&#x2F;别的东西基本和time 相同\n\tTime t_1(10.0);\n\tTime t_2(5.0);\n\n\tDuration d_2(5 + 1000); &#x2F;&#x2F;创建5s 加上 1000ns 的持续时间\n\n\tAINFO &lt;&lt; &quot;d_1 time : &quot; &lt;&lt; d_1;\n\tAINFO &lt;&lt; &quot;d_2 time : &quot; &lt;&lt; d_2;\n\tAINFO &lt;&lt; &quot;t_1 time : &quot; &lt;&lt; t_1;\n\tAINFO &lt;&lt; &quot;d_2 time : &quot; &lt;&lt; t_2;\n\n\tAINFO &lt;&lt; &quot;现在时间是： &quot; &lt;&lt; Time::Now();\n\td_1.Sleep(); &#x2F;&#x2F;休眠5s\n\tAINFO &lt;&lt; &quot;现在时间是： &quot; &lt;&lt; Time::Now();\n\n\tAINFO &lt;&lt; &quot;t_1(10.0) + d_1(5.0) : &quot; &lt;&lt; t_1 + d_1;  &#x2F;&#x2F;结果就是10 - 5 \n\tAINFO &lt;&lt; &quot;t_1(10.0) - d_1(5.0) : &quot; &lt;&lt; t_1 - d_1;\n\tAINFO &lt;&lt; &quot; d_1 &#x3D;&#x3D; d_2 ? &quot; &lt;&lt; (d_1 &#x3D;&#x3D; d_2);\n\n\treturn 0;\n&#125;\n\nrate 休眠api#include &quot;cyber&#x2F;cyber.h&quot;\n#include &quot;cyber&#x2F;time&#x2F;rate.h&quot;\n\nusing apollo::cyber::Rate;\n\nint main(int argc, char const *argv[])\n&#123;\n\tRate r_1(2.0); &#x2F;&#x2F;使用double类型会将发布频率设置为 2.0，也就是休眠时间 1&#x2F;2.0 也就是0.5s\n\tRate r_2((uint64_t)1000000000); &#x2F;&#x2F;直接设置休眠时间为多少ns\n\tapollo::cyber::Duration d_1(5.0);\n\tRate r_3(d_1); &#x2F;&#x2F;直接设置持续时间\n\n\tAINFO &lt;&lt; &quot;r_1 休眠前时间 &quot; &lt;&lt; apollo::cyber::Time::Now();\n\tr_1.Sleep(); &#x2F;&#x2F;启动休眠\n\tAINFO &lt;&lt; &quot;r_1 休眠后时间 &quot; &lt;&lt; apollo::cyber::Time::Now();\n\tAINFO &lt;&lt; &quot;&quot;;\n\tAINFO &lt;&lt; &quot;r_2 休眠前时间 &quot; &lt;&lt; apollo::cyber::Time::Now();\n\tr_2.Sleep();\n\tAINFO &lt;&lt; &quot;r_2 休眠后时间 &quot; &lt;&lt; apollo::cyber::Time::Now();\n\tAINFO &lt;&lt; &quot;&quot;;\n\tAINFO &lt;&lt; &quot;r_3 休眠前时间 &quot; &lt;&lt; apollo::cyber::Time::Now();\n\tr_3.Sleep();\n\tAINFO &lt;&lt; &quot;r_3 休眠后时间 &quot; &lt;&lt; apollo::cyber::Time::Now();\n\treturn 0;\n&#125;\n\ntimer 定时api#include &quot;cyber&#x2F;cyber.h&quot;\n#include &quot;cyber&#x2F;timer&#x2F;timer.h&quot;\n\nusing apollo::cyber::Timer;\nint i &#x3D; 0;\n\nvoid cp()&#123;\n    AINFO &lt;&lt; &quot;定时器执行中!  &quot; &lt;&lt; ++i;\n&#125;\n\nint main(int argc, char const *argv[])\n&#123;\n\tTimer t_1(1000,cp,false);\n    &#x2F;&#x2F;参数 1 设置循环频率 1000就是1000ms 执行1次\n    &#x2F;&#x2F;参数 cp 就是设置循环逻辑\n    &#x2F;&#x2F;参数 3 是否只执行1次\n\n\tt_1.Start(); &#x2F;&#x2F;开启定时器\n\n\tsleep(3); &#x2F;&#x2F;先休眠3s\n\n\tt_1.Stop();\n\n\tAINFO &lt;&lt; &quot;函数停止!&quot;;\n\treturn 0;\n&#125;\n\nlog 日志api#include &quot;cyber&#x2F;cyber.h&quot;\n\nint main(int argc, char const *argv[])\n&#123;\n\tapollo::cyber::Init(argv[0]); &#x2F;&#x2F;初始化日志文件， 默认参数用于文件名，argv0 是文件名\n\n\tAINFO &lt;&lt; &quot;AINFO 一般信息&quot;;\n\tADEBUG &lt;&lt; &quot;ADEBUG 调试信息&quot;; &#x2F;&#x2F;仅仅在调试模式输出\n\tAWARN &lt;&lt; &quot;AWARN 警告信息&quot;;\n\tAFATAL &lt;&lt; &quot;AFATAL 严重警告信息&quot;;\n\treturn 0;\n&#125;\n\n\ncyber&#x2F;setup.bash 日志文件设置\nexport GLOG_log_dir&#x3D;&quot;$&#123;APOLLO_ROOT_DIR&#125;&#x2F;data&#x2F;log&quot; #设置日志目录\nexport GLOG_alsologtostderr&#x3D;1  #设置是否在终端中显示\nexport GLOG_colorlogtostderr&#x3D;1 #设置不同级别信息是否用不同颜色打印\nexport GLOG_minloglevel&#x3D;0 #设置打印哪种级别日志，参数0-3 0：全部，1 ： 一般以上 2： 只打印warn和fatal 3:只打印fatal\n\n\n\ncyber 下的函数包含在apollo::cyber命名空间下\nCreateNode 函数 &#x2F;&#x2F;函数原型 : \nstd::unique_ptr&lt;Node&gt; CreateNode(const std::string&amp; node_name,const std::string&amp; name_space &#x3D; &quot;&quot;)\n&#x2F;&#x2F;一般使用\nauto talker_node &#x3D; cyber::CreateNode(&quot;ergou&quot;); \n\nNode 下函数auto talker &#x3D; talker_node-&gt;CreateWriter&lt;Student&gt;(&quot;chatter&quot;);  &#x2F;&#x2F;创建发布者\nauto listener &#x3D; listener_node-&gt;CreateReader&lt;Student&gt;(&quot;chatter&quot;, cp);  &#x2F;&#x2F;创建监听者\n&#x2F;&#x2F;当监听到 chatter发送东西的时候，调用cp函数进行处理，cp函数需要传入 数据\nauto client &#x3D; client_node-&gt;CreateClient&lt;Request,Response&gt;(&quot;addints&quot;); &#x2F;&#x2F;设置客户机\nauto server &#x3D; server_node-&gt;CreateService&lt;Request, Response&gt;(&quot;addints&quot;,cp); &#x2F;&#x2F;设置接收到数据时的处理函数\nstd::shared_ptr&lt;ParameterServer&gt; server &#x3D; std::make_shared&lt;ParameterServer&gt;(server_node); &#x2F;&#x2F;创建服务端\nstd::shared_ptr&lt;ParameterClient&gt; client &#x3D; std::make_shared&lt;ParameterClient&gt;(client_node,&quot;param&quot;); &#x2F;&#x2F;创建客户端，需要传入服务端节点号\n\n","slug":"cyber","date":"2022-09-17T10:32:01.587Z","categories_index":"apollo","tags_index":"apollo,教程","author_index":"yuri2078"},{"id":"69f01253b53bd2b9171f221efabe5073","title":"apollo安装教程","content":"配置 apollo 教程\n\n\n\n\n\n\n\n\n前言 ： 这是一整套的搭建教程，如果仅仅是需要看代码，直接本地克隆代码就行\n如果需要实机使用apollo 工具进行开发，获取调试之类的才需要完整构建\n这个教程是基于虚拟机，如果需要wsl 请看官方教程，以及如果你仅仅想轻量化使用pnc 可以考虑edu 版本\napollo 官方教程edu 版本安装\nWSL2 win子系统安装\n官方文档\n安装虚拟机\n下载虚拟机\n\n https://www.aliyundrive.com/s/eN7uiuj2HtQ (阿里云盘)\n\nhttps://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html (官网链接)\n\n\n\n激活虚拟机 https://zhuanlan.zhihu.com/p/386892372\n\n\n安装 ubuntu 22.04\n\n\n\n\n\n\n\n\n官方推荐使用 ubuntu 18.04 这是以 22.04举列子，一样的\n\n下载镜像 https://releases.ubuntu.com/22.04/ubuntu-22.04.1-desktop-amd64.iso官网链接\n\n打开 VMware 安装 ubuntu\n\n新建虚拟机 选择以典型安装 然后下一步\n选择第二个 （以镜像文件安装） 选择刚下载的 ubantu 22.04 镜像 然后下一步\n用户名 随意设置 密码 需要记住 （开机后的 root 密码）然后下一步\n选择一个空的文件夹存放虚拟机\n分配空间至少分配 80G （亲测 50G 加 8G 内存 gcc 编译内存不足）(选择合并成一个文件，多个文件都行)\n内存分配最好 4G 以上，不然容易卡 （我是 8G）核心数和线程数不想卡，就多分点。我分了 3 核 4 线程\n然后下一步等他打开虚拟机\n重新启动等他弹出设置语言界面（中文 Chinese 英文都行）\n然后 continue\n然后点击 Install Now(后面问你是否确定，直接确定 continue 就行)\n然后让你输入名字 密码（这是登录系统的密码，也就是锁屏密码）输入之后下一步等安装就行了\n等他安装好了之后会问你重启吗？ 立即重启就行了，然后输入你刚刚设置的登录密码登录就行了\n\n\n开机之后一路右上角 skip down 就行，不同具体设置\n\n\n安装英伟达驱动\n\n\n\n\n\n\n\n\n需要使用感知模块并且有显卡的需要安装一下英伟达显卡驱动  —– 以下教程来自官方文档\n\n安装必要软件包\nsudo apt-get update\nsudo apt-add-repository multiverse\nsudo apt-get update\nsudo apt-get install nvidia-driver-455\n\n\n\n输入 nvidia-smi来校验 NVIDIA GPU 驱动是否在正常运行（可能需要在安装后重启系统以使驱动生效）\nPrompt&gt; nvidia-smi\nMon Jan 25 15:51:08 2021\n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 460.27.04    Driver Version: 460.27.04    CUDA Version: 11.2     |\n|-------------------------------+----------------------+----------------------+\n| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp  Perf  Pwr:Usage&#x2F;Cap|         Memory-Usage | GPU-Util  Compute M. |\n|                               |                      |               MIG M. |\n|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|\n|   0  GeForce RTX 3090    On   | 00000000:65:00.0  On |                  N&#x2F;A |\n| 32%   29C    P8    18W &#x2F; 350W |    682MiB &#x2F; 24234MiB |      7%      Default |\n|                               |                      |                  N&#x2F;A |\n+-------------------------------+----------------------+----------------------+\n\n+-----------------------------------------------------------------------------+\n| Processes:                                                                  |\n|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |\n|        ID   ID                                                   Usage      |\n|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|\n|    0   N&#x2F;A  N&#x2F;A      1286      G   &#x2F;usr&#x2F;lib&#x2F;xorg&#x2F;Xorg                 40MiB |\n|    0   N&#x2F;A  N&#x2F;A      1517      G   &#x2F;usr&#x2F;bin&#x2F;gnome-shell              120MiB |\n|    0   N&#x2F;A  N&#x2F;A      1899      G   &#x2F;usr&#x2F;lib&#x2F;xorg&#x2F;Xorg                342MiB |\n|    0   N&#x2F;A  N&#x2F;A      2037      G   &#x2F;usr&#x2F;bin&#x2F;gnome-shell               69MiB |\n|    0   N&#x2F;A  N&#x2F;A      4148      G   ...gAAAAAAAAA --shared-files      105MiB |\n+-----------------------------------------------------------------------------+\n\n\n\n为了在容器内获得 GPU 支持，在安装完 docker 后需要安装 NVIDIA Container Toolkit。 运行以下命令安装 NVIDIA Container Toolkit：\ndistribution&#x3D;$(. &#x2F;etc&#x2F;os-release;echo $ID$VERSION_ID)\ncurl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;nvidia-docker&#x2F;gpgkey | sudo apt-key add -\ncurl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;nvidia-docker&#x2F;$distribution&#x2F;nvidia-docker.list | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;nvidia-docker.list\nsudo apt-get -y update\nsudo apt-get install -y nvidia-docker2\n\n安装完成后，重启 Docker 以使改动生效。\nsudo systemctl restart docker\n\n安装完毕后，可以在APOLLO容器内输入nvidia-smi来校验 NVIDIA GPU 在容器内是否能正常运行（详见1）。\n\n\n开始配置 apollo准备秘钥\n\n\n\n\n\n\n\n\n如果能够使用github 版本就不用搞这个直接 git clone https://github.com/ApolloAuto/apollo.git 就行，如果提示没有git 就执行 sudo apt install git就行\n如果看不懂上面在说什么就直接无视这句话就行\n\n注册 gitte https://gitee.com/\n点击右上角加号 -&gt; 新建仓库\n仓库的名字和路径随便填 然后点击创建\n进入仓库，点击顶部一排选项右边的 ‘’管理‘’\n点击部署公钥管理 -&gt; 添加公钥 名字随便，内容填下面输出的内容\n打开终端输入 ssh-keygen -t ed25519 -C &quot;xxxxx@xxxxx.com&quot;  然后直接回车 3 次就行\n输入cat ~/.ssh/id_ed25519.pub 然后复制输出的 ssh -ed …… 添加到公钥\n填写完成之后终端 输入ssh -T git@gitee.com按提示回复 yes 然后看到他输出 Hi Anonymous就行了\n\n更换国内源\n打开终端输入 sudo vim /etc/docker/daemon.json\n\n然后按 i 进入插入模式\n\n复制下面的语句ctrl shift + v 复制进去\n&#123;\n    &quot;registry-mirrors&quot;: [\n        &quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;,\n        &quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;,\n        &quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;\n    ]\n&#125;\n\n按ESC键后输入  :wq!保存并退出\n\n输入service docker restart重新加载docker\n\n输入 docker info 末尾出现类似的就是成功了\nInsecure Registries:\n 127.0.0.0&#x2F;8\nRegistry Mirrors:\n http:&#x2F;&#x2F;hub-mirror.c.163.com&#x2F;\n https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&#x2F;\n https:&#x2F;&#x2F;registry.docker-cn.com&#x2F;\nLive Restore Enabled: false\n   \n\n开始跑命令\n浏览器打开https://wwho.lanzoue.com/ioHPm0jsee5g下载 docker.txt\n\n下载完成后 ctrl + alt + t 打开终端\n\ncd Download 目录\n\n输入 ls 查看是否有一个 docker.txt\n\n输入 bash docker.txt 开始跑命令\n\n然后他会提示你输入 root 密码， 注意这里输入密码不会有提示，直接输入之后回车就行，看不到输入内容\n\n然后安心等待他跑完就行。大概需要好几个小时，因为需要下载很多东西\nλ ~&#x2F; master* cd Downloads #进入下载目录\nλ ~&#x2F;Downloads&#x2F; master* ls #查看当前目录下的所有文件\ndocker.sh\nλ ~&#x2F;Downloads&#x2F; master* bash docker.sh\n[sudo] password for yuri: #这里输入看不见的\n\n\n看到这样的输出就是成功\n\n\n开始 build apollo\n扩展虚拟内存 （防止 gcc 编译报错）\n\n终端照着输入就行 (需要输入 root 密码)\nsudo swapoff &#x2F;swapfile\nsudo rm &#x2F;swapfile\nsudo dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;swapfile bs&#x3D;1M count&#x3D;16240\nsudo mkswap &#x2F;swapfile\nsudo swapon &#x2F;swapfile\nfree -m #查看虚拟内存是不是挂载上了,看第二行 第一列 是不是16000多就行了\n\n打开终端输入\ncd apollo\nbash docker&#x2F;scripts&#x2F;dev_into.sh\nsudo bash apollo.sh build\n\n# 之用输入上面三个命令就行\n\n# 明确自己需要的东西，如果只要cyber 最后一句就是 \nsudo bash apollo.sh build cyber # 只要cyber\nsudo bash apollo.sh build dreamview # 只要dreamview\nsudo bash apollo.sh build planning # 只要预测模块\nsudo bash apollo.sh build_dbg # 以dbug 模式构建\n#开始build 好的配置大概build 半小时， 差的四五个小时\n#不要让屏幕熄灭，ubantu默认5分钟锁屏，可以去设置- 电源 里面改成永不熄灭，还有自己的电脑最好也搞一下\n\n等出现绿色的 OK 和 Enjoy 则表示成功 如图\n\n测试回放 demo\nbash scripts/bootstrap.sh start 然后会提示你在 http://localhost:8888 中访问他\n\n打开浏览器输入刚刚的网址出现这个界面就是成功\n\n下载测试 demo 下载链接：https://link.zhihu.com/?target=https%3A//blog.shipengx.com/download/demo_3.5.record\n\n下载完成执行 mv ~/Downloads/demo_3.5.record ~/apollo/docs/demo_guide 命令把他复制进测试文件夹\n\n进入 demo_guide 文件夹 cd ~/apollo/docs/demo_guide\n\n执行 cyber_recorder play -f demo_3.5.record -l然后打开浏览器就能看到该 demo\n\n\n","slug":"apollo配置","date":"2022-09-15T10:22:15.201Z","categories_index":"apollo","tags_index":"apollo,教程","author_index":"yuri2078"},{"id":"b95b0550c3492760431cfda4b2d90aa9","title":"vim语法","content":"vim语法常规用法\nvim 文件 用vim打开文件\n\nsudo vim 文件 使用su权限打开文件\n\n\n命令行\nwq 保存并且退出\n\nq 推出不保存\n\ni 切换到插入模式\n\nesc 推出编辑模式，切换到命令行模式\n\nh-左 j-上 k-下 l-右\n\n0 到这一行的开头\n\nyy 拷贝 dd 剪切 p粘贴\n\nset fileencoding 查看编码\n\n\n9 :1,$s&#x2F;word1&#x2F;word2&#x2F;g 或 :%s&#x2F;word1&#x2F;word2&#x2F;g 用world2 替换world1\n","slug":"vim语法","date":"2022-08-04T11:17:31.000Z","categories_index":"小记","tags_index":"常用命令,vim","author_index":"yuri2078"},{"id":"b08451922c6ccb7c92beca3c493566dd","title":"QT_linux开发","content":"QT linux 开发 基于 ubantu 22.04\n环境准备软件安装\n下载Qt https://download.qt.io 选择 qt-opensource-linux-x64-5.14.2.run\n\n安装 ls -l qt-opensource-linux-x64-5.14.2.run 查看是否有可执行权限\n\n给权限 chmod +x qt-opensource-linux-x64-5.14.2.run\n\n执行安装 ./qt-opensource-linux-x64-5.14.2.run 安装\n\n\n环境配置\nhome/yuri/rubbish/Qt/5.14.2/gcc_64/bin\n\nhome/yuri/rubbish/Qt/Tools/QtCreator/bin\n\nsudo vi /etc/environment 进入把两个目录粘贴进取 冒号隔开\n\nPATH=&quot;/home/yuri/rubbish/Qt/Tools/QtCreator/bin:/home/yuri/rubbish/Qt/5.14.2/gcc_64/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin&quot;\n\n\n测试qmake是否工作\n重新启动\n\n终端打开 qmake -v 输出版本号则成功\n\n打开qt 随便找一个看看能够运行\n\n如果不能 （报错 collect2:ld returned 1 exit status）\n\nsudo apt-get update\n\nsudo apt-get upgrade\n\nsudo apt install libgl1-mesa-dev\n\n\n\n\n一个QT程序\nmkdir hello 找到一个文件夹存储项目\n\nvim main.cpp 编辑代码\n \n#include &lt;QApplication&gt;\n#include &lt;QLabel&gt;\n\nint main(int argc, char **argv)\n&#123;\n    &#x2F;&#x2F;创建qt的应用程序对象\n    QApplication app(argc,argv);\n    QLabel *label_1 &#x3D; new QLabel(&quot;你好，谢谢!&quot;);\n    label_1-&gt;resize(800,800);\n    label_1-&gt;show();\n    return app.exec(); &#x2F;&#x2F;让应用程序进入事件循环\n&#125;\n\n\nqmake -project 生成对应的pro文件\n\nvim hello.pro 编辑文件 在顶部添加 QT +&#x3D; widgets 需要什么添加什么\n \n######################################################################\n# Automatically generated by qmake (3.1) Wed Jul 13 23:33:22 2022\n######################################################################\n\nQT +&#x3D; widgets\nTEMPLATE &#x3D; app\nTARGET &#x3D; hello\nINCLUDEPATH +&#x3D; .\n\n# You can make your code fail to compile if you use deprecated APIs.\n# In order to do so, uncomment the following line.\n# Please consult the documentation of the deprecated API in order to know\n# how to port your code away from it.\n# You can also select to disable deprecated APIs only up to a certain version of Qt.\n#DEFINES +&#x3D; QT_DISABLE_DEPRECATED_BEFORE&#x3D;0x060000    # disables all the APIs deprecated before Qt 6.0.0\n\n# Input\nSOURCES +&#x3D; main.cpp\n\n\nqmake 如果没有报错则连接成功 生成makefile文件\n\nmake 生成可执行文件\n\n./hello 执行文件\n\n\nui文件的使用\n编辑ui文件，将类名改为你以后需要用到的类的名字\n\ndesigner …ui 可以直接用设计师打开ui文件\n\nuic .ui -o ui_.h 转换ui文件为 h头文件\n\n\nqt常用重载函数qt常用事件\npaintEvent(QPaintEvent *); 绘图事件\n\nvoidkeyPressEvent(QKeyEvent *ev) 键盘按下事件\n\n\n","slug":"QT-linux开发","date":"2022-08-04T11:16:50.000Z","categories_index":"Qt","tags_index":"Qt","author_index":"yuri2078"},{"id":"b172669047508df38cc455a4fc57c0bb","title":"hexo安装教程","content":"安装nodejs\n一路下一步\nnodejs -v 查看安装版本号\nnpm -v 查看 npm 版本号\n如果npm 报错 进nodesjs 目录 把npm.cmd文件的第 12行和npm文件的第 23 行替换prefix -g为prefix –location&#x3D;global\n\n安装git\n一路下一步\ngit -v 查看安装是否成功\n\n注册GitHub\n新建一个仓库 名字是 用户名&#x2F;用户名.github.io – 固定格式\n\n准备开始 – 1\n替换镜像源 npm config set registry https://registry.npm.taobao.org\n\n创建一个文件夹 并 右击 在git bash中打开 &#x2F; win + R  cd 进去\n\nnpm i hexo-cli -g 安装hexo\n\nhexo -v 查看是否成功安装\n\nhexo init 初始化hexo 文件夹\n\nhexo install 创建hexo\n\nhexo g 生成静态文件夹\n\nhexo s 建立本地服务器 进网址看看是否成功\n\nctrl + C 退出服务\n\n\n开始 – 2\ngit config –global user.name “yuri2078” 设置全局用户名 GitHub 的用户名\n\ngit config –global user.email “&#121;&#117;&#114;&#x69;&#x32;&#48;&#x37;&#x38;&#49;&#x37;&#x30;&#x36;&#x35;&#x38;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;“ 设置全局邮箱 GitHub 的邮箱\n\nmkdir .ssh 新建ssh 文件夹 – 可以不建立\n\nssh-keygen -t rsa -C “&#x79;&#117;&#x72;&#105;&#50;&#x30;&#x37;&#x38;&#49;&#55;&#48;&#x36;&#x35;&#56;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#x6d;“ 生成 ssh 文件 一路回车即可\n\n进 c：&#x2F;用户&#x2F;用户名&#x2F;.ssh&#x2F;   用记事本 打开 id_rsa.pub 全选复制文件\n\n进GitHub 的个人设置 选择 ssh key ， 添加ssh  名字随意 key 为 刚复制的东西\n\nssh -T &#x67;&#105;&#116;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#x6d; 进行本地连接 – 出现自己的用户名就是成功 第一回可能会问你yes&#x2F;on 输入yes就行\n\n修改 博客根目录下 _config.yml 文件 将 deploy 修改为以下 repository 为自己的博客地址\n\n\ndeploy:\n  type: git\n  repository: https:&#x2F;&#x2F;github.com&#x2F;yuri2078&#x2F;yuri2078.github.io\n  branch: main\n\n\n\nhexo new post “fist-blog” 新建第一篇博客\n\n进 博客根目录&#x2F;source&#x2F;_posts 下找到文章.md 进行编辑\n\n\n提交\nhexo g 生成静态文件\nhexo d 提交到GitHub 随后访问 https://用户名.github.io就可以访问了\n\n日常使用\nhexo new page “categories” 添加分类功能\n\ncategories: - hello world 设置分类\n\n\nhexo new page “tags” 添加标签功能\n\ntags: 可以多个\n\n- jQuery\n- 表格\n- 表单验证\n\n\nhexo new page “about” 添加关于界面\n\nhexo new page “contact” 添加联系界面\n\nnpm i –save hexo-wordcount 安装 统计字数插件  \n\nnpm install hexo-deployer-git –save 解决git报错d\n\n\n免费cdn\n新建github仓库\n\n发布reselss版本\n\nhttps://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 访问你的图片\n\n\n","slug":"hexo安装教程","date":"2022-08-04T11:15:26.000Z","categories_index":"教程","tags_index":"hexo","author_index":"yuri2078"},{"id":"3c992e7574b48536b50666714703da0d","title":"git常用命令","content":"全局设置\ngit config --global user.name &quot;yuri2078&quot; 设置用户名\ngit config --global user.email &quot;yuri2078170658@gmail.com&quot; 设置邮箱账号\ngit config --global http.sslVerify &quot;false&quot; 取消全局验证\n\n取消全局代理\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n\n常用命令\ngit add file-name 添加指定文件\ngit add . 添加目录下所有文件\ngit commit -a 提交文件 然后进行编辑\ngit commit -m &quot;main&quot; 提交文件并以 “main” 作为提交\ngit branch -M main 新建分支\ngit push -u origin main 推送文件到main 分支\ngit log 查看历史提交日志\ngit reset --hard commit_id 回退到某个版本\ngit push main 推送到远程 main 分支\n\n远程覆盖本地\ngit fetch --all\ngit reset --hard origin/main\ngit pull\n\nconfig --global http.sslVerify \"false\"git config --global --unset http.proxy\ngit config --global --unset https.proxy \ngit add ..\ngit commit -m &quot;main&quot;\ngit push -u origin main\n\n\nlinux 常用修复命令\n每次都要输入密码\n  git config --global credential.helper store\n\n\ngithun 仓库密钥 更新时间 8.15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\n","slug":"git常用命令","date":"2022-08-04T11:14:44.000Z","categories_index":"小记","tags_index":"git,常用命令","author_index":"yuri2078"},{"id":"456a9f884f236ceaa1db3db112545b25","title":"css大全","content":"文本direction\n定义 属性规定文本的方向 &#x2F; 书写方向。\n\n语法 direction:ltr|rtl|inherit;\n\n属性值\n\n\n\n\n值\n描述\n\n\n\nltr\n默认。文本方向从左到右。\n\n\nrtl\n文本方向从右到左。\n\n\ninherit\n规定应该从父元素继承 direction 属性的值。\n\n\n\n\nletter-spacing\n定义 属性增加或减少字符间的空白（字符间距）.\n\n语法 letter-spacing:normal|length|inherit;\n\n属性值\n\n\n\n\nnormal\n默认。规定字符间没有额外的空间。\n\n\n\nlength\n定义字符间的固定空间（允许使用负值）。\n\n\ninherit\n规定应该从父元素继承 letter-spacing 属性的值。\n\n\n\n\nline-height\n定义 属性设置行间的距离（行高）。。\n\n语法 line-height:normal|number|length|%|inherit;\n\n属性值\n\n\n\n\nnormal\n默认。设置合理的行间距。\n\n\n\nnumber\n设置数字，此数字会与当前的字体尺寸相乘来设置行间距。\n\n\nlength\n设置固定的行间距。\n\n\n%\n基于当前字体尺寸的百分比行间距。\n\n\ninherit\n规定应该从父元素继承 line-height 属性的值。\n\n\n\n\ntext-align\n定义 属性规定元素中的文本的水平对齐方式。\n\n语法 text-align:left|right|center|justify|inherit;\n\n属性值\n\n\n\n\nleft\n把文本排列到左边。默认值：由浏览器决定。\n\n\n\nright\n把文本排列到右边。\n\n\ncenter\n把文本排列到中间。\n\n\njustify\n实现两端对齐文本效果。\n\n\ninherit\n规定应该从父元素继承 text-align 属性的值。\n\n\n\n\ntext-decoration\n定义 属性规定添加到文本的修饰。\n\n语法 text-decoration：none|underline|overline|line-through|blink|inherit;\n\n属性值\n\n\n\n\nnone\n默认。定义标准的文本。\n\n\n\nunderline\n定义文本下的一条线。\n\n\noverline\n定义文本上的一条线。\n\n\nline-through\n定义穿过文本下的一条线。\n\n\ninherit\n规定应该从父元素继承 text-decoration 属性的值。\n\n\n\n\ntext-indent\n定义 属性规定文本块中首行文本的缩进。\n\n语法 text-indent：length|%|inherit;\n\n属性值\n\n\n\n\nlength\n定义固定的缩进。默认值：0。\n\n\n\n%\n定义基于父元素宽度的百分比的缩进。\n\n\ninherit\n规定应该从父元素继承 text-indent 属性的值。\n\n\n\n\ntext-overflow\n定义 属性规定当文本溢出包含元素时发生的事情\n\n语法 text-overflow: clip|ellipsis|string;\n\n属性值 \n\n\n\n\n值\n描述\n\n\n\nclip\n修剪文本。\n\n\nellipsis\n显示省略符号来代表被修剪的文本。\n\n\nstring\n使用给定的字符串来代表被修剪的文本。\n\n\n\n\ntext-shadow\n定义 属性连接一个或更多的阴影文本。\n\n语法 text-shadow: h-shadow v-shadow blur color;\n\n属性值 \n\n\n\n\n值\n描述\n\n\n\nh-shadow\n必需。水平阴影的位置。允许负值。\n\n\nv-shadow\n必需。垂直阴影的位置。允许负值。\n\n\nblur\n可选。模糊的距离。\n\n\ncolor\n可选。阴影的颜色。参阅 CSS 颜色值。\n\n\n\n\ntext-transform\n定义 属性控制文本的大小写。\n\n语法 text-transform:none|capitalize|uppercase|lowercase|inherit;\n\n属性值 \n\n\n\n\n值\n描述\n\n\n\nnone\n默认。定义带有小写字母和大写字母的标准的文本。\n\n\ncapitalize\n文本中的每个单词以大写字母开头。\n\n\nuppercase\n定义仅有大写字母。\n\n\nlowercase\n定义无大写字母，仅有小写字母。\n\n\ninherit\n规定应该从父元素继承 text-transform 属性的值。\n\n\n\n\n字体@font-face\n定义 网页设计师再也不必使用的”web-safe”的字体之一。\n\n语法 @font-face\n{\nfont-properties\n}\n\n属性值 \n\n\n\n\n值\n说明 （索引中有详细介绍）\n\n\n\nfont-family\n必需的。定义字体的名称。\n\n\nsrc\n应该从父元素继承 opacity 属性的值。\n\n\nfont-stretch\n可选。定义该字体应该如何被拉长。默认值是”正常”\n\n\nfont-style\n可选。定义该字体应该是怎样样式。默认值是”正常”\n\n\nfont-weight\n可选。定义字体的粗细。默认值是”正常”\n\n\nunicode-range\n可选。定义该字体支持Unicode字符的范围。默认值是”ü+0-10 FFFF”\n\n\n\n\nfont-family\n定义 规定元素的字体系列。\n\n语法   font-family:”A”,B,…,C;\n\n属性值 \n\n\n\n\n值\n说明 （索引中有详细介绍）\n\n\n\nfamily-name generic-family\n用于某个元素的字体族名称或&#x2F;及类族名称的一个优先表。默认值：取决于浏览器。\n\n\ninherit\n定应该从父元素继承字体系列。\n\n\n\n\nfont-size\n定义 属性可设置字体的尺寸。\n\n语法   font-size:A|smaller|larger|length|%|inherit\n\n属性值 \n\n\n\n\n值\n说明 （索引中有详细介绍）\n\n\n\nA(xx-small、x-small、small、medium、large、x-large、xx-large)\n把字体的尺寸设置为不同的尺寸，从 xx-small 到 xx-large。默认值：medium。\n\n\nsmaller\n把 font-size 设置为比父元素更小的尺寸。\n\n\nlarger\n把 font-size 设置为比父元素更大的尺寸。\n\n\nlength\n把 font-size 设置为一个固定的值。\n\n\n%\n把 font-size 设置为基于父元素的一个百分比值。\n\n\ninherit\n定应该从父元素继承字体系列。\n\n\n\n\nfont-style\n定义 属性定义字体的风格。\n\n语法 font-style:normal|italic|oblique|inherit;\n\n属性值 \n\n\n\n\n值\n说明 （索引中有详细介绍）\n\n\n\nnormal\n默认值。浏览器显示一个标准的字体样式。\n\n\nitalic\n浏览器会显示一个斜体的字体样式。\n\n\noblique\n浏览器会显示一个倾斜的字体样式。\n\n\ninherit\n规定应该从父元素继承字体样式。\n\n\n\n\nfont-variant\n定义 属性设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写\n\n语法 font-variant:normal|small-caps|inherit;\n\n属性值 \n\n\n\n\n值\n说明 （索引中有详细介绍）\n\n\n\nnormal\n默认值。浏览器会显示一个标准的字体。\n\n\nsmall-caps\n浏览器会显示小型大写字母的字体。\n\n\ninherit\n规定应该从父元素继承 font-variant 属性的值。\n\n\n\n\nfont-weight\n定义 属性设置文本的粗细。\n\n语法 font-weight:normal|bold|bolder|lighter|100-900|inherit;\n\n属性值 \n\n\n\n\n值\n说明 （索引中有详细介绍）\n\n\n\nnormal\n默认值。定义标准的字符。\n\n\nbold\n定义粗体字符。\n\n\nbolder\n定义更粗的字符。\n\n\nlighter\n定义更细的字符。\n\n\n100、200、300、400、500、600、700、800、900\n定义由粗到细的字符。400 等同于 normal，而 700 等同于 bold。\n\n\ninherit\n规定应该从父元素继承字体的粗细。\n\n\n\n\n位置clear\n定义 属性指定段落的左侧或右侧不允许浮动的元素。\n\n语法  clear:none|left|right|both|inherit;\n\n属性值 \n\n\n\n\n值\n说明 （索引中有详细介绍）\n\n\n\nnone\n默认值。允许浮动元素出现在两侧。\n\n\nleft\n在左侧不允许浮动元素。\n\n\nright\n在右侧不允许浮动元素。\n\n\nboth\n在左右两侧均不允许浮动元素。\n\n\ninherit\n规定应该从父元素继承 clear 属性的值。\n\n\n\n\nclip\n定义 属性剪裁绝对定位元素。\n\n语法 clip:shape|auto|inherit;\n\n属性值 \n\n\n\n\n值\n说明 （索引中有详细介绍）\n\n\n\nauto\n默认值。不应用任何剪裁。\n\n\nshape\n设置元素的形状。唯一合法的形状值是：rect (top, right, bottom, left)\n\n\ninherit\n规定应该从父元素继承 clip 属性的值。\n\n\n\n\ncursor\n定义 属性定义了鼠标指针放在一个元素边界范围内时所用的光标形状\n\n语法 cursor:url|default|auto|A;\n\n属性值 \n\n\n\n\n值\n说明 （索引中有详细介绍）\n\n\n\nauto\n默认。浏览器设置的光标。\n\n\nurl\n需使用的自定义光标的 URL。注释：请在此列表的末端始终定义一种普通的光标，以防没有由 URL 定义的可用光标。\n\n\nauto\n默认。浏览器设置的光标。\n\n\ncrosshair\n光标呈现为十字线。\n\n\npointer\n光标呈现为指示链接的指针（一只手）\n\n\nmove\n此光标指示某对象可被移动。\n\n\ne-resize\n此光标指示矩形框的边缘可被向右（东）移动。\n\n\nne-resize\n此光标指示矩形框的边缘可被向上及向右移动（北&#x2F;东）。\n\n\nnw-resize\n此光标指示矩形框的边缘可被向上及向左移动（北&#x2F;西）。\n\n\nn-resize\n此光标指示矩形框的边缘可被向上（北）移动。\n\n\nse-resize\n此光标指示矩形框的边缘可被向下及向右移动（南&#x2F;东）。\n\n\nsw-resize\n此光标指示矩形框的边缘可被向下及向左移动（南&#x2F;西）。\n\n\ns-resize\n此光标指示矩形框的边缘可被向下移动（北&#x2F;西）。\n\n\nw-resize\n此光标指示矩形框的边缘可被向左移动（西）。\n\n\ntext\n此光标指示文本。\n\n\nwait\n此光标指示程序正忙（通常是一只表或沙漏）。\n\n\nhelp\n此光标指示可用的帮助（通常是一个问号或一个气球）。\n\n\n\n\ndisplay\n定义 属性规定元素应该生成的框的类型。\n\n语法 display:inline|block|A|;\n\n属性值 \n\n\n\n\n值\n说明 （索引中有详细介绍）\n\n\n\ninline\n默认。此元素会被显示为内联元素，元素前后没有换行符。\n\n\nblock\n此元素将显示为块级元素。\n\n\ncontent\n盒子文本正常绘制，而围绕在盒子中的框并不会生成。\n\n\nflex\n此元素将显示为弹性盒容器。\n\n\ngrid\n此元素将显示为栅格容器。\n\n\ninline-block\n此元素将显示为行内块元素。\n\n\ninline-flex\n此元素将显示为行内弹性盒容器。\n\n\ninline-grid\n此元素将显示为行内栅格容器。\n\n\ninline-table\n此元素会作为内联表格来显示（类似 ），表格前后没有换行符。\n\n\nlist-item\n此元素会作为列表显示。\n\n\nrun-in\n此元素会根据上下文作为块级元素或内联元素显示。\n\n\ntable\n此元素会作为块级表格来显示（类似 table元素），表格前后带有换行符。\n\n\ntable-caption\n此元素会作为一个表格标题显示（类似 caption 元素）。\n\n\ntable-column-group\n此元素会作为一个或多个列的分组来显示（类似 colgroup 元素）。\n\n\ntable-header-group\n此元素会作为一个或多个行的分组来显示（类似 thead 元素）。\n\n\ntable-footer-group\n此元素会作为一个或多个行的分组来显示（类似 tfoot 元素）。\n\n\ntable-row-group\n此元素会作为一个或多个行的分组来显示（类似 tbody 元素）。\n\n\ntable-cell\n此元素会作为一个表格单元格显示（类似 td 元素）\n\n\ntable-column\n此元素会作为一个单元格列显示（类似 col 元素）\n\n\ntable-row\n此元素会作为一个表格行显示（类似 tr 元素）。\n\n\nnone\n此元素不会被显示。\n\n\ninitial\n设置该属性为默认元素。\n\n\ninherit\n规定应该从父元素继承 display 属性的值。\n\n\n\n\nfloat\n定义 属性定义元素在哪个方向浮动。\n\n语法 float:none|left|right|inherit;\n\n属性值 \n\n\n\n\n值\n说明 （索引中有详细介绍）\n\n\n\nnone\n默认值。元素不浮动，并会显示在其在文本中出现的位置。\n\n\nleft\n元素向左浮动。\n\n\nright\n元素向右浮动。\n\n\ninherit\n规定应该从父元素继承 float 属性的值。\n\n\n\n\ntop &#x2F;right &#x2F; buttom &#x2F;left\n定义 属性规定元素的顶部 &#x2F; 右边 &#x2F; 下面 &#x2F; 左边 边缘。\n\n语法 top:auto|%|length|inherit;\n\n属性值 \n\n\n\n\n值\n说明\n\n\n\nauto\n默认值。通过浏览器计算顶边缘的位置。\n\n\n%\n设置以包含元素的百分比计的顶边位置。可使用负值。\n\n\nlength\n使用 px、cm 等单位设置元素的顶边位置。可使用负值。\n\n\ninherit\n规定应该从父元素继承 top 属性的值。\n\n\n\n\noverflow\n定义 属性规定当内容溢出元素框时发生的事情。\n\n语法 overflow:visible|hidden|scroll|auto|inherit;\n\n属性值 \n\n\n\n\n值\n说明\n\n\n\nvisible\n默认值。内容不会被修剪，会呈现在元素框之外。\n\n\nhidden\n内容会被修剪，并且其余内容是不可见的。\n\n\nscroll\n内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。\n\n\nauto\n如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。\n\n\ninherit\n规定应该从父元素继承 overflow 属性的值。\n\n\n\n\nposition\n定义 属性规定元素的定位类型。\n\n语法 position:static|absolute|relative|fixed|inherit;\n\n属性值 \n\n\n\n\n值\n说明\n\n\n\nstatic\n默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。\n\n\nabsolute\n生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。\n\n\nfixed\n生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。\n\n\nrelative\n生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。\n\n\ninherit\n规定应该从父元素继承 position 属性的值。\n\n\n\n\nvisibility\n定义 属性规定元素是否可见。\n\n语法 visibility:visible|hidden|collapse|inherit;\n\n属性值 \n\n\n\n\n值\n说明\n\n\n\nvisible\n默认值。元素是可见的。\n\n\nhidden\n元素是不可见的。\n\n\ncollapse\n当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 “hidden”。\n\n\ninherit\n规定应该从父元素继承 visibility 属性的值。\n\n\n\n\nz-index\n定义  属性设置元素的堆叠顺序。\n\n语法 z-index:auto|number|inherit;\n\n属性值 \n\n\n\n\n值\n说明\n\n\n\nauto\n默认。堆叠顺序与父元素相等。\n\n\nnumber\n设置元素的堆叠顺序。\n\n\ninherit\n规定应该从父元素继承 z-index 属性的值。\n\n\n\n\n\n定义 \n语法 \n属性值\n\n边界border-radius\n定义 属性是一个简写属性，用于设置四个 border-*-radius 属性。\n\n语法 border-radius: 1-4 length|% &#x2F; 1-4 length|%;\n\n属性值 \n\n\n\n\n值\n描述\n\n\n\nlength\n定义圆角的形状。\n\n\n%\n以百分比定义圆角的形状。\n\n\n\n\nbox-shadow\n定义 性向框添加一个或多个阴影。\n\n语法 box-shadow: h-shadow v-shadow blur spread color inset;\n\n属性值 \n\n\n\n\n值\n描述\n\n\n\nh-shadow\n必需。水平阴影的位置。允许负值。\n\n\nv-shadow\n必需。垂直阴影的位置。允许负值。\n\n\nblur\n可选。模糊距离。\n\n\nspread\n可选。阴影的尺寸。\n\n\ncolor\n可选。阴影的颜色。\n\n\ninset\n可选。将外部阴影 (outset) 改为内部阴\n\n\n\n\noutline\n定义 （轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用\n\n语法 outline:outline-color|outline-style|outline-width|inherit;\n\n属性值 \n\n\n\n\n值\n描述\n\n\n\noutline-color\n规定边框的颜色。\n\n\noutline-style\n规定边框的样式。\n\n\noutline-width\n规定边框的宽度。\n\n\ninherit\n规定应该从父元素继承 outline 属性的设置。\n\n\n\n定义 \n\n语法 \n\n属性值\n\n\n\n定义 \n语法 \n属性值\n\n\n定义 \n语法 \n属性值\n\n\n定义 \n语法 \n属性值\n\n\n定义 \n语法 \n属性值\n\n\n定义 \n语法 \n属性值\n\n\n定义 \n语法 \n属性值\n\n\n定义 \n语法 \n属性值\n\n\n定义 \n语法 \n属性值\n\n\n定义 \n语法 \n属性值\n\n\n定义 \n语法 \n属性值\n\n2d&#x2F;3dtransform\n定义 属性应用于元素的2D或3D转换。\n\n语法 transform: none|transform-functions;\n\n属性值 \n\n\n\n\n值\n说明\n\n\n\nnone\n定义不进行转换。\n\n\nmatrix(n,n,n,n,n,n)\n定义 2D 转换，使用六个值的矩阵。\n\n\nmatrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)\n定义 3D 转换，使用 16 个值的 4x4 矩阵。\n\n\ntranslate(x,y)\n定义 2D 转换。\n\n\ntranslate3d(x,y,z)\n定义 3D 转换。\n\n\ntranslateX(x)\n定义转换，只是用 X 轴的值。\n\n\ntranslateY(y)\n定义转换，只是用 Y 轴的值。\n\n\ntranslateZ(z)\n定义 3D 转换，只是用 Z 轴的值。\n\n\nscale(x[,y]?)\n定义 2D 缩放转换。\n\n\nscale3d(x,y,z)\n定义 3D 缩放转换。\n\n\nscaleX(x)\n通过设置 X 轴的值来定义缩放转换。\n\n\nscaleY(y)\n通过设置 Y 轴的值来定义缩放转换。\n\n\nscaleZ(z)\n通过设置 Z 轴的值来定义 3D 缩放转换。\n\n\nrotate(angle)\n定义 2D 旋转，在参数中规定角度。\n\n\nrotate3d(x,y,z,angle)\n定义 3D 旋转。\n\n\nrotateX(angle)\n定义沿着 X 轴的 3D 旋转。\n\n\nrotateY(angle)\n定义沿着 Y 轴的 3D 旋转。\n\n\nrotateZ(angle)\n定义沿着 Z 轴的 3D 旋转。\n\n\nskew(x-angle,y-angle)\n定义沿着 X 和 Y 轴的 2D 倾斜转换。\n\n\nskewX(angle)\n定义沿着 X 轴的 2D 倾斜转换。\n\n\nskewY(angle)\n定义沿着 Y 轴的 2D 倾斜转换。\n\n\nperspective(n)\n为 3D 转换元素定义透视视图。\n\n\n\n\ntransform-Origin\n定义 属性允许更改转换元素的位置。\n\n语法 transform-origin: x-axis y-axis z-axis;\n\n属性值 \n\n\n\n\n值\n说明\n\n\n\nx-axis\n定义视图被置于 X 轴的何处。可能的值：left、center、right、length、%\n\n\ny-axis\n定义视图被置于 Y 轴的何处。可能的值：top、center、bottom、length、%\n\n\nz-axis\n定义视图被置于 Z 轴的何处。可能的值：length\n\n\n\n\n\n定义 \n语法 \n属性值\n\n\n定义 \n语法 \n属性值\n\n\n定义 \n语法 \n属性值\n\n\n定义 \n语法 \n属性值\n\n\n定义 \n语法 \n属性值\n\n杂项知识css\ncalc(100% + 10px) 裁剪函数\nfilter: blur(2px); 模糊效果\n\n","slug":"css大全","date":"2022-08-04T11:11:49.000Z","categories_index":"小记","tags_index":"web","author_index":"yuri2078"},{"id":"dc168ae0e61f850398133451b0c7647e","title":"c++知识点补充","content":"c&#x2F;c++写代码的要求尽可能的使用const 修饰代码\n避免无意识中修改变量导致出错\n使他能够接受const 和 非const 参数\n是4程序能够正常生成 临时变量 — 引用的时候\n\n命名规则\n小驼峰 myPoint\n大驼峰 MyPoint\n匈牙利 my_point\n__  和 _开头的命令被保留给实现，一般不用\n\n不使用using namespace std\n使用 using std::cout;\n使用 using std::cin;\n\n使用容器的时候包含头文件\niostream 包含了string 但 自己还是包含一下\n\n给函数传递参数时的选择\n当传递类或者结构体这种数据量大的数据时一般选择 引用传递\n传递数组时 智能选择指针\n当传递普通数据类型的变量是 选择值传递\n\n数组的初始化\nint array[10] &#123; 1, 2, 3, 4 &#125;c11可以忽略等于号\nint array[10] &#123;&#125;c11可以直接用空括号初始化0\n列表禁止缩窄定义 比如long  -&gt;  int\n\n未完成的事情\n类型关键字\nstatic\nconst\nextern\nvolatile\nauto 自动识别类型\nregister\nthread_local\nmutable 使用这个可以修改常量函数里的变量\n\n\n\n类和对象类的基本结构class Person : public Animal &#x2F;&#x2F;继承自Animal 类\n&#123;\nprivate: &#x2F;&#x2F;访问权限\n    int x; &#x2F;&#x2F;数据成员\n   \npublic:\n    Person() &#x3D; default; &#x2F;&#x2F;默认构造函数，不写系统会自动生成\n    Person(int x); &#x2F;&#x2F;重载的构造函数\n    explicit Person(int x, int y, int z &#x3D; 0); &#x2F;&#x2F;禁止发生隐式抓换构造函数\n    Person(const Person &amp;p); &#x2F;&#x2F;拷贝构造函数 当需要拷贝的时候调用\n    Person(const Person &amp;&amp;p); &#x2F;&#x2F;移动构造函数 当需要移动数据完成构造的时候调用\n    ~Person() &#x3D; default; &#x2F;&#x2F;析构函数，不加default默认会生成一个，他没有参数\n    void printPerson(); &#x2F;&#x2F;普通成员函数\n    virtual void test(); &#x2F;&#x2F;虚函数\n    virtual void test_1() &#x3D; 0; &#x2F;&#x2F;纯虚函数，如果不重写，他的子类或者他本身无法生成对象\n    int getX() const; &#x2F;&#x2F;禁止修改数据成员，隐含 const 修饰 this指针。\n&#125;;\n\n\n\nexplicit  关键字一般用于构造函数&#x2F;拷贝构造函数 加上之后就不能发生隐式类型转换，必须指明\nclass Person\n&#123;\n    explicit Person(int x &#x3D; 0, int y &#x3D;1) &#x2F;&#x2F;添加禁止隐式转换关键字\n    &#123;\n\n    &#125;\n&#125;;\nvoid test()\n&#123;\n    Person p1 &#x3D; 3; &#x2F;&#x2F;发生隐式类型转换\n    &#x2F;&#x2F;程序处理 ： Person temp(3); p1 &#x3D; temp; \n    &#x2F;&#x2F;未来避免发生不必要的错误，使用explicit关键字禁止 隐式类型转换\n\n    &#x2F;&#x2F;加上explicit关键字后\n    &#x2F;&#x2F; Person p1 &#x3D; 3; 错误\n    &#x2F;&#x2F; Person p1 &#x3D; Person(3); 正确\n&#125;\n\n\n匿名对象调用成员函数 直接生成匿名对象，调用函数\nclass Person\n&#123;\npublic:\n    void test()\n    &#123;\n        cout &lt;&lt; &quot;hello world &quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nint main()\n&#123;\n    Person().test();\n    return 0;\n&#125;\n\n\ndefault 关键字生成一个默认的构造函数或者析构函数\nclass Person\n&#123;\n    &#x2F;&#x2F;生成默认构造函数，该函数不可重新定义\n  \tPerson() &#x3D; default; \n&#125;;\n\n\n\nnoexcept  关键字告诉编译器该函数 默认是安全的不会弹出错误\nvoid test() noexcept;\nvoid test() noexcept(true); &#x2F;&#x2F;等同于上面那个\nvoid test(); &#x2F;&#x2F;不加关键字默认是可能弹出错误\nvoid test() noexcept(false); &#x2F;&#x2F;等同于上面那个\n\n&#x2F;&#x2F;函数 声明&#x2F;定义 有一个有noexcept关键字，其他所有 声明&#x2F;定义 都要有关键字\n\noverride 关键字表示对一个virtual 函数进行重写\nclass Animal&#123;\n    virtual void eat()&#123;\n        std::cout &lt;&lt; &quot;Animal is eating\\n&quot;;\n    &#125;\n&#125;;\n\nclass Person : public Animal&#123;\n    void eat() override&#123; &#x2F;&#x2F;对虚函数进行重写\n        std::cout &lt;&lt; &quot;Person is eating\\n&quot;;\n    &#125;\n&#125;;\n\nfinal 关键字&#x2F;&#x2F;表示该类禁止被继承\nclass Person final : public Animal&#123;\n    virtual void eat() final; &#x2F;&#x2F;表示该函数禁止被子类重写\n&#125;\n\n\n\n\n常用函数补充#include &lt;limits.h&gt;保存各类型的最大值 INT_MAX\n#include &lt;stdlib.h&gt;常用申请内存函数\n\nint *num = (int *)malloc(8 * sizeof(int)); &#x2F;&#x2F;分配内存但是不重置为0 失败返回NULL\nint *num = (int *)calloc(8, sizeof(int)); &#x2F;&#x2F;分配n 个size内存 并置为0 失败返回 NULL\nnum = realloc(num, 9 * sizeof(int)); 重新分配内存可大可小\n后面空间小于 原有空间则释放多余地址\n后面空间大于 原有空间则查看后面连续地址是否有剩余 没有则把旧数据拷贝到新地址且返回新地址\n指针为NULL 且size不为0 作用和malloc类似 返回新的地址\n指针不为NULL 但是size为0  则空间会被释放 返回NULL\n空间不足 返回NULL原空间内容不变\n\n\n\n#include &lt;limits&gt;\n\n\n\n\n\n\n\n\nstd::numeric_limits 类模板来获取类型的最大值和最小值等\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n\nint main(int argc, char *argv[]) &#123;\n    std::cout &lt;&lt; &quot;long long max&quot; &lt;&lt; std::numeric_limits&lt;long long&gt;::max() &lt;&lt; std::endl; &#x2F;&#x2F; 获取long long最大值\n    std::cout &lt;&lt; &quot;long long min&quot; &lt;&lt; std::numeric_limits&lt;long long&gt;::min() &lt;&lt; std::endl;\n    \n    std::cout &lt;&lt; &quot;int max&quot; &lt;&lt; std::numeric_limits&lt;long long&gt;::max() &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;int min&quot; &lt;&lt; std::numeric_limits&lt;long long&gt;::min() &lt;&lt; std::endl;\n&#125;\n\n\n\n\n常见关键字补充const 关键字#include &lt;iostream&gt;\n\nint main(int argc, char const *argv[])\n&#123;\n    int x &#x3D; 666, b &#x3D; 666;\n    int *p;\n\n    const int *point &#x3D; &amp;x; &#x2F;&#x2F;const 在左边表示他指向的值不能修改\n    &#x2F;&#x2F; *point &#x3D; 666; &#x2F;&#x2F;不能修改，报错\n    point &#x3D; &amp;b; &#x2F;&#x2F;可以修改\n\n    int *const point_2 &#x3D; &amp;x;\n    *point_2 &#x3D; 666;\n    &#x2F;&#x2F; point_2 &#x3D; &amp;b; &#x2F;&#x2F;不能修改，报错\n\n    const int temp &#x3D; 666;\n\n    return 0;\n&#125;\n\n总结：\n\nconst 加在类型的前面则表示后面的值不能修改 const int *point = &amp;x;\n\n不能通过point 修改 x 的值\n可以修改point 指向的值\n\n\nconst 加在类型的后面则表示这个变量不能修改int *const point_2 = &amp;x;\n\n可以通过point_2 修改x的值\n不能修改point_2 指向的值\n\n\n尽量加const 这样可以接受const的值，普通变量是不能接受const的值的\n\n\nauto 关键字自动识别数据类型\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing std::cout;\nusing std::endl;\nusing std::vector;\n\nclass Student\n&#123;\n\nprivate:\n  int age;\n\npublic:\n  explicit Student()\n  &#123;\n    age &#x3D; 666;\n  &#125;\n\n&#125;;\n\nint main(int argc, char **argv)\n&#123;\n    vector&lt;int&gt; v1;\n    for(int i &#x3D; 0; i &lt; 10; i++)&#123;\n      v1.push_back(i);\n    &#125;\n\n    &#x2F;&#x2F;自动识别迭代器类型\n    for (auto begin &#x3D; v1.begin(); begin !&#x3D; v1.end(); begin++)\n    &#123;\n      cout &lt;&lt; *begin &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n    for (vector&lt;int&gt;::iterator begin &#x3D; v1.begin(); begin !&#x3D; v1.end(); begin++)\n    &#123;\n      cout &lt;&lt; *begin &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    auto &amp;hell &#x3D; v1;\n    cout &lt;&lt; &quot;hello &quot; &lt;&lt; hell[0] &lt;&lt; endl;\n    return 0;\n&#125;\n\n\n&amp;&amp; 右值引用符号宏定义知识点补充\n#号 转化成字符串\n#define STR(s) #s &#x2F;&#x2F;将s转化成字符串\nSTR(sss) &#x2F;&#x2F;结果 &quot;sss&quot;\n\n\n\n## 连接前后两个 \n#define CAT(a,b) a##e##b &#x2F;&#x2F;CAT(2,10) 结果2e10 也就是 2的十次方\n\n\n\n\n\n指针知识补充函数指针智能指针\nstd::unique_ptr 独占指针\n在任何给定的时刻只能有一指针管理内存\n在超出作用域后，指针将会释放内存\n只能move 不能 copy\n\n\nstd::shard_ptr 计数指针\n他可以copy\n可以计数 赋值一次 计数器加一，销毁一次计数器减一\nunique_ptr 可以传递给shard_ptr 但是shard不能传递给unique_ptr\n拥有计数方法 .use_count() 统计指针被复制的次数。 被删除一次则加一\n\n\nstd::weak_ptr \n没有所有权\n不能解引用和使用箭头函数\n一般用于标识别的对象信息，用shard和unique会释放掉内存\n\n\n\n详细列子\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nclass Person\n&#123;\nprivate:\n    \npublic:\n    std::string name&#123;&quot;hello&quot;&#125;;\n    \n    Person(); &#x2F;&#x2F;默认调用函数\n    Person(const std::string &amp;name);\n    void set_name(const std::string &amp;name);\n    ~Person();\n    Person(const Person &amp;&amp;p);\n&#125;;\n\nPerson::Person() \n&#123;\n    std::cout &lt;&lt; &quot;name : &quot; &lt;&lt; name &lt;&lt; &quot;  Person 类创建\\n&quot;;\n&#125;\n\nPerson::Person(const std::string &amp;name) : name(name)\n&#123;\n    std::cout &lt;&lt; &quot;name : &quot; &lt;&lt; name &lt;&lt; &quot;  Person 类创建\\n&quot;;\n&#125;\n\nPerson::~Person()\n&#123;\n    std::cout &lt;&lt; &quot;name : &quot; &lt;&lt; name &lt;&lt; &quot;  Person 类析构\\n&quot;;\n&#125;\n\nvoid Person::set_name(const std::string &amp;name)\n&#123;\n    this-&gt;name &#x3D; name;\n&#125;\nPerson::Person(const Person &amp;&amp;p)\n&#123;\n    std::cout &lt;&lt; &quot;移动构造函数调用\\n&quot;;\n    this-&gt;name &#x3D; p.name;\n&#125;\n\nvoid test_0()\n&#123;\n    Person p1; &#x2F;&#x2F;会自己调用析构函数\n    Person *p2 &#x3D; new Person; &#x2F;&#x2F;不会自己调用析构函数\n    delete p2; &#x2F;&#x2F;需要自己调用\n&#125;\n\nvoid unique_ptr()\n&#123;\n    &#x2F;&#x2F;创建方式1 使用原始指针创建\n    Person *p &#x3D; new Person;\n    std::unique_ptr&lt;Person&gt; u_p&#123;p&#125;; &#x2F;&#x2F;通过原始指针创建\n\n    &#x2F;&#x2F;独占指针需要满足条件1 这里两个都能调用不满足，把它指向空\n    p &#x3D; nullptr;\n\n    std::cout &lt;&lt; &quot;u_p : name --- &quot; &lt;&lt; u_p-&gt;name &lt;&lt; std::endl; &#x2F;&#x2F;正常调用，函数结束后自己会调用析构函数\n\n    \n    &#x2F;&#x2F;创建方式2 使用new 创建\n    std::unique_ptr&lt;Person&gt; u_p_2&#123;new Person(&quot;yuri&quot;)&#125;;\n    \n    &#x2F;&#x2F;创建方式3 使用std::make 创建\n\n    std::unique_ptr&lt;Person&gt; u_p_3 &#x3D;  std::make_unique&lt;Person&gt;(&quot;yuri is yes&quot;);\n\n    std::cout &lt;&lt; &quot;u_p_2.get() : &quot; &lt;&lt; u_p_2.get() &lt;&lt; std::endl; &#x2F;&#x2F;打印地址\n    &#x2F;&#x2F;打印的是指针指向的地址，而不是&amp; 打印指针的地址\n\n    std::unique_ptr&lt;Person&gt; up &#x3D; std::make_unique&lt;Person&gt;(&quot;yuri&quot;);\n    auto hello &#x3D; std::move(up); &#x2F;&#x2F;只能通过move使用\n    &#x2F;&#x2F; auto hello &#x3D; up; 报错，无法复制，只能move\n&#125;\n\nvoid shared_ptr()\n&#123;\n    std::shared_ptr&lt;int&gt; int_1 &#x3D; std::make_shared&lt;int&gt;(100);\n    std::cout &lt;&lt; &quot;(1 cout &#x3D; &quot; &lt;&lt; int_1.use_count() &lt;&lt; std::endl;\n    auto int_2 &#x3D; int_1; &#x2F;&#x2F;复制一次计数器加一\n    std::cout &lt;&lt; &quot;(1 cout &#x3D; &quot; &lt;&lt; int_1.use_count() &lt;&lt; std::endl; &#x2F;&#x2F;指向同一个地方，计数器都变成2\n    std::cout &lt;&lt; &quot;(2 cout &#x3D; &quot; &lt;&lt; int_2.use_count() &lt;&lt; std::endl;\n\n    int_1.reset(); &#x2F;&#x2F;释放一次\n    std::cout &lt;&lt; &quot;(1 cout &#x3D; &quot; &lt;&lt; int_1.use_count() &lt;&lt; std::endl; &#x2F;&#x2F;已经删除了，计数器编程0\n    std::cout &lt;&lt; &quot;(2 cout &#x3D; &quot; &lt;&lt; int_2.use_count() &lt;&lt; std::endl; &#x2F;&#x2F;这里不变，因为原来的删除，所以减一变成0了\n    &#x2F;&#x2F;在函数里面调用的时候会加一，出来之后又会不变\n&#125;\n\nvoid weak_ptr()\n&#123;\n    &#x2F;&#x2F;没有所有权\n    &#x2F;&#x2F;不能解引用和使用箭头函数\n    &#x2F;&#x2F;一般用于标识别的对象信息，用shard和unique会释放掉内存\n    auto p &#x3D; std::make_shared&lt;Person&gt;();\n    std::weak_ptr&lt;Person&gt; weak_p(p);\n    &#x2F;&#x2F; p-&gt;name; 错误无法调用\n    \n&#125;\n\nint main(int argc, char const *argv[])\n&#123;\n    unique_ptr(); &#x2F;&#x2F;独占指针\n    shared_ptr(); &#x2F;&#x2F;计数指针\n    return 0;\n&#125;\n\n","slug":"c++知识点补充","date":"2022-08-04T11:10:31.000Z","categories_index":"c/c++","tags_index":"c/c++","author_index":"yuri2078"},{"id":"a190eeed437f3803134f7d0fcd279e47","title":"linux常用命令","content":"安装软件\nsudo apt-get  update\nsudo apt-get uprdge\nsudo apt upgrade -y 升级系统包\nsudo apt install ..deb 安装软件\nsudo dpkg -i …deb 安装应用\nmkdir hello 创建文件夹\ntouch hello.txt 创建文件\nsudo apt purge netease-cloud-music 卸载软件\nsudo apt list –installed 列出apt包\nsnap list列出snap包\ndpkg –list 列出所有安装的包\nsudo aptitude install packer 防止出现依赖不足\nsudo apt dist-upgrade 不知道是干啥的\ngnome-session-properties  设置程序自己启动\nzip -r hh.zip hh 压缩文件\nunzip hh.zip解压文件\n\n软件权限相关\nls -l .. 查看具有的属性\nchmod +x … 添加属性\nsudo chown -R $(whoami) &#x2F;usr&#x2F;share&#x2F;code 设置管理员权限\n\n环境变量PATH\necho $PATH 查看环境变量path的内容\nsudo vi &#x2F;etc&#x2F;environment PATH 用：隔开\n\n清华镜像\n&#x2F;etc&#x2F;apt&#x2F;sources.list\n\nhttps://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/\n","slug":"linux常用命令","date":"2022-08-02T14:43:33.000Z","categories_index":"小记","tags_index":"常用命令,linux","author_index":"yuri2078"},{"id":"32aa9907fa494b367a751b336ad0976b","title":"贪吃蛇","content":"c语言版本#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n#include &lt;time.h&gt;\n#include &lt;conio.h&gt;\nstruct Snake &#x2F;&#x2F;定义蛇蛇结构体\n&#123;\n    short int x; &#x2F;&#x2F;横坐标\n    short int y; &#x2F;&#x2F;纵坐标\n    struct Snake *next; &#x2F;&#x2F;下一条蛇的地址\n&#125;;\n\nvoid Setxy(short int x,short int y) &#x2F;&#x2F;将光标定位\n&#123;\n    COORD head &#x3D; &#123;x, y&#125;; &#x2F;&#x2F;设置坐标\n    HANDLE Cmd &#x3D; GetStdHandle(STD_OUTPUT_HANDLE); &#x2F;&#x2F;获取控制台句柄\n    SetConsoleCursorPosition(Cmd, head); &#x2F;&#x2F;设置光标位置\n&#125;\n\nvoid HideCursor()\n&#123;\n    HANDLE handle &#x3D; GetStdHandle(STD_OUTPUT_HANDLE); &#x2F;&#x2F;获取句柄\n    CONSOLE_CURSOR_INFO CursorInfo;\n    GetConsoleCursorInfo(handle, &amp;CursorInfo);&#x2F;&#x2F;获取控制台光标信息\n    CursorInfo.bVisible &#x3D; FALSE; &#x2F;&#x2F;隐藏控制台光标\n    SetConsoleCursorInfo(handle, &amp;CursorInfo);&#x2F;&#x2F;设置控制台光标状态\n&#125;\n\nvoid GameStart() &#x2F;&#x2F;游戏开始界面\n&#123;\n    system(&quot;mode con cols&#x3D;150 lines&#x3D;50&quot;); &#x2F;&#x2F;设置窗口大小\n    for (int i &#x3D; 0; i &lt; 150; i++)\n    &#123;\n        printf(&quot;■&quot;);\n    &#125;\n    Setxy(65, 15);\n    printf(&quot;欢迎你来到贪吃蛇游戏&quot;);\n    HideCursor();\n    Setxy(0, 48);\n    for (int i &#x3D; 0; i &lt; 150; i++)\n    &#123;\n        printf(&quot;■&quot;);\n    &#125;\n    Setxy(66, 40);\n&#125;\n\nvoid PrintSnake(struct Snake *head)\n&#123;\n    while(head)\n    &#123;\n        Setxy(head-&gt;x, head-&gt;y);\n        printf(&quot;■&quot;);\n        head &#x3D; head-&gt;next;\n    &#125;\n&#125;\n\nstruct Snake * Setsnake(void)\n&#123;\n    struct Snake *head,*temp; &#x2F;&#x2F;初始化蛇蛇\n    head &#x3D; (struct Snake *)malloc(sizeof(struct Snake));\n    head-&gt;x &#x3D; 10; &#x2F;&#x2F;起点横坐标\n    head-&gt;y &#x3D; 30; &#x2F;&#x2F;起点纵坐标\n    temp &#x3D; head;\n    for (int i &#x3D; 0; i &lt; 5;i++) &#x2F;&#x2F;接连生成5个\n    &#123;\n        temp-&gt;next &#x3D; (struct Snake *)malloc(sizeof(struct Snake));\n        temp &#x3D; temp-&gt;next;\n        temp-&gt;x &#x3D; 12 + i*2;\n        temp-&gt;y &#x3D; 30;\n    &#125;\n    temp-&gt;next &#x3D; NULL;\n    return head; &#x2F;&#x2F;返回生成的新蛇头\n&#125;\n\nvoid Setmap(void)\n&#123;\n    for (int i &#x3D; 0; i &lt; 150;i&#x3D;i+2)\n    &#123;\n        for (int j &#x3D; 0; j &lt; 50;j++)\n        &#123;\n            if(i &#x3D;&#x3D; 0 || i &#x3D;&#x3D; 148 || j &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 49)\n            &#123;\n                Setxy(i, j);\n                printf(&quot;■&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nvoid Setfood(struct Snake *food, int flag)\n&#123;\n    if(flag)\n    &#123;\n        srand((unsigned)time(NULL));\n        food-&gt;x &#x3D; (rand() % 75) * 2;\n        food-&gt;y &#x3D; rand() % 50;\n        &#x2F;&#x2F;防止生成到地图上\n        while(food-&gt;y &#x3D;&#x3D; 0 || food-&gt;y &#x3D;&#x3D; 49 || food-&gt;x &#x3D;&#x3D; 0 || food-&gt;x &#x3D;&#x3D; 148)\n        &#123;\n            food-&gt;x &#x3D; (rand() % 75) * 2;\n            food-&gt;y &#x3D; rand() % 50;\n        &#125;\n    &#125;\n    else\n    &#123;\n        Setxy(food-&gt;x,food-&gt;y);\n        printf(&quot;■&quot;);\n    &#125;\n&#125;\n\nint CheckSnake(struct Snake * head, struct Snake * tail)\n&#123;\n    while(head-&gt;next)\n    &#123;\n        &#x2F;&#x2F;碰到自己和碰到地图都会失败\n        if ((head-&gt;x &#x3D;&#x3D; tail-&gt;x &amp;&amp; head-&gt;y &#x3D;&#x3D; tail-&gt;y) || tail-&gt;y &#x3D;&#x3D; 0 || tail-&gt;y &#x3D;&#x3D; 49 || tail-&gt;x &#x3D;&#x3D; 0 || tail-&gt;x &#x3D;&#x3D; 148)\n        &#123;\n            return 1;\n        &#125;\n        head &#x3D; head-&gt;next;\n    &#125;\n    return 0;\n&#125;\n\nvoid Relase(struct Snake * head)\n&#123;\n    struct Snake *temp;\n    while(head)\n    &#123;\n        temp &#x3D; head;\n        head &#x3D; head-&gt;next;\n        free(temp);\n    &#125;\n&#125;\n\nvoid Game(void) &#x2F;&#x2F;游戏主体\n&#123;\n    char ch &#x3D; &#39;d&#39;; &#x2F;&#x2F;默认移动方向为右\n    int i &#x3D; 2, j &#x3D; 0, point&#x3D;0;\n    GameStart(); &#x2F;&#x2F;打印开始欢迎界面\n    system(&quot;pause&quot;); &#x2F;&#x2F;暂停一下，按任意键开始\n    struct Snake *snakeHead, *temp, *tail, *food&#x3D;(struct Snake *)malloc(sizeof(struct Snake));\n    Setfood(food, 1); &#x2F;&#x2F;生成蛇蛇的食物\n    snakeHead &#x3D; Setsnake(); &#x2F;&#x2F;生成小蛇蛇\n    tail &#x3D; snakeHead; &#x2F;&#x2F;计算蛇尾\n    while(tail-&gt;next)\n    &#123;\n        tail &#x3D; tail-&gt;next;\n    &#125;\n    &#x2F;&#x2F;游戏开始\n    while(1)\n    &#123;\n        system(&quot;cls&quot;); &#x2F;&#x2F;清空屏幕\n        Setmap(); &#x2F;&#x2F;开始打印地图框架\n        Setfood(food,0); &#x2F;&#x2F;打印食物\n        if (kbhit()) &#x2F;&#x2F;检测键盘输入\n        &#123;\n            ch&#x3D;getch(); &#x2F;&#x2F; 将键盘输入赋值给ch，并且不同回车确定\n            if(ch &#x3D;&#x3D; &#39;w&#39;)  &#x2F;&#x2F;上\n            &#123;\n                i &#x3D; 0;\n                j &#x3D; -1;\n            &#125;\n            else if(ch &#x3D;&#x3D;  &#39;s&#39;) &#x2F;&#x2F;下\n            &#123;\n                i &#x3D; 0;\n                j &#x3D; 1;\n            &#125;\n            else if(ch &#x3D;&#x3D;  &#39;a&#39;) &#x2F;&#x2F;左\n            &#123;\n                i &#x3D; -2;\n                j &#x3D; 0;\n            &#125;\n            else if(ch &#x3D;&#x3D;  &#39;d&#39;) &#x2F;&#x2F;右\n            &#123;\n                i &#x3D; 2;\n                j &#x3D; 0;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 每次移动产生新的坐标\n        temp &#x3D; snakeHead; &#x2F;&#x2F;更改蛇头的坐标使他成为新的蛇尾，不断重复\n        snakeHead &#x3D; snakeHead-&gt;next;\n        tail-&gt;next &#x3D; temp;\n        temp-&gt;x &#x3D; tail-&gt;x +i;\n        temp-&gt;y &#x3D; tail-&gt;y +j;\n        tail &#x3D; tail-&gt;next;\n        tail-&gt;next &#x3D; NULL;\n        if(CheckSnake(snakeHead,tail)) &#x2F;&#x2F;出现碰撞，游戏结束\n        &#123;\n            system(&quot;cls&quot;);\n            Setmap();\n            Setxy(65, 20);\n            printf(&quot;game is over\\n&quot;);\n            Setxy(65, 23);\n            printf(&quot;总共得分: %d 分\\n&quot;, point);\n            break;\n        &#125;\n        if (food-&gt;x &#x3D;&#x3D; snakeHead-&gt;x &amp;&amp; food-&gt;y &#x3D;&#x3D; snakeHead-&gt;y)\n        &#123;\n            temp &#x3D; tail;\n            point++; &#x2F;&#x2F;分数加1\n            tail &#x3D; (struct Snake *)malloc(sizeof(struct Snake));&#x2F;&#x2F;生成新的蛇尾\n            tail-&gt;x &#x3D; temp-&gt;x +i; \n            tail-&gt;y &#x3D; temp-&gt;y +j;\n            temp-&gt;next &#x3D; tail; &#x2F;&#x2F;蛇尾变成新的蛇尾\n            tail-&gt;next &#x3D; NULL; &#x2F;&#x2F;蛇尾的next为NULL\n            Setfood(food, 1); &#x2F;&#x2F;产生新的蛇头\n            Setfood(food, 0); &#x2F;&#x2F;打印新的蛇头\n        &#125;\n        PrintSnake(snakeHead); &#x2F;&#x2F;打印蛇身\n        Sleep(150);\n    &#125;\n    Setxy(65, 26);\n    system(&quot;pause&quot;); &#x2F;&#x2F;游戏结束暂停\n    Relase(snakeHead); &#x2F;&#x2F;游戏结束回收小蛇蛇\n&#125;\n\nint main(void)\n&#123;\n    &#x2F;&#x2F;所有用到的函数\n    void GameStart(); &#x2F;&#x2F;游戏开始界面\n    void Setxy(short int x, short int y); &#x2F;&#x2F;定义设置坐标函数\n    void HideCursor(); &#x2F;&#x2F;隐藏光标\n    void Setmap(); &#x2F;&#x2F;打印地图\n    void PrintSnake(struct Snake * head); &#x2F;&#x2F;打印小蛇蛇\n    struct Snake *Setsnake(void); &#x2F;&#x2F;生成小蛇蛇\n    int CheckSnake(struct Snake * head, struct Snake * tail); &#x2F;&#x2F;检查蛇蛇有没有撞到自己\n    void Relase(struct Snake * head); &#x2F;&#x2F;回收自己产生所有空间\n\n    &#x2F;&#x2F;运行的函数\n    Game(); &#x2F;&#x2F;开始游戏\n    return 0;\n&#125;\n\nc++ 版本#include &lt;iostream&gt;\n#include &lt;windows.h&gt;\n#include &lt;time.h&gt;\n#include &lt;conio.h&gt;\nint i &#x3D; 2, j &#x3D; 0, len &#x3D; 6;\nclass Snake \n&#123;\nprivate:\n    int x; &#x2F;&#x2F;横坐标\n    int y; &#x2F;&#x2F;纵坐标\npublic:\n    Snake(int xx, int yy);\n    Snake();\n    void PrintSnake(Snake snake[1000]);\n    void ChangeSnake(Snake snake[1000]);\n    void Setfood(int flag);\n    void CheckSnake(Snake snake[1000]);\n    void Running(Snake snake[1000]);\n    int GameOver(Snake snake[1000]);\n&#125;;\n\nSnake::Snake(int xx, int yy)\n&#123;\n    x &#x3D; xx;\n    y &#x3D; yy;\n&#125;\n\nSnake::Snake()\n&#123;\n\n&#125;\n\nvoid Setxy(short int x,short int y) &#x2F;&#x2F;将光标定位\n&#123;\n    COORD head &#x3D; &#123;x, y&#125;; &#x2F;&#x2F;设置坐标\n    HANDLE Cmd &#x3D; GetStdHandle(STD_OUTPUT_HANDLE); &#x2F;&#x2F;获取控制台句柄\n    SetConsoleCursorPosition(Cmd, head); &#x2F;&#x2F;设置光标位置\n&#125;\n\nvoid HideCursor()\n&#123;\n    HANDLE handle &#x3D; GetStdHandle(STD_OUTPUT_HANDLE); &#x2F;&#x2F;获取句柄\n    CONSOLE_CURSOR_INFO CursorInfo;\n    GetConsoleCursorInfo(handle, &amp;CursorInfo);&#x2F;&#x2F;获取控制台光标信息\n    CursorInfo.bVisible &#x3D; FALSE; &#x2F;&#x2F;隐藏控制台光标\n    SetConsoleCursorInfo(handle, &amp;CursorInfo);&#x2F;&#x2F;设置控制台光标状态\n&#125;\n\nvoid SetMap(void)\n&#123;\n    for (int i &#x3D; 0; i &lt; 100;i&#x3D;i+2)\n    &#123;\n        for (int j &#x3D; 0; j &lt; 50;j++)\n        &#123;\n            if(i*j &#x3D;&#x3D; 0 || i &#x3D;&#x3D; 98 || j &#x3D;&#x3D; 49)\n            &#123;\n                Setxy(i, j);\n                std::cout &lt;&lt; &quot;■&quot;;\n            &#125;\n        &#125;\n    &#125;\n    Setxy(115, 8);\n    std::cout &lt;&lt; &quot;欢迎来到贪吃蛇小游戏&quot;;\n    Setxy(117, 12);\n    std::cout &lt;&lt; &quot;  W 键 向上移动&quot;;\n    Setxy(117, 14);\n    std::cout &lt;&lt; &quot;  S 键 向下移动&quot;;\n    Setxy(117, 16);\n    std::cout &lt;&lt; &quot;  A 键 向左移动&quot;;\n    Setxy(117, 18);\n    std::cout &lt;&lt; &quot;  D 键 向右移动&quot;;\n    Setxy(116, 30);\n    std::cout &lt;&lt; &quot;当前你一共得了 &quot; &lt;&lt; len - 6 &lt;&lt; &quot; 分！&quot;;\n&#125;\n\nvoid Snake::PrintSnake(Snake snake[1000])\n&#123;\n    for (int i &#x3D; 0; i &lt; len;i++)\n    &#123;\n        Setxy(snake[i].x, snake[i].y);\n        std::cout &lt;&lt; &quot;■&quot;;\n    &#125;\n&#125;\n\nvoid Snake::ChangeSnake(Snake snake[1000])\n&#123;\n    for (int k &#x3D; 0; k &lt; len-1;k++)\n    &#123;\n        snake[k].x &#x3D; snake[k+1].x;\n        snake[k].y &#x3D; snake[k+1].y;\n    &#125;\n    snake[len - 1].x &#x3D; snake[len - 2].x + i;\n    snake[len - 1].y &#x3D; snake[len - 2].y + j;\n&#125;\n\nvoid Snake::Setfood(int flag)\n&#123;\n    if(flag)\n    &#123;\n        srand((unsigned)time(NULL));\n        x &#x3D; (rand() % 50) * 2;\n        y &#x3D; rand() % 50;\n        &#x2F;&#x2F;防止生成到地图上\n        while(y * x &#x3D;&#x3D; 0 || x &#x3D;&#x3D; 98  || y &#x3D;&#x3D; 49)\n        &#123;\n            x &#x3D; (rand() % 50) * 2;\n            y &#x3D; rand() % 50;\n        &#125;\n    &#125;\n    else\n    &#123;\n        Setxy(x,y);\n        std::cout &lt;&lt; &quot;■&quot;;\n    &#125;\n&#125;\n\nvoid Snake::CheckSnake(Snake snake[1000])\n&#123;\n    if((x &#x3D;&#x3D; (snake[len-1].x + i)) &amp;&amp; (y &#x3D;&#x3D; (snake[len-1].y + j)))\n    &#123;\n        snake[len].x &#x3D; x;\n        snake[len].y &#x3D; y;\n        Setfood(1);\n        Setfood(0);\n        len++;\n    &#125;\n&#125;\n\nint Snake::GameOver(Snake snake[1000])\n&#123;\n    for (int i &#x3D; 0; i &lt; len - 1;i++)\n    &#123;\n        if(((x &#x3D;&#x3D; snake[i].x) &amp;&amp; (y &#x3D;&#x3D; snake[i].y)) || x *y &#x3D;&#x3D;0 || x &#x3D;&#x3D; 98 || y &#x3D;&#x3D;49)\n        &#123;\n            return 1;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n\nvoid Snake::Running(Snake snake[1000])\n&#123;\n    \n    Snake food;\n    food.Setfood(1);\n    char ch &#x3D; &#39;d&#39;;\n    while(1)\n    &#123;\n        system(&quot;cls&quot;);\n        SetMap();\n        food.Setfood(0);\n        if(kbhit())\n        &#123;\n            ch &#x3D; getch();\n            if(ch &#x3D;&#x3D; &#39;w&#39;)  &#x2F;&#x2F;上\n            &#123;\n                i &#x3D; 0;\n                j &#x3D; -1;\n            &#125;\n            else if(ch &#x3D;&#x3D;  &#39;s&#39;) &#x2F;&#x2F;下\n            &#123;\n                i &#x3D; 0;\n                j &#x3D; 1;\n            &#125;\n            else if(ch &#x3D;&#x3D;  &#39;a&#39;) &#x2F;&#x2F;左\n            &#123;\n                i &#x3D; -2;\n                j &#x3D; 0;\n            &#125;\n            else if(ch &#x3D;&#x3D;  &#39;d&#39;) &#x2F;&#x2F;右\n            &#123;\n                i &#x3D; 2;\n                j &#x3D; 0;\n            &#125;\n        &#125;\n        food.CheckSnake(snake);\n        snake[0].ChangeSnake(snake);\n        PrintSnake(snake);\n        Sleep(300);\n        if(snake[len-1].GameOver(snake))\n        &#123;\n            system(&quot;cls&quot;);\n            SetMap();\n            Setxy(44, 30);\n            std::cout &lt;&lt; &quot;游戏结束！&quot;;\n            getch();\n            break;\n        &#125;\n    &#125;\n&#125;\n\nvoid GameStart() &#x2F;&#x2F;游戏开始界面\n&#123;\n    system(&quot;mode con cols&#x3D;150 lines&#x3D;50&quot;); &#x2F;&#x2F;设置窗口大小\n    HideCursor();\n    SetMap();\n    Snake snake[1000] &#x3D; &#123;\n        &#123;20,30&#125;,\n        &#123;22,30&#125;,\n        &#123;24,30&#125;,\n        &#123;26,30&#125;,\n        &#123;28,30&#125;,\n        &#123;30,30&#125;,\n    &#125;;\n    Setxy(117, 25);\n    std::cout &lt;&lt; &quot;按下任意键开始游戏&quot;;\n    getch();\n    snake[0].Running(snake);\n&#125;\n\nint main()\n&#123;\n    GameStart();\n    return 0;\n&#125;\n\n","slug":"贪吃蛇","date":"2022-04-03T04:50:53.399Z","categories_index":"c/c++","tags_index":"c/c++","author_index":"yuri2078"},{"id":"50604dfa48ccad311782bbc66ef231c6","title":"c++的输入输出","content":"cerr 和 clog 用于特定场合的输出c++中仍然可以使用c语言的printf 和 scanf 但是c++新增了cin 和 cout\ncin 输入流1 cin &gt;&gt; 变量名;   变量是什么类型接收的就是什么类型，可以接收多个变量\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n&#123;\n    int x;\n    float y;\n    cin &gt;&gt; x &gt;&gt; y;&#x2F;&#x2F;从键盘接收数据\n    cout &lt;&lt; x &lt;&lt; endl &lt;&lt; y; &#x2F;&#x2F;打印x,y的值\n    return 0;\n&#125;\n\n注意(1): 列入语句 float x;char ch;cin &gt;&gt; x &gt;&gt; ch;cin 同时读取实数和字符时 若输入 123 f时，不会读取空格给字符ch.而是把后面的f赋值给ch。回车也是同理的。会自动忽略输入的所有回车和空格。且若输入3.这种类型的，’.’也会直接忽略。(2): 若接收字符串和字符时，不会接收回车和空格。\n2 cin.get() &#x2F;&#x2F; 从输入流中接收一个字符。并且该字符会消失。\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n&#123;\n    char ch;\n    cin.get();\n    cin &gt;&gt; ch;\n    cout &lt;&lt; ch &lt;&lt; endl;\n    &#x2F;&#x2F;输入ch，打印结果为h\n    return 0;\n&#125;\n\n3 cin.ignore(长度，字符) 忽略多少长的的输入直到遇到’字符’\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n&#123;\n    char ch;\n    cin.ignore(10, &#39;.&#39;);\n    &#x2F;&#x2F;忽略输入的10个字符，直到遇到&#39;.&#39;\n    cin &gt;&gt; ch;\n    cout &lt;&lt; ch &lt;&lt; endl;\n    return 0;\n&#125;\n\n注意_1（1）：当遇到符合条件的字符时，会一起忽略符合条件的字符，并不是遇到该字符就停止忽略，该字符也会被忽略。\n（2）：类如语句 cin.ignore(10,’.’) 如果输入11个字符，而前十个字符不是’.’，但是第11个正好是’.’，此时会连同第十一个的’.’一同忽略。第十二个则不受影响 (3): 如果不填写参数，则忽略第一个字符等价 cin.ignore(1,EOF）；\n4 cin.peek() 观测输入流的一个字符，观测完了又放回去，并不会删除它，也就是说，它只是取出来看看，并不会导致当前指向的字符变成下一个。\n举例：输入一串字符串，遇到’.’结束，并将他们打印输出。\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n&#123;\n    char ch;\n    while (cin.peek() !&#x3D; &#39;.&#39;)\n    &#x2F;&#x2F;读取输入流中的第一个数据，然后放回\n    &#x2F;&#x2F;这里读取的数据不会影响下面的读取\n    &#123;\n        ch &#x3D; cin.get();\n        cout &lt;&lt; ch;\n    &#125;\n    &#x2F;&#x2F;输入hello c. 打印结果为hello c\n    return 0;\n&#125;\n\n5 cin.getline(str，n，ch) 从输入流接收长度为n-1的字符串，遇到字符ch停止并且存储在数组str中。ch默认为’\\0’。可以不写\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n&#123;\n    char str[80];\n    char ch,x;\n    cin &gt;&gt; x;\n    &#x2F;&#x2F;从键盘中指定停止的字符x\n    cin.getline(str,80,x);\n    &#x2F;&#x2F;遇到x停止接收，并把x转为\\0存储起来\n    &#x2F;&#x2F;输入流中的x会消失，并不会影响接下来的输入\n    cout &lt;&lt; str &lt;&lt; endl;\n    cin.get(ch);\n    cout &lt;&lt; &quot;ch : &quot; &lt;&lt; ch;\n    return 0;\n&#125;\n\n注意_2若指定的长度过短，则会影响后续的输入。所以在指定输入长度的时候需要大于或等于第一次出现停止字符的位置。\n6 cin.gcount() 返回上次读取的字符个数，包括\\0。需要和get()、getline()、ignore()、peek()、read()、readsome()、putback()  unget() 等函数联用。不可以直接和cin &gt;&gt; 数组名，联用。\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n&#123;\n    char str[80];\n    cin.getline(str, 80);\n    &#x2F;&#x2F;读取字符\n    cout &lt;&lt; &quot;上次读取了&quot; &lt;&lt; cin.gcount() &lt;&lt; &quot;个字符&quot; &lt;&lt; endl;\n    return 0;\n&#125;\n\ncout 输出流#include &lt;iostream&gt;\nusing namespace std;\nint main()\n&#123;\n    cout.width(10);&#x2F;&#x2F;设置宽度为10 等价于setw(10)\n    cout.fill(&#39;*&#39;);&#x2F;&#x2F;设置空白填充为&#39;*&#39;\n    &#x2F;&#x2F;设置左对齐\n    cout.setf(ios_base::left); &#x2F;&#x2F;等价于 cout &lt;&lt; setiosflags(ios::right)\n    cout &lt;&lt; 3.1415926 &lt;&lt; endl;\n    &#x2F;&#x2F;清除左对齐状态，默认是右对齐\n    cout.unsetf(ios_base::left);&#x2F;&#x2F;等价于 cout &lt;&lt; resetiosflags(ios::right);\n    cout.width(20);&#x2F;&#x2F;若不重新指定宽度，后面将默认输出\n    cout &lt;&lt; 3.1415926 &lt;&lt; endl;\n    &#x2F;&#x2F;若不指定填空字符，默认为上一次指定的字符。\n    cout.setf(ios_base::showpoint);&#x2F;&#x2F;以一般实数方式显示,默认保留五位小数\n    cout.precision(6);&#x2F;&#x2F;除小数点外保留6位有效数字\n    cout &lt;&lt; 3.1415926 &lt;&lt; endl;\n    cout.setf(ios_base::scientific);&#x2F;&#x2F;以科学计数法显示，默认保留6位小数\n    cout &lt;&lt; 3.1415926 &lt;&lt; endl;\n    cout.precision(6);&#x2F;&#x2F;e后面保留6位小数\n    cout &lt;&lt; 3.1415926 &lt;&lt; endl;\n    cout &lt;&lt; hex &lt;&lt; 123 &lt;&lt; endl;&#x2F;&#x2F;以十六进制输出\n    cout &lt;&lt; dec &lt;&lt; 123 &lt;&lt; endl;&#x2F;&#x2F;以十进制输出\n    cout &lt;&lt; oct &lt;&lt; 123 &lt;&lt; endl;&#x2F;&#x2F;以八进制输出\n    return 0;\n&#125;\n\n\n","slug":"c++的输入输出","date":"2022-03-04T15:00:41.516Z","categories_index":"c/c++","tags_index":"c/c++","author_index":"yuri2078"},{"id":"c1066c6c67d738c454c0adc022f5b3f1","title":"c语言内存管理函数","content":"以下函数均包含在stdlib.h头文件中\nvoid *malloc()    1. 向系统申请 个字节的空间，并返回指向该空间的指针    2. 返回的是void空指针，需要转换类型使用。无初值    3. 返回失败返回NULL。\nvoid free(指针)             释放我们申请的空间。它没有返回值\n因为返回的地址是void类型，所以我们需要强制类型转换\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint main(void)\n&#123;\n    int *p;\n    &#x2F;&#x2F;定义整形指针\n    p &#x3D; (int *)malloc(sizeof(int));\n    &#x2F;&#x2F;分配int字节的空间并把地址返回给p\n    if (p &#x3D;&#x3D; NULL)\n    &#123;\n        printf(&quot;分配失败 ! &quot;);\n        &#x2F;&#x2F;分配失败就终止程序\n        exit(1);\n    &#125;\n    printf(&quot;请输入一个数: &quot;);\n    scanf(&quot;%d&quot;, p);\n    printf(&quot;我们输入的数是 %d \\n&quot;, *p);\n    free(p);\n    &#x2F;&#x2F;释放我们申请的空间\n    return 0;\n&#125;\n\n内存泄漏问题 很危险就对了\n分配一个数组\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint main(void)\n&#123;\n    int *p &#x3D; NULL;\n    p &#x3D; (int *)malloc(8 * sizeof(int));\n    for (int i &#x3D; 0; i &lt; 8;i++)\n    &#123;\n        scanf(&quot;%d&quot;, p + i);\n        printf(&quot;%d  &quot;, *(p + i));\n    &#125;\n    free(p);\n    return 0;\n&#125;\n\n\nmemset(p, 0, size);  &#x2F;&#x2F;包含于string.h  中将p指向的size大小的空间初始化为0\ncalloc(number,size);申请number * size个空间并把他们初始化为0\nmemcpy(p1,p2,n);  将n个数据从p2中拷贝到p1中\n","slug":"c语言内存管理函数","date":"2021-12-20T12:04:01.960Z","categories_index":"c/c++","tags_index":"c/c++","author_index":"yuri2078"},{"id":"e711e115c4d04e8fd1bc13f673ce3ea8","title":"c语言链表","content":"单链表组成：   |信息域|指针域|    单链表一般由 信息域 和 指针域 构成\n链表的增加 删除\n链表练习题 均使用头插法\n1 制作同学数据录入表\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\nstruct Name\n&#123;\n    int age;\n    char name[80];\n    struct Name *next;\n&#125;;\n&#x2F;&#x2F;定义结构体\nvoid show(struct Name *p)\n&#123;\n    while (p)\n    &#123;\n        printf(&quot;该同学是:%-15s 今年   %-3d  岁 \\n&quot;, p-&gt;name, p-&gt;age);\n        p &#x3D; p-&gt;next;\n    &#125;\n&#125;\n&#x2F;&#x2F;定义输出函数\nstruct Name *add(struct Name *head)\n&#123;\n    char name[80];\n    int age;\n    struct Name *p &#x3D; head;\n    printf(&quot;请输入需要添加的同学姓名 年龄: &quot;);\n    scanf(&quot;%s%d&quot;, name, &amp;age);\n    if (head &#x3D;&#x3D; NULL)\n    &#123;\n        head &#x3D; (struct Name *)malloc(sizeof(struct Name));\n        strcpy(head-&gt;name, name);\n        head-&gt;age &#x3D; age;\n        return head;\n    &#125;\n    else\n    &#123;\n        while (head-&gt;next !&#x3D; NULL)\n        &#123;\n            head &#x3D; head-&gt;next;\n        &#125;\n        head-&gt;next &#x3D; (struct Name *)malloc(sizeof(struct Name));\n        strcpy(head-&gt;next-&gt;name, name);\n        head-&gt;next-&gt;age &#x3D; age;\n    &#125;\n    return p;\n&#125;\n&#x2F;&#x2F;定义添加成员函数\nstruct Name *del(struct Name *head)\n&#123;\n    struct Name *p &#x3D; head, *t &#x3D; NULL;\n    char s[80];\n    printf(&quot;请输入你想要删除的同学的名字&quot;);\n    scanf(&quot;%s&quot;, s);\n    while (p !&#x3D; NULL)\n    &#123;\n        if (strcmp(p-&gt;name, s) &#x3D;&#x3D; 0)\n        &#123;\n            break;\n        &#125;\n        t &#x3D; p;\n        p &#x3D; p-&gt;next;\n    &#125;\n    if (t &#x3D;&#x3D; NULL)\n    &#123;\n        t &#x3D; head;\n        free(t);\n        head &#x3D; head-&gt;next;\n    &#125;\n    else\n    &#123;\n        t-&gt;next &#x3D; p-&gt;next;\n        free(p);\n    &#125;\n    return head;\n&#125;\n&#x2F;&#x2F;定义删除成员函数\nvoid relass(struct Name *p)\n&#123;\n    struct Name *t &#x3D; p;\n    while (p)\n    &#123;\n        free(t);\n        p &#x3D; p-&gt;next;\n        t &#x3D; p;\n    &#125;\n&#125;\n&#x2F;&#x2F;定义释放内存呢函数\nint main(void)\n&#123;\n    struct Name *head &#x3D; NULL;\n    int x;\n    printf(&quot;欢饮来到同学信息录入删除系统--------版本2.0\\n&quot;);\n    printf(&quot;请按照序号选择操作\\n&quot;);\n    while(1)\n    &#123;\n        printf(&quot; 1 添加n个同学\\n 2 删除一个同学 \\n 3 查看当然数据库\\n 4 打印成员并且退出系统\\n\\n请输入数据:&quot;);\n        scanf(&quot;%d&quot;, &amp;x);\n        switch(x)\n        &#123;\n            case 1 : &#123;\n                head &#x3D; add(head);\n                break;\n            &#125;\n            case 2 : &#123;\n                head &#x3D; del(head);\n                break;\n            &#125;\n            case 3 : &#123;\n                show(head);\n                break;\n            &#125;\n            case 4 : &#123;\n                show(head);\n                relass(head);\n                return 0;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n2  多项式相加\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\ntypedef struct Node\n&#123;\n    int coef;  &#x2F;&#x2F;系数\n    int expn;  &#x2F;&#x2F;指数\n    struct Node *next;\n&#125;Node;\n\nNode* create()\n&#123;\n        Node *head&#x3D;NULL,*p&#x3D;NULL;\n        int x,i;\n        scanf(&quot;%d&quot;,&amp;x);\n        for(i&#x3D;0;i&lt;x&#x2F;2;i++) \n        &#123;\n            if(head &#x3D;&#x3D; NULL)\n            &#123;\n                head&#x3D;(Node *)malloc(sizeof(Node));\n                scanf(&quot;%d%d&quot;,&amp;head-&gt;coef,&amp;head-&gt;expn);\n                p&#x3D;head;\n            &#125;\n            else\n            &#123;\n                p-&gt;next&#x3D;(Node *)malloc(sizeof(Node));\n                p&#x3D;p-&gt;next;\n                scanf(&quot;%d%d&quot;,&amp;p-&gt;coef,&amp;p-&gt;expn);\n            &#125;\n        &#125; \n        p-&gt;next &#x3D; NULL;\n        return head; \n&#125;\nNode* add(Node *a,Node *b)\n&#123;\n    Node *t&#x3D;NULL,*p;\n    if(a-&gt;expn &lt; b-&gt;expn)\n    &#123;\n        t &#x3D; a;\n        a &#x3D; b;\n        b &#x3D; t;\n    &#125;\n    p &#x3D; a;\n    while(a !&#x3D; NULL &amp;&amp; b !&#x3D; NULL)\n    &#123;\n        while((a !&#x3D;NULL) &amp;&amp; (a-&gt;expn &#x3D;&#x3D; b-&gt;expn))\n        &#123;\n            t &#x3D; a;\n            a &#x3D; a-&gt;next;\n        &#125;\n        if(a !&#x3D; NULL)\n        &#123;\n            if(a-&gt;expn &#x3D;&#x3D; b-&gt;expn)\n            &#123;\n                a-&gt;coef +&#x3D; b-&gt;coef;\n                b &#x3D; b-&gt;next;\n            &#125;\n            else\n            &#123;\n                t-&gt;next &#x3D; (Node *)malloc(sizeof(Node));\n                t &#x3D; t-&gt;next;\n                t-&gt;coef &#x3D; b-&gt;coef;\n                t-&gt;expn &#x3D; b-&gt;expn;\n                t-&gt;next &#x3D; a;\n            &#125;\n        &#125;\n    &#125;\n    if(b !&#x3D; NULL)\n        t-&gt;next &#x3D; b;\n    return p;\n&#125;\nvoid print(Node *head)\n&#123;\n    while(head !&#x3D; NULL)\n    &#123;\n        printf(&quot;%d %d &quot;,head-&gt;coef,head-&gt;expn);\n        head&#x3D;head-&gt;next;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    Node *a,*b,*c;\n    a &#x3D; create();\n    b &#x3D; create();\n    c &#x3D; add(a,b);\n    print(c);\n    return 0;\n&#125;\n\n\n","slug":"c语言链表","date":"2021-12-20T10:32:01.587Z","categories_index":"c/c++","tags_index":"c/c++","author_index":"yuri2078"},{"id":"827b9ebac231c6d2ed515e8152eec015","title":"结构体","content":"结构体是用户自己定义的数据类型，它所占的空间是所有成员的空间之和但是 ，每个成员的占用空间数是 4 的倍数\n形如：struct 结构体名{  具体成员};定义结构体成员\n#include &lt;stdio.h&gt;\nstruct Tongxue\n&#123;\n    char name[80];\n    int age;\n    float fenshu;\n&#125;; &#x2F;&#x2F;末尾需要添加分号\n&#x2F;&#x2F;定义一个结构体命名为Tongxue\nint main(void)\n&#123;\n    struct Tongxue  people;\n    printf(&quot;请输入同学名字 : &quot;);\n    scanf(&quot;%s&quot;, people.name);\n    &#x2F;&#x2F;用结构体名.具体成员名，就可以访问具体成员\n    printf(&quot;请输入同学年龄 : &quot;);\n    scanf(&quot;%d&quot;, &amp;people.age);\n    printf(&quot;请输入同学名字 : &quot;);\n    scanf(&quot;%f&quot;, &amp;people.fenshu);\n    printf(&quot;你好，%s 同学今年 %d岁，考了%f分&quot;, people.name, people.age, people.fenshu);\n    &#x2F;&#x2F;打印输出\n    return 0;\n&#125;\n\ntips ： 定义的时候也可以直接把名字放结构体成员的话括弧后面如struct 结构体名{  具体成员} name ;\n这样就是全局变量\n初始值我们可以直接用大括号指定成员的初始值\n#include &lt;stdio.h&gt;\nstruct Tongxue\n&#123;\n    char name[80];\n    int age;\n    float fenshu;\n&#125;; \nint main(void)\n&#123;\n    struct Tongxue people &#x3D;\n        &#123;\n            &quot;gejing&quot;,\n            100,\n            66.6\n        &#125;;\n    &#x2F;&#x2F;直接初始化结构体\n    printf(&quot;你好，%s 同学今年 %d岁，考了%f分&quot;, people.name, people.age, people.fenshu);\n    return 0;\n&#125;\n\n我们也可以直接指定某个成员的初始值\n#include &lt;stdio.h&gt;\nstruct Tongxue\n&#123;\n    char name[80];\n    int age;\n    float fenshu;\n&#125;; \nint main(void)\n&#123;\n    struct Tongxue  people&#x3D;&#123;.age &#x3D; 100&#125;;\n    &#x2F;&#x2F;指定成员中的一位的初始值\n\n    printf(&quot;请输入同学名字 : &quot;);\n    scanf(&quot;%s&quot;, people.name);\n    printf(&quot;请输入同学分数 : &quot;);\n    scanf(&quot;%f&quot;, &amp;people.fenshu);\n    printf(&quot;你好，%s 同学今年 %d岁，考了%f分&quot;, people.name, people.age, people.fenshu);\n    return 0;\n&#125;\n\n\n结构体里面嵌套结构体\n#include &lt;stdio.h&gt;\nstruct Date\n&#123;\n    int year;\n    int month;\n    int day;\n&#125;;\nstruct Tongxue\n&#123;\n    char name[80];\n    struct Date date;\n    &#x2F;&#x2F;嵌套结构体\n    float fenshu;\n&#125;mate; \nint main(void)\n&#123;\n    printf(&quot;请输入同学的名字: &quot;);\n    scanf(&quot;%s&quot;, mate.name);\n    printf(&quot;请输入同学的出生日期: &quot;);\n    scanf(&quot;%d%d%d&quot;, &amp;mate.date.year,&amp;mate.date.month,&amp;mate.date.day);\n    &#x2F;&#x2F;通过  结构体名.结构体名.成员名访问\n    printf(&quot;请输入同学的分数: &quot;);\n    scanf(&quot;%f&quot;, &amp;mate.fenshu);\n    printf(&quot;你好，%s 同学出生于%d年%d月%d日，考了%f分&quot;, mate.name, mate.date.year,mate.date.month,mate.date.day,mate.fenshu);\n    return 0;\n&#125;\n\n\n结构体数组 ： 直接在名字后加上长度就行了\n#include &lt;stdio.h&gt;\nstruct Date\n&#123;\n    int year;\n    int month;\n    int day;\n&#125;;\nstruct Tongxue\n&#123;\n    char name[80];\n    struct Date date;\n    float fenshu;\n&#125;mate[5]; \n&#x2F;&#x2F;直接定义5个结构体变量\nint main(void)\n&#123;\n    for (int i &#x3D; 0; i &lt; 5;i++)\n    &#123;\n        printf(&quot;请输入第%d个同学的名字: &quot;,i+1);\n        scanf(&quot;%s&quot;, mate[i].name);\n        &#x2F;&#x2F;通过下标引用结构体\n        printf(&quot;请输入该同学的出生日期: &quot;);\n        scanf(&quot;%d%d%d&quot;, &amp;mate[i].date.year,&amp;mate[i].date.month,&amp;mate[i].date.day);\n        printf(&quot;请输入该同学的分数: &quot;);\n        scanf(&quot;%f&quot;, &amp;mate[i].fenshu);\n    &#125;\n    for (int i &#x3D; 0; i &lt; 5;i++)\n    &#123;\n        printf(&quot;你好，%s 同学出生于%d年%d月%d日，考了%f分\\n&quot;, mate[i].name, mate[i].date.year,mate[i].date.month,mate[i].date.day,mate[i].fenshu);\n    &#125;\n    return 0;\n&#125;\n\n\n结构体指针 struct 结构体名 *变量名基本上和常规类型一样的用法\n#include &lt;stdio.h&gt;\nstruct Name\n&#123;\n    char x[80];\n&#125;;\n\nvoid show(struct Name *p,int x)\n&#x2F;&#x2F;定义结构体指针\n&#123;\n    for (int i &#x3D; 0; i &lt; x;i++)\n    &#123;\n        printf(&quot;%s\\n&quot;, p-&gt;x);\n        p++;\n    &#125;\n&#125;\n\nint main(void)\n&#123;\n    int x;\n    printf(&quot;一共有多少个同学？  &quot;);\n    scanf(&quot;%d&quot;,&amp;x);\n    struct Name classMate[x];\n    printf(&quot;请依次输入同学的姓名\\n &quot;);\n    for (int i &#x3D; 0; i &lt; x;i++)\n    &#123;\n        scanf(&quot;%s&quot;,classMate[i].x);\n    &#125;\n    show(classMate, x);\n    &#x2F;&#x2F;直接传入地址打印\n    return 0;\n&#125;\n\n我们如果不喜欢 每次都打struct的话还可以用这个方法定义\n#include &lt;stdio.h&gt;\ntypedef struct \n&#123;\n    int x;\n&#125; Name;\n&#x2F;&#x2F;直接声明结构体名字\n&#x2F;&#x2F;可以声明多个但是意义不大\nint main(void)\n&#123;\n    int x;\n    Name t;\n    &#x2F;&#x2F;直接定义\n    scanf(&quot;%d&quot;,&amp;x);\n    t.x &#x3D; x;\n    printf(&quot;%d mmm &quot;,t.x);\n    return 0;\n&#125;\n\n\n","slug":"结构体","date":"2021-12-15T10:22:15.201Z","categories_index":"c/c++","tags_index":"c/c++","author_index":"yuri2078"},{"id":"dbe2dc55bd3968b121423724b8b30463","title":"c语言知识点补充","content":"scanf 输入是 用 %*d 会吞掉一个输入#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int x, y;\n    scanf(&quot;%d %*d %d&quot;, &amp;x, &amp;y);\n    &#x2F;&#x2F;输入11 22 33 \n    printf(&quot;x &#x3D; %d y &#x3D; %d \\n&quot;,x,y);\n    &#x2F;&#x2F;打印结果是 x &#x3D; 11 y &#x3D; 33 中间输入的22被吞掉\n    return 0;\n&#125; \n\nprint 输出时 %09d 前面不足9位的时候会用0补充#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int x &#x3D; 666;\n    printf(&quot;%09d&quot;, x);\n    &#x2F;&#x2F;打印结果000000666\n    return 0;\n&#125; \n\n而用-09d则会提示错误\n用scanf接收数据的时候可以指定接收的长度，浮点数也可以指定长度，但是不能指定小数点 如 %6.2f这种就是错误的用法#include&lt;stdio.h&gt;\nint main()\n&#123;\n    float x, y;\n    scanf(&quot;%6f%f&quot;, &amp;x, &amp;y);\n    &#x2F;&#x2F;输入 ： 3.123456 2.5\n    printf(&quot;x &#x3D; %f y &#x3D; %f \\n&quot;, x, y);\n    &#x2F;&#x2F;打印结果 x &#x3D; 3.123400 y &#x3D; 56.000000\n    return 0;\n&#125; \n\n\n指定输入长度后，未获取的数据会给下一个变量\n高级宏定义\n宏定义只定义不进行运算    1. 不带参数 #define PI 3.14    2. 带参数的\n#include&lt;stdio.h&gt;\n#define SUM(x,y) x+y\nint main()\n&#123;\n    int x, y;\n    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n    printf(&quot;sum(x,y) &#x3D; %d \\n&quot;, SUM(x, y));\n    &#x2F;&#x2F;用x+y替换SUN(x,y)\n    return 0;\n&#125; \n\n\ntip: 在某些场景可以用宏定义替代函数，可以提高效率\n内联函数形如 以下程序 打印1-30的平方\n#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int pingFang(int x);\n    for (int i &#x3D; 1; i &lt; 30;i++)\n    &#123;\n        printf(&quot;%d 的平方是: %d \\n&quot;, i, pingFang(i));\n    &#125;\n    return 0;\n&#125; \nint pingFang(int x)\n&#123;\n    return x * x;\n&#125;\n\n这里函数需要重估的调用，但是因为c语言函数调用是借助于堆栈的这样会严重影响运行效率。  所以我们可以使用内联函数。相当于宏定义，在编译的时候用函数的内容替代函数名，从而实现提高效率，减少开支\n方法 ： 在函数名前加 inline\n#include&lt;stdio.h&gt;\ninline int pingFang(int x);\n&#x2F;&#x2F;在函数名前添加inline \n&#x2F;&#x2F;需要在main前声明\nint main()\n&#123;\n    for (int i &#x3D; 1; i &lt; 30;i++)\n    &#123;\n        printf(&quot;%d 的平方是: %d \\n&quot;, i, pingFang(i));\n    &#125;\n    return 0;\n&#125; \nint pingFang(int x)\n&#123;\n    return x * x;\n&#125;\n\n加号链接运算符,记号黏贴运算符形如 #define STR(s) #s 将输入的数据转换成字符串形如 #define TOGETHER(x,y) x ## y 连接x和y\n#include &lt;stdio.h&gt;\n#define TOGETHER(x,y) x ## y\n&#x2F;&#x2F;连接x和y\nint main(void)\n&#123;\n    printf(&quot; TOGETHER &#x3D; %d &quot;,TOGETHER(2,50));\n    return 0;\n&#125;\n&#x2F;&#x2F;输出250\n\n可变参数\n形如 #define PRINTF(…) printf(# VA_ARGS)\n#include &lt;stdio.h&gt;\n#define PRINTF(...) printf(# __VA_ARGS__)\n&#x2F;&#x2F;\n&#x2F;&#x2F;...表示需要传入参数，va-args-- 固定写法，表示接收任何的参数\n&#x2F;&#x2F;# 表示将参数转化成字符串\nint main(void)\n&#123;\n    PRINTF(hello python);\n    &#x2F;&#x2F;成功打印hello python\n    return 0;\n&#125;\n\n可变参数支持空参数\n#include &lt;stdio.h&gt;\n#define PRINTF(str,...) printf(# str,## __VA_ARGS__)\n&#x2F;&#x2F;将hello python 传入给str ，...为空参数\nint main(void)\n&#123;\n    PRINTF(hello python);\n    &#x2F;&#x2F;成功打印hello python\n    return 0;\n&#125;\n\n\n\\b   &#x2F;&#x2F;使光标回退一格 需要后面跟着替换的字符不然既不会回退\n#include &lt;stdio.h&gt;\nint main(void)\n&#123;\n    printf(&quot;hello python*\\b \\n&quot;);\n    &#x2F;&#x2F; \\b后面有替换的空格 打印结果hello python\n    printf(&quot;hello*\\b&quot;);\n    &#x2F;&#x2F; \\b后没有替换的空格 打印结果hello*\n    return 0;\n&#125;\n\n\n\\r   &#x2F;&#x2F;使光标回退到开头注意 只是回退，本质上并不是清除。往下如果不完全覆盖，还是可以打印出来的\n#include &lt;stdio.h&gt;\nint main(void)\n&#123;\n    printf(&quot;hello python 我是多的数据&quot;);\n    printf(&quot;\\r&quot;);\n    &#x2F;&#x2F;使光标移动到开头\n    printf(&quot;hello java c &quot;);\n    &#x2F;&#x2F;重新打印比刚才多的数据\n    &#x2F;&#x2F;打印结果 hello java c 我是多的数据\n    return 0;\n&#125;\n\n","slug":"c语言知识点补充","date":"2021-12-14T06:34:01.293Z","categories_index":"c/c++","tags_index":"c/c++","author_index":"yuri2078"},{"id":"4c0cb40856baa1e8384c37c457fb63f6","title":"指针","content":"1  指针的初值。一般我们将没有赋值的指针初值设置为NULL\n定义指针时一定要有初值，不然后面赋值之后它指向的地方是不确定的，那么你修改内存中的东西可能会修改到已经有值的内存，这是不被允许的。并且编译器也会报错。\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n&#123;\n    char *p;\n    char *s &#x3D; &quot;china&quot;;\n    &#x2F;&#x2F;定义字符数组的时候可以省略[]所以这不是野指针\n    int *i; &#x2F;&#x2F;未初始化指针i的值，所以i是一个野指针\n    p &#x3D; s;\n    *i &#x3D; 123;\n    printf(&quot;s &#x3D; %s , p &#x3D; %p \\n&quot;, p, p);\n    &#x2F;&#x2F;可以打印出p的地址也就是s的地址\n    printf(&quot;i &#x3D; %d , p &#x3D; %p \\n&quot;, *i,i);\n    &#x2F;&#x2F;打印结果i的地址是0，并且编译器告诉你你非法修改地址的内容\n    return 0;\n&#125; \n\n比如上面这段代码，运行结果是：\ntest.c:10:5: warning: &#39;i&#39; is used uninitialized in this function [-Wuninitialized]\n*i &#x3D; 123;\n~~~^~~~~\ns &#x3D; china , p &#x3D; 0000000000404000\ni &#x3D; 123 , p &#x3D; 0000000000000000\n\n它会告诉你你非法修改了内存里的值，也就是i所指向的这部分值。\n2 定义字符数组的时候，如果是 char *p&#x3D;”china”;这种的，是只读类型的\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\nint main()\n&#123;\n    char *p;\n    char *s &#x3D; &quot;china&quot;;\n    p &#x3D; s;\n    for (int i &#x3D; 0; i &lt; strlen(p);i++)\n    &#123;\n        putchar(p[i]);\n    &#125;\n    &#x2F;&#x2F;通过下标访问字符数组的值\n    p[0] &#x3D; &#39;C&#39;;\n    puts(p);\n    &#x2F;&#x2F;我们发现数组的值并没有改变\n    return 0;\n&#125; \n\n这样定义的字符数组同样可以通过下标访问但是却不能修改他的值，是只读的。不能修改。\n3 指针数组和数组指针\n1 数组名是不可以修改的，数组名永远代表第一个元素的首地址。不可以改变它指向的地址。比如以下程序会报错！\n#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int i&#x3D;0;\n    char s[]&#x3D; &quot;i love miku&quot;;\n    while(*s++) i++;\n    printf(&quot;len &#x3D; %d &quot;, i);\n    return 0;\n&#125; \n\n报错 error: lvalue required as increment operand运算对象必须是一个可以运算的左值，而数组名不可以修改。\n指针数组： int *p[10];定义存放是个指针的数组p\n#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int *p[10]&#x3D;&#123;NULL&#125;;\n    &#x2F;&#x2F;[]优先级高于*所以，这是一个存放5个指针变量的指针数组\n    int a[5],b[5];\n    for (int i &#x3D; 0; i &lt; 5;i++)\n    &#123;\n        a[i] &#x3D; i + 1;\n        p[i] &#x3D; &amp;a[i];\n        printf(&quot;p[i] &#x3D; %d  \\n&quot;, *p[i]);\n    &#125;\n    for (int i &#x3D; 5; i &lt; 10;i++)\n    &#123;\n        b[i-5] &#x3D; i + 1;\n        p[i] &#x3D; &amp;b[i-5];\n        printf(&quot;p[i] &#x3D; %d  \\n&quot;, *p[i]);\n    &#125;\n    &#x2F;&#x2F;p指针数组分别存放a，b数组的十个变量的地址\n    return 0;\n&#125; \n\n总结： 指针数组是一个数组，每个元素存放一个指针变量\n数组指针：int(*p)[5];这是一个指针，指向一个有5个元素的数组\n()和[]优先级是一样的，从左往右运算加了括号，先和*结合再和[]结合，这是个数组指针\n错误初始化实例\n#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int(*p)[5]&#x3D;&#123;1,2,3,4,5&#125;;\n    for (int i &#x3D; 0; i &lt; 5;i++)\n    &#123;\n        printf(&quot; %d \\n&quot;, *(p + i));\n    &#125;\n    &#x2F;&#x2F; 打印结果是  1 21 41 61 81\n    return 0;\n&#125; \n\np里存放的应该是地址而不是值\n#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int a[5] &#x3D; &#123;1, 2, 3, 4, 5&#125;;\n    int(*p)[5] &#x3D; &amp;a;\n    &#x2F;&#x2F; p指向的应该是一个真正的数组而不是元素值\n    &#x2F;&#x2F; 如果仅仅是a编译器会警告你\n    for (int i &#x3D; 0; i &lt; 5;i++)\n    &#123;\n        printf(&quot; %d  &quot;, *(*p + i));\n        &#x2F;&#x2F; p指向的是数组，所以*p才是它所指向的数组的首地址\n    &#125;\n    return 0;\n&#125; \n\n\n总结： p是数组指针指向的应该是数组的地址。而数组名虽然和数组的第一个元素地址相同，但却代表不同的意思。这里我们的p需要指向的是数组，而不是元素的地址，所以需要用&amp;取数组的地址。后面也可以看出来，p指向的数组，*p才是数组的首地址。而普通定义的int *p。其实是一个指向整形变量的指针，这里是一个指向数组的指针。\n指针和二维数组\n二维数组才c语言中是线性存放的，也就死并不存在真正的二维数组。数组名 数组第一行 数组第一行第一列的元素  所代表的都是a[0][0]的地址\n#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int a[5][5];\n    for (int i &#x3D; 0; i &lt; 5;i++)\n    &#123;\n        for (int j &#x3D; 0; j &lt; 5;j++)\n        &#123;\n            *(*(a + i) + j) &#x3D; j;\n            printf(&quot;%d &quot;, *(*(a + i) + j));\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n    printf(&quot;a &#x3D; %p \\n&quot;, a);\n    printf(&quot;a &#x3D; %p \\n&quot;, a[0]);\n    printf(&quot;a &#x3D; %p \\n&quot;, &amp;a[0][0]);\n    &#x2F;&#x2F;打印后我们发现结果是一样的\n    return 0;\n&#125; \n\n数组名代表的是一个指向二维数组的指针，他的值是第一行，第一个元素的地址\n#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int a[5][5]&#x3D;&#123;0&#125;;\n    &#x2F;&#x2F;一共100字节一共5行，也就是每行20字节\n    printf(&quot;a &#x3D; %p  a+1 &#x3D; %p \\n&quot;, a,a+1);\n    &#x2F;&#x2F;打印结果是 ： a &#x3D; 000000000061FD90  a+1 &#x3D; 000000000061FDA4\n    &#x2F;&#x2F;结果相差14 也就是十进制的20自己，证明了a+1就是指向下一行（第二行）\n    printf(&quot;a[1] &#x3D; %p  *(a+1) &#x3D; %p \\n&quot;, a[1],*(a+1));\n    &#x2F;&#x2F;结果相同，并且结果都是a+1的值，证明a+1 a[1] *(a+1) 都指向第二行\n    printf(&quot;a[1][0] &#x3D; %p  (*(a+1)) &#x3D; %p \\n&quot;, &amp;a[1][0],(*(a+1)));\n    &#x2F;&#x2F;结果相同，证明 a[1][0]  *(*(a+1)) 都是指的第二行第一个元素\n    return 0;\n&#125; \n\n\n数组名 + n 表示的是第 n 行 &#x2F;&#x2F;此处的第n行，仅仅是指向行而 (数组名 + n)值得是 第n行的元素 再次通过可以访问里面的元素\n(数组名+n)+m 这是表示指向n行m列的元素的地址 当加上，才可以访问它的值\n#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int a[5][5]&#x3D;&#123;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25&#125;;\n    int(*p)[5];\n    p &#x3D; a;\n    printf(&quot;a[0][0] &#x3D; %d    **p &#x3D; %d \\n&quot;,a[0][0],**p);\n    printf(&quot;a[1][0] &#x3D; %d    **(p+1) &#x3D; %d \\n&quot;,a[1][0],**(p+1));\n    printf(&quot;a[1][2] &#x3D; %d    *(*(p+1)+2) &#x3D; %d \\n&quot;,a[1][2],*(*(p+1)+2));\n    return 0;\n&#125; \n运行上面这段代码，我们发现，下面每一行的值是相同的，这也印证了，数组名代表的是第一行的地址，而它可以直接赋值给一个数组指针。也可以通过下标访问这个数组里个各个值。\n\n\n4 指向函数的指针\n\n#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int x, y;\n    int sum(int x, int y);\n    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n    int (*p)(int, int);\n    &#x2F;&#x2F;初始换指针是里面的数据需要和指向的函数相对应\n    &#x2F;&#x2F;对应参数的名字可以省略，但是参数的类型不能省略\n    &#x2F;&#x2F;定义函数指针\n    p &#x3D; sum;\n    &#x2F;&#x2F;将指针指向 sum函数\n    printf(&quot;sum &#x3D; %d \\n&quot;, p(x, y));\n    &#x2F;&#x2F;通过指针调用sum函数\n    return 0;\n&#125; \nint sum(int x,int y)\n&#123;\n    return x + y;\n&#125;\n\n\n5 NULL指针和void指针\n（1） void指针可以指向任何指针，任何指针也可以赋值给void指针\n6 指向指针的指针\n定义 ： int **p;\n#include&lt;stdio.h&gt;\nint main()\n&#123;\n    int x;\n    int *t&#x3D;&amp;x;\n    &#x2F;&#x2F;定义一个指针指向x\n    int **p&#x3D;&amp;t;\n    &#x2F;&#x2F;定义一个指向指针的指针，指向指针t\n    &#x2F;&#x2F;t表示指针t指向的地址，%t才是指针t本省\n    scanf(&quot;%d&quot;, &amp;x);\n    printf(&quot;x &#x3D; %d **p &#x3D; %d &quot;, x, **p);\n    &#x2F;&#x2F;打印结果相同\n    return 0;\n&#125; \n\n应用 ： 将指向指针的指针指向一个字符数组\n","slug":"指针","date":"2021-12-12T07:41:07.092Z","categories_index":"c/c++","tags_index":"c/c++","author_index":"yuri2078"},{"id":"e2c06b60dce8071098800af5e45f52bb","title":"vscode配置教程","content":"\n\n\n\n\n\n\n\n\n前言 : 因为里面需要配置Jason文件路径，所以没有基础就按着我的路径走，等有经验了，再继续用自己的方法走\n\n\n\n\n\nc语言 教程\n下载mingw64  https://sourceforge.net/projects/mingw-w64/files/mingw-w64/\n 选择最新的版本就行，这里用的是 gcc 810\n 我们下载 x86_64-posix-seh 这个就行了 32位系统选择32位的就行 \n\n解压mingw64 到c盘根目录\n \n\n配置环境变量\n 右击我的电脑 属性 高级系统设置 环境变量 进去后找到系统变量 PATH \n 把刚刚解压的mingw64文件夹里的bin文件夹的目录复制进去\n  \n \n 弄好之后 ，win + R 组合键 然后调出cmd  使用命令 gcc -v 如果出现下面的界面表示成功 \n\n下载 vscode   https://code.visualstudio.com/ 直接点这个 大大的蓝色的 Download for windows 下载就行了，下载完直接安装，什么都不用动直接无脑下一步。\n \n\n下载vsode需要的c配置文件\n 下载完直接解压到你想要的地方就行了\n\n下载插件 进vscode后直接点击左下第四个图标，下载插件  直接搜索就行了 1 chinese 中文汉化插件 安装后需要重启 2 code run 可以直接编写完成后 编译直接保存运行 3 Bracket Pair Colorizer 编写代码时帮我们弄花括弧 4 c&#x2F;c++  C&#x2F;C++ Extension Pack 这两个一定要安装 编写c语言需要的扩展 5 atom 主题可用可不用\n\n编写hello c 点击左上角第一个图标选择代打一个文件夹\n 打开第五步解压的vscode 的配置文件夹 然后选择完全信任父文件夹 \n 点击左上角 文件夹名字右边四个图表中的第一个然后 新建 hello.c \n 然后编写代码。结束后，邮寄空白处点击run code或者点击右上角的小三角形就行了。代码会自动保存编译运行。\n\n\npython\n下载python https://www.python.org/downloads/ 直接点击那个黄色的大按钮下载就行 \n 然后安装，安装的时候下面有两个选项， 把第二个  add pytho3.10 to path 勾选上，然后点击上面的 install now 无脑下一步安装就行了\n\nvscode 里搜索python扩展安装就行。 一定要先安装完python再装扩展  然后直接运行\n\n\njava\n下载Java https://www.java.com/zh-CN/download/\n 这个无脑下一步就行了，默认安装位置就行\n\n下载jdk https://www.oracle.com/java/technologies/downloads/#jdk17-windows\n 选择后缀是exe或者msi都可以。然后安装，这里我们不更改默认位置。直接下一步就行了。\n\n配置环境变量\n 右击我的电脑 属性 高级系统设置 环境变量\n 进去后我们在 系统变量下新建两个系统变量 变量名 JAVA_HOME 值 C:\\Program Files\\Java\\jdk-17.0.1\n 这是jdk默认安装位置 \n 在系统变量path下，添加 %JAVA_HOME%\\jre\\bin %JAVA_HOME%\\bin 这两个变量\n\n查看 win + R 然后 cmd 输入 java -version 命令 出现版本号就表示成功了\n \n\nvscode扩展安装 搜索 Java  安装  Extension Pack for Java 这个Java包就行了\n\n点击左下角的齿轮 再点击设置 \n 搜索 setting 然后点第一个下面在setting.json 中设置 \n 进去后在最后一个花括号前加上一一句 &quot;java.home&quot;: &quot;C:\\\\Program Files\\\\Java\\\\jdk-17.0.1&quot; 具体位置可以自己改变。 \n 如果出现这种报错的话!在添加的那句话的前面的语句后面加一个逗号  如图所示没有都好就会报错\n\n打印helloJava\n \n\n\nvscode 常用命令\nctrl p 切换文件\nctrl  shirft L  同一改变相同值\nf12 转到定义\nalt f12 查看定义\nf2 重命名符号\nctrl + shitf 多行选中\n\n","slug":"vscode配置教程","date":"2021-12-11T09:18:08.875Z","categories_index":"教程","tags_index":"教程,vscode","author_index":"yuri2078"},{"id":"b61ff605f29218b2c48bdd2185b58832","title":"python常见函数","content":"经常和for循环出生入死的好兄弟函数 range()函数range(stop)\n生成从 0 到 len 为止的所有整数 不包括本身\nfor i in range(10) :\n    print(i,end&#x3D;&quot; &quot;)\n# 输出结果 \n# 0 1 2 3 4 5 6 7 8 9 \n\nrange(start,stop)\n生成从 start 开始到 stop 为止的所有整数 包括start 不包括 stop\nfor i in range(3,10) :\n    print(i,end&#x3D;&quot; &quot;)\n# 输出结果 \n# 3 4 5 6 7 8 9 \n\nrange(start,stop,step)\n和上一个一样，不过多了step 也就是跨度 step也可以是复数\nfor i in range(3,10,3) :\n    print(i,end&#x3D;&quot; &quot;)\n# 输出结果 \n# 3 6 9 \n\n随机生成函数\nimport random\ndaan&#x3D;random.randint(1,20) #随机生成1，20的数字\n\n\n提高浮点数精确度函数\nimport decimal #导入decimal 函数\na&#x3D;decimal.Decimal(0.1)\nb&#x3D;decimal.Decimal(0.2)\nprint(a)\n\n\nmath函数，使用前需要导入math模块 且引用为 math.具体模块\nimport math\nx,y&#x3D;input(),input()\nx,y&#x3D;int(x),int(y)\nprint(math.sin(x)) #x的正弦值\nprint(math.cos(x)) #x的余弦值\nprint(math.asin(x)) #x的反正弦\nprint(math.acos(x)) #x的反余弦\nprint(math.tan(x)) #x的正切\nprint(math.atan(x)) #x的余切，反正切\nprint(math.hypot(x,y)) #求直角三角形的斜边长度\nprint(math.fmod(x,y)) #取x&#x2F;y的余数\nprint(math.ceil(x)) #x取不小于x的最小整数\nprint(math.floor(x)) #取不大于x的最大整数\nprint(math.fabs(x)) #x的绝对值\nprint(math.exp(x)) #求e的x次方\nprint(math.pow(x,y)) #x的y次方\nprint(math.log10(x)) #求x以10为底的对数\nprint(math.sqrt(x)) #开x的根号\nprint(math.pi) #求Π的值\n\n注意：里面有的函数需要的参数值不一样，类型也不一样\nstring 函数 需要导入string\nimport string\ns&#x3D;&quot;hello python &quot;\nss&#x3D;&#39;hello&#39;\nprint(s.capitalize()) #将字符串的第一个字母大写\nprint(s.count(ss)) #查询ss字符串在s中出现的次数\nprint(s.find(ss)) #查询ss字符串在s中出现的起始位置没有则返回-1\nprint(s.isalnum()) #检测字符串是不是仅包含数字字母\nprint(s.isalpha()) #检测字符串是不是仅包含字母\nprint(s.isdigit()) #检测字符串是不是仅包含数字\nprint(s.isspace()) #检测字符串是不是仅包含空格\nprint(s.istitle()) #检测字符串首字母是不是大写\nprint(s.islower()) #检测字符串是不是都是小写字母\nprint(s.isupper()) #检测字符串是不是都是大写字母\nprint(s.join(ss)) #链接字符串\nprint(s.split()) #分割字符串\nprint(s.lower()) #将字符串全部变成大写\nprint(s.upper()) #将字符串全部变成小写\nprint(s.swapcase()) #将字符串大写变小写小写变大写\nprint(s.title()) #将字符串首字母大写\nprint(len(s)) #获取字符串长度\n\n\n列表函数 不需要导入函数\na&#x3D;[1,2,3,4,6]\nb&#x3D;[3,3,3]\nprint(a)\na.append(666) #列表尾部添加成员 \nprint(a)\nprint(a.count(1)) #返回列表中参数出现的次数\na.extend(b) #向列表追加另一个列表\nprint(a)\nprint(a.index(6)) #返回参数在列表中的序号，不存在就报错 \nprint(a)\na.insert(0,6) #向列表指定位置插入数据 \nprint(a)\nprint(a.pop()) #删除列表尾部成员并返回删除的值\nprint(a)\na.remove(1) #删除列表里指定成员（第一个），不存在则报错\nprint(a)\na.reverse() #将列表成员颠倒\nprint(a)\na.sort() #将列表中成员排序\nprint(a)\n\n\ninsert插入函数list.insert(0,2) 向list列表插入下标0的位置插入数据2\na &#x3D; [&quot;java&quot;,&quot;c&quot;,&quot;c++&quot;]\nprint(a)\n#打印结果[&quot;java&quot;,&quot;c&quot;,&quot;c++&quot;]\na.insert(3,&quot;python&quot;)\n#向下标3处插入&quot;python&quot;\n#打印结果[&#39;java&#39;, &#39;c&#39;, &#39;c++&#39;, &#39;python&#39;]\nprint(a)\n\n\nremove 删除函数list.remove(元素) 删除元素，不存在就报错。仅仅删除一个\na &#x3D; [&quot;java&quot;,&quot;c&quot;,&quot;c++&quot;,&quot;python&quot;]\nprint(a)\na.remove(&quot;python&quot;)\n#删除&quot;python&quot;\n&#39;&#39;&#39; \n    打印结果:\n    [&#39;java&#39;, &#39;c&#39;, &#39;c++&#39;, &#39;python&#39;]\n    [&#39;java&#39;, &#39;c&#39;, &#39;c++&#39;]\n&#39;&#39;&#39;\nprint(a)\n\n\nclear() 清除列表所有成员list.clear() 清除所有lise的成员\na &#x3D; [&quot;java&quot;,&quot;c&quot;,&quot;c++&quot;,&quot;python&quot;]\nprint(a)\na.clear()\n#清除成员a的所有成员\nprint(a)\n&#39;&#39;&#39;\n    打印结果：\n    [&#39;java&#39;, &#39;c&#39;, &#39;c++&#39;, &#39;python&#39;]\n    []\n&#39;&#39;&#39;\n\n","slug":"python常见函数","date":"2021-11-25T11:47:11.052Z","categories_index":"python","tags_index":"python","author_index":"yuri2078"},{"id":"412c84aa1f62065f96811d56475c91ef","title":"python第三章","content":"python注释通常有两种 一种是 “ # ” 字符开始另一种是用三个引号，或者三个双引号（都是在英文输入状态）\n# 以#号开始的注释\n&#39;&#39;&#39; 以三个单引号开始的注释 &#39;&#39;&#39;\n&quot;&quot;&quot; 以三个双引号开始的注释 &quot;&quot;&quot;\n\n如果一行程序写不下可以用’&#39; 继续\nprint(&quot;这一行太长了写不下了\\\n可以用\\接着下一行写&quot;)\n\npython用print打印输出不同参数默认会用空格隔开并且在最后打印一个回车这些都是可以修改的\na&#x3D;1\nb&#x3D;2\nprint(a,b)\nprint(a,b,sep&#x3D;&#39;,&#39;) #更改默认分隔符号\nprint(a,b,end&#x3D;&#39;;&#39;) #更改默认结束符号\nprint(a,b) # 此时我们发现并没有打印回车而是直接输出\n\n打印结果：1 21,21 2;1 2\npython中的字符串加号和乘号有着不同的功能\nx&#x3D;&quot;hello &quot;\ny&#x3D;&quot;python&quot;\nprint(x+y)\nprint(x*4)\n# 运行结果：\n# hello python\n# hello hello hello hello\n\n\n由此看出加号 为 两个字符串链接而乘号就是字符串打印的个数\npython中常用的运算符号\na&#x3D;13\nb&#x3D;4\nprint(a**b) #打印a的b次方\nprint(a&#x2F;&#x2F;b) #打印a整除b丢弃余数的结果\nprint(a%b)  #与c语言相同，取余数丢弃除数\nprint(a|b)  #按位或运算 \nprint(a^b)  #按位异或运算\nprint(a&amp;b)  #按位与运算\n# &lt;&lt; 左移 &gt;&gt; 右移运算\n\n格式或输出 %d这种类型与c语言相同\na&#x3D;666\nss&#x3D;&quot;i love  python &quot;\nprint(&quot;python is %d so %s&quot; %(a,ss))\n\npython中 bool 类型与c语言大致相同不过比较的值的结果为 Trur  和 False并且python中多了 is 和 is not 返回值一样是 Trur  和 False\nprint(6 &gt; 5)\nprint(6 is not 5)\nprint(6 &lt; 5)\nprint(6 is 5)\n\n结果为：TrueTrueFalseFalsepython中还有 and or not bool运算  与c语言相同or前为1则不运算后面 and前为0就不运算后面的值返回值为最终运算过的值\n# and or not \nprint(bool(3)) #值为True\nprint(bool(0)) #值为False\nprint(3 or 4) # 最终返回的值为3\nprint(3 and 4) # 最终返回的值为4\nprint(not True) #结果为False\nprint(not False) #结果为True\n\nif 语句的五种判别方式\nb,c,d&#x3D;6,7,8\n#(1)\nif b&gt;c :\n    print(&quot;我在里面&quot;)\nprint(&quot;我在外面&quot;)\n\n#(2)\nif b&gt;c :\n    max&#x3D;b\nelse   :\n    max&#x3D;c\n\n#(3)\nif b&gt;c   :\n    max&#x3D;b\nelif b&lt;d :\n    max&#x3D;d\n\n#(4)\nif b&gt;c   :\n    max&#x3D;b\nelif b&gt;d :\n    max&#x3D;d\nelse     :\n    max&#x3D;c\n\n#(5)\nmax&#x3D;b if b&gt;c else c\n\nwhile循环的使用\ni &#x3D; 0\nwhile i&lt;100:\n    print(&#39; i &#x3D; %d &#39; %(i) )\n    i &#x3D; input(&quot;输入一个大于100的数我就停了哦 ！ &quot;)\n    i &#x3D; int(i)\n    if(i &lt; 0 ) :\n        print(&quot;你输入的太小了。不让你继续了 你没有出来 &quot;)\n        break\n# break 强制退出\nelse :\n    print(&quot;恭喜你成功的出来了&quot;)\n#当while循环完成之后就会执行else语句\n\n\nwhile循环的嵌套使用 打印99乘法表\ni&#x3D;1\nwhile i &lt;&#x3D;9 :\n    j&#x3D;1\n    while j &lt;&#x3D; i :\n        print(&quot;%d * %d &#x3D; %d &quot; %(j,i,i*j),end&#x3D;&quot; &quot;)\n        j +&#x3D; 1\n    print(&quot;\\n&quot;)\n    i +&#x3D;1\nelse :\n    print(&quot;以上就是99乘法表了&quot;)\n\n注意  ： break 和 continue 只能跳过或者跳出一条循环\nfor 循环for 变量 in 可迭代对象 列如：一个字符串，或者range函数\nfor i in range(10) :\n    print(i,end&#x3D;&quot; &quot;)\nfor i in &quot;hello python .&quot; :\n    print(i,end&#x3D;&#39; &#39;)\n\n简单的打印一个 100以内的素数\nfor i in range(2,100) :\n    for j in range(2,i) :\n        if i%j &#x3D;&#x3D; 0 :\n            break\n    else :\n        print(i,end&#x3D;&#39;  &#39;)\n\n列表python里的列表可以是多种类型a &#x3D; [1,2,3,4,5,”python”]我们可以通过下标访问其中的每个元素\na &#x3D; [1,2,3,4,5,&quot;python&quot;]\nprint(a[5])\nprint(a[len(a)-1])\nprint(a[-1])\nprint(a[0:3]) #打印下标0-3的片段\nprint(a[:3]) #打印开头到3的片段\nprint(a[3:]) #打印3到尾部的片段\nprint(a[0:4:2]) #间隔2个打印\nprint(a[::2]) #省略头和尾间隔两个打印\nprint(a[::-2]) #省略头尾从尾部间隔两个打印\n\n上面前三个结果是一样的,同理我们打印a[-2]就是打印的倒数第二个元素。注意 所有的区间都是左开右闭。包含起始位置但是不包含尾部位置\n通过切片的方式我们也可以方便的添加数据\na &#x3D; [&quot;java&quot;,&quot;c&quot;,&quot;c++&quot;]\nprint(a)\n#打印结果是 [&#39;java&#39;, &#39;c&#39;, &#39;c++&#39;]\na[len(a):]&#x3D;[&quot;python&quot;]\n# 通过切片的方式添加数据\nprint(a)\n#打印结果是 [&#39;java&#39;, &#39;c&#39;, &#39;c++&#39;, &#39;python&#39;]\n\n\npython 的数据精度问题c语言中因为各种数据都存在类型，而python一开始便可以直接定义，但他们为什么类型呢？\nx&#x3D;input(&quot;请随机输入一个你想要输入的数： &quot;)\nprint(type(x)) \n#请随机输入一个你想要输入的数： 1 &lt;class &#39;str&#39;&gt;\n\n我们发现他是 str 也就是字符型，从此我们知道，python是默认输入的东西为字符型，但是我们可以直接转换为别的类型需要注意的是自己直接定义的数是相对应的数值类型比如 x&#x3D;0.2  x就是float型\nx&#x3D;int(x)\nprint(type(x))\n#此时的打印的数据类型就是int型了\n\n在python中不同类型的值是不可以直接比较的\n# x输入为6\nprint(x &#x3D;&#x3D; 6) # 结果为False\nx&#x3D;int(x)\nprint(x &#x3D;&#x3D; 6) # 结果就是true了\n\n另外python中小数的精度是有问题的，比如下面这段\nx&#x3D;0.1\ny&#x3D;0.2\nprint(x+y)\nprint(x+y &#x3D;&#x3D; 0.3)\n\n我们会神奇的发现结果为0.30000000000000004 和 False这是因为计算机存储数的原理导致的，所以小数做不到完全精确，不过我们可以借助与函数来实现精确的小数\nimport decimal #导入decimal 函数\nx&#x3D;decimal.Decimal(&#39;0.1&#39;)\ny&#x3D;decimal.Decimal(&#39;0.2&#39;)\nprint(x+y)\n\n此时我们发现我们输出的数就是0.3了\n","slug":"python第三章","date":"2021-11-22T11:09:30.350Z","categories_index":"python","tags_index":"python","author_index":"yuri2078"},{"id":"ae969b28ee76ca213c35889e63b4843f","title":"小米11刷gsi","content":"分享一下大佬 @和奥奥学Py 的vab分区机型刷gsi教程不要在问我别的有没有了，我不是大佬，我只是一个搬运工而已，教程放在这里，自己动手丰衣足食理论上小米11p 11u [流汗滑稽]也可以\n前言：    本教程原帖链接 https://fiime.cn/thread/463\n因为各种人各种不同的情况，我就不一一解释里面的情况了，懂得自己看着原来的教程自己省略一些步骤，不懂得老老实实跟着我的教程走，虽然可能不用这么麻烦，不过总归没有错\n请提前备份数据！请提前备份数据！请提前备份数据！请提前备份数据！请提前备份数据！大佬的原教程：小米11刷入GSI&#x2F;SGSI镜像步骤1.解密动态分区文件fastboot –disable-verification flash vbmeta2.刷入MIUI recovery(如果你是线刷完稳定版MIUI的话就不用刷这个了，跳过就是)命令：fastboot flash recovery 加实际地址3.进入到fastbooted模式必须在fastboot模式下才能进入fastbootd模式使用命令(回车)fastboot reboot fastboot兔子界面蓝色文字变成黄色文字 仔细观察OK，刷完了H。刷入GSI ROM使用命令fastboot flash system 加实际地址6.执行双清DATA使用命令(回车)fastboot -w请提前备份数据！请提前备份数据！\n小白专用教程：\n1 下载所需的东西miflash （我用的是2018.5版本）miui12 线刷包想要刷的gsi （dot os）gsi链接 ：https://github.com/phhusson/treble_experimentations/wiki/Generic-System-Image-(GSI)-list 下载ab的 用魔法下载会变得快点[受虐滑稽]\n所需工具链接 https://wwi.lanzoui.com/b016j5bcf 密码:3pd5\n2 全部下载好了，手机链接电脑把文件全部拖入电脑解压miflash压缩包解压miui线刷包（第一次解压出来是一个tar后缀的压缩包，要再解压一次，知道解压出来的是一个文件夹）\n3 准备阶段解压miflash 双击里面的 XiaoMiflash.exe 第一用这需要点击左上角 Driver 安装驱动\n然后点击选择，选择刚刚解压出来的线刷包\n如果出现 couldnt find flash script 那就是文件夹选在错了，一定要选择有bat命令文件的外层文件夹\n4 重置阶段点击 加载设备 加载出来后，看下下面对应的命令有没有选择好别点全部删除并上锁就行，其他两个看你自己刷完等它重启，你可以等它进系统再进fast boot 也可以直接强制关机直接进fastboot\n5 推送命令阶段文件夹目录可以自己改，对应的命令的目录和名字也要改，懂得自己改，不明白怎么改的就按我说的来在c盘根目录建立名为venus的文件夹把解压出来的线刷包里image目录下的 vbmeta.img 和 gsi镜像放进文件夹解压FiimeROM工具箱 打开 Fiime命令行工具箱.exe 在弹出的界面输入按顺序输入命令\n1 fastboot –disable-verification flash vbmeta C:\\venus\\vbmeta.img2 fastboot reboot fastboot （刷完这个命令会重启到fastbootd 看到字体变成黄色的就成功了）3 fastboot flash system C:\\venus\\dotos.img （名字为镜像的名字）4 fastboot -w （格式化 ）5 fastboot reboot （ 重启）\n","slug":"小米11刷gsi","date":"2021-11-20T08:00:21.615Z","categories_index":"教程","tags_index":"教程","author_index":"yuri2078"}]